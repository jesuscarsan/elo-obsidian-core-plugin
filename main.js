/* eslint-disable */

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/@google+genai@1.39.0/node_modules/@google/genai/dist/web/index.mjs
var web_exports = {};
__export(web_exports, {
  ActivityHandling: () => ActivityHandling,
  AdapterSize: () => AdapterSize,
  ApiError: () => ApiError,
  ApiSpec: () => ApiSpec,
  AuthType: () => AuthType,
  Batches: () => Batches,
  Behavior: () => Behavior,
  BlockedReason: () => BlockedReason,
  Caches: () => Caches,
  CancelTuningJobResponse: () => CancelTuningJobResponse,
  Chat: () => Chat,
  Chats: () => Chats,
  ComputeTokensResponse: () => ComputeTokensResponse,
  ContentReferenceImage: () => ContentReferenceImage,
  ControlReferenceImage: () => ControlReferenceImage,
  ControlReferenceType: () => ControlReferenceType,
  CountTokensResponse: () => CountTokensResponse,
  CreateFileResponse: () => CreateFileResponse,
  DeleteCachedContentResponse: () => DeleteCachedContentResponse,
  DeleteFileResponse: () => DeleteFileResponse,
  DeleteModelResponse: () => DeleteModelResponse,
  DocumentState: () => DocumentState,
  DynamicRetrievalConfigMode: () => DynamicRetrievalConfigMode,
  EditImageResponse: () => EditImageResponse,
  EditMode: () => EditMode,
  EmbedContentResponse: () => EmbedContentResponse,
  EndSensitivity: () => EndSensitivity,
  Environment: () => Environment,
  FeatureSelectionPreference: () => FeatureSelectionPreference,
  FileSource: () => FileSource,
  FileState: () => FileState,
  Files: () => Files,
  FinishReason: () => FinishReason,
  FunctionCallingConfigMode: () => FunctionCallingConfigMode,
  FunctionResponse: () => FunctionResponse,
  FunctionResponseBlob: () => FunctionResponseBlob,
  FunctionResponseFileData: () => FunctionResponseFileData,
  FunctionResponsePart: () => FunctionResponsePart,
  FunctionResponseScheduling: () => FunctionResponseScheduling,
  GenerateContentResponse: () => GenerateContentResponse,
  GenerateContentResponsePromptFeedback: () => GenerateContentResponsePromptFeedback,
  GenerateContentResponseUsageMetadata: () => GenerateContentResponseUsageMetadata,
  GenerateImagesResponse: () => GenerateImagesResponse,
  GenerateVideosOperation: () => GenerateVideosOperation,
  GenerateVideosResponse: () => GenerateVideosResponse,
  GoogleGenAI: () => GoogleGenAI,
  HarmBlockMethod: () => HarmBlockMethod,
  HarmBlockThreshold: () => HarmBlockThreshold,
  HarmCategory: () => HarmCategory,
  HarmProbability: () => HarmProbability,
  HarmSeverity: () => HarmSeverity,
  HttpElementLocation: () => HttpElementLocation,
  HttpResponse: () => HttpResponse,
  ImagePromptLanguage: () => ImagePromptLanguage,
  ImportFileOperation: () => ImportFileOperation,
  ImportFileResponse: () => ImportFileResponse,
  InlinedEmbedContentResponse: () => InlinedEmbedContentResponse,
  InlinedResponse: () => InlinedResponse,
  JobState: () => JobState,
  Language: () => Language,
  ListBatchJobsResponse: () => ListBatchJobsResponse,
  ListCachedContentsResponse: () => ListCachedContentsResponse,
  ListDocumentsResponse: () => ListDocumentsResponse,
  ListFileSearchStoresResponse: () => ListFileSearchStoresResponse,
  ListFilesResponse: () => ListFilesResponse,
  ListModelsResponse: () => ListModelsResponse,
  ListTuningJobsResponse: () => ListTuningJobsResponse,
  Live: () => Live,
  LiveClientToolResponse: () => LiveClientToolResponse,
  LiveMusicPlaybackControl: () => LiveMusicPlaybackControl,
  LiveMusicServerMessage: () => LiveMusicServerMessage,
  LiveSendToolResponseParameters: () => LiveSendToolResponseParameters,
  LiveServerMessage: () => LiveServerMessage,
  MaskReferenceImage: () => MaskReferenceImage,
  MaskReferenceMode: () => MaskReferenceMode,
  MediaModality: () => MediaModality,
  MediaResolution: () => MediaResolution,
  Modality: () => Modality,
  Models: () => Models,
  MusicGenerationMode: () => MusicGenerationMode,
  Operations: () => Operations,
  Outcome: () => Outcome,
  PagedItem: () => PagedItem,
  Pager: () => Pager,
  PartMediaResolutionLevel: () => PartMediaResolutionLevel,
  PersonGeneration: () => PersonGeneration,
  PhishBlockThreshold: () => PhishBlockThreshold,
  RawReferenceImage: () => RawReferenceImage,
  RecontextImageResponse: () => RecontextImageResponse,
  RegisterFilesResponse: () => RegisterFilesResponse,
  ReplayResponse: () => ReplayResponse,
  ResourceScope: () => ResourceScope,
  SafetyFilterLevel: () => SafetyFilterLevel,
  Scale: () => Scale,
  SegmentImageResponse: () => SegmentImageResponse,
  SegmentMode: () => SegmentMode,
  Session: () => Session,
  SingleEmbedContentResponse: () => SingleEmbedContentResponse,
  StartSensitivity: () => StartSensitivity,
  StyleReferenceImage: () => StyleReferenceImage,
  SubjectReferenceImage: () => SubjectReferenceImage,
  SubjectReferenceType: () => SubjectReferenceType,
  ThinkingLevel: () => ThinkingLevel,
  Tokens: () => Tokens,
  TrafficType: () => TrafficType,
  TuningMethod: () => TuningMethod,
  TuningMode: () => TuningMode,
  TuningTask: () => TuningTask,
  TurnCompleteReason: () => TurnCompleteReason,
  TurnCoverage: () => TurnCoverage,
  Type: () => Type,
  UploadToFileSearchStoreOperation: () => UploadToFileSearchStoreOperation,
  UploadToFileSearchStoreResponse: () => UploadToFileSearchStoreResponse,
  UploadToFileSearchStoreResumableResponse: () => UploadToFileSearchStoreResumableResponse,
  UpscaleImageResponse: () => UpscaleImageResponse,
  UrlRetrievalStatus: () => UrlRetrievalStatus,
  VadSignalType: () => VadSignalType,
  VideoCompressionQuality: () => VideoCompressionQuality,
  VideoGenerationMaskMode: () => VideoGenerationMaskMode,
  VideoGenerationReferenceType: () => VideoGenerationReferenceType,
  VoiceActivityType: () => VoiceActivityType,
  createFunctionResponsePartFromBase64: () => createFunctionResponsePartFromBase64,
  createFunctionResponsePartFromUri: () => createFunctionResponsePartFromUri,
  createModelContent: () => createModelContent,
  createPartFromBase64: () => createPartFromBase64,
  createPartFromCodeExecutionResult: () => createPartFromCodeExecutionResult,
  createPartFromExecutableCode: () => createPartFromExecutableCode,
  createPartFromFunctionCall: () => createPartFromFunctionCall,
  createPartFromFunctionResponse: () => createPartFromFunctionResponse,
  createPartFromText: () => createPartFromText,
  createPartFromUri: () => createPartFromUri,
  createUserContent: () => createUserContent,
  mcpToTool: () => mcpToTool,
  setDefaultBaseUrls: () => setDefaultBaseUrls
});
function setDefaultBaseUrls(baseUrlParams) {
  _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;
  _defaultBaseVertexUrl = baseUrlParams.vertexUrl;
}
function getDefaultBaseUrls() {
  return {
    geminiUrl: _defaultBaseGeminiUrl,
    vertexUrl: _defaultBaseVertexUrl
  };
}
function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
  var _a2, _b;
  if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {
    const defaultBaseUrls = getDefaultBaseUrls();
    if (vertexai) {
      return (_a2 = defaultBaseUrls.vertexUrl) !== null && _a2 !== void 0 ? _a2 : vertexBaseUrlFromEnv;
    } else {
      return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;
    }
  }
  return httpOptions.baseUrl;
}
function formatMap(templateString, valueMap) {
  const regex = /\{([^}]+)\}/g;
  return templateString.replace(regex, (match, key) => {
    if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
      const value = valueMap[key];
      return value !== void 0 && value !== null ? String(value) : "";
    } else {
      throw new Error(`Key '${key}' not found in valueMap.`);
    }
  });
}
function setValueByPath(data, keys, value) {
  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (key.endsWith("[]")) {
      const keyName = key.slice(0, -2);
      if (!(keyName in data)) {
        if (Array.isArray(value)) {
          data[keyName] = Array.from({ length: value.length }, () => ({}));
        } else {
          throw new Error(`Value must be a list given an array path ${key}`);
        }
      }
      if (Array.isArray(data[keyName])) {
        const arrayData = data[keyName];
        if (Array.isArray(value)) {
          for (let j = 0; j < arrayData.length; j++) {
            const entry = arrayData[j];
            setValueByPath(entry, keys.slice(i + 1), value[j]);
          }
        } else {
          for (const d of arrayData) {
            setValueByPath(d, keys.slice(i + 1), value);
          }
        }
      }
      return;
    } else if (key.endsWith("[0]")) {
      const keyName = key.slice(0, -3);
      if (!(keyName in data)) {
        data[keyName] = [{}];
      }
      const arrayData = data[keyName];
      setValueByPath(arrayData[0], keys.slice(i + 1), value);
      return;
    }
    if (!data[key] || typeof data[key] !== "object") {
      data[key] = {};
    }
    data = data[key];
  }
  const keyToSet = keys[keys.length - 1];
  const existingData = data[keyToSet];
  if (existingData !== void 0) {
    if (!value || typeof value === "object" && Object.keys(value).length === 0) {
      return;
    }
    if (value === existingData) {
      return;
    }
    if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
      Object.assign(existingData, value);
    } else {
      throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
    }
  } else {
    if (keyToSet === "_self" && typeof value === "object" && value !== null && !Array.isArray(value)) {
      const valueAsRecord = value;
      Object.assign(data, valueAsRecord);
    } else {
      data[keyToSet] = value;
    }
  }
}
function getValueByPath(data, keys, defaultValue = void 0) {
  try {
    if (keys.length === 1 && keys[0] === "_self") {
      return data;
    }
    for (let i = 0; i < keys.length; i++) {
      if (typeof data !== "object" || data === null) {
        return defaultValue;
      }
      const key = keys[i];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        if (keyName in data) {
          const arrayData = data[keyName];
          if (!Array.isArray(arrayData)) {
            return defaultValue;
          }
          return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1), defaultValue));
        } else {
          return defaultValue;
        }
      } else {
        data = data[key];
      }
    }
    return data;
  } catch (error) {
    if (error instanceof TypeError) {
      return defaultValue;
    }
    throw error;
  }
}
function moveValueByPath(data, paths) {
  for (const [sourcePath, destPath] of Object.entries(paths)) {
    const sourceKeys = sourcePath.split(".");
    const destKeys = destPath.split(".");
    const excludeKeys = /* @__PURE__ */ new Set();
    let wildcardIdx = -1;
    for (let i = 0; i < sourceKeys.length; i++) {
      if (sourceKeys[i] === "*") {
        wildcardIdx = i;
        break;
      }
    }
    if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {
      for (let i = wildcardIdx; i < destKeys.length; i++) {
        const key = destKeys[i];
        if (key !== "*" && !key.endsWith("[]") && !key.endsWith("[0]")) {
          excludeKeys.add(key);
        }
      }
    }
    _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);
  }
}
function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {
  if (keyIdx >= sourceKeys.length) {
    return;
  }
  if (typeof data !== "object" || data === null) {
    return;
  }
  const key = sourceKeys[keyIdx];
  if (key.endsWith("[]")) {
    const keyName = key.slice(0, -2);
    const dataRecord = data;
    if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {
      for (const item of dataRecord[keyName]) {
        _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);
      }
    }
  } else if (key === "*") {
    if (typeof data === "object" && data !== null && !Array.isArray(data)) {
      const dataRecord = data;
      const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith("_") && !excludeKeys.has(k));
      const valuesToMove = {};
      for (const k of keysToMove) {
        valuesToMove[k] = dataRecord[k];
      }
      for (const [k, v] of Object.entries(valuesToMove)) {
        const newDestKeys = [];
        for (const dk of destKeys.slice(keyIdx)) {
          if (dk === "*") {
            newDestKeys.push(k);
          } else {
            newDestKeys.push(dk);
          }
        }
        setValueByPath(dataRecord, newDestKeys, v);
      }
      for (const k of keysToMove) {
        delete dataRecord[k];
      }
    }
  } else {
    const dataRecord = data;
    if (key in dataRecord) {
      _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);
    }
  }
}
function tBytes$1(fromBytes) {
  if (typeof fromBytes !== "string") {
    throw new Error("fromImageBytes must be a string");
  }
  return fromBytes;
}
function fetchPredictOperationParametersToVertex(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["operationName"], fromOperationName);
  }
  const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
  if (fromResourceName != null) {
    setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
  }
  return toObject;
}
function generateVideosOperationFromMldev$1(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, [
    "response",
    "generateVideoResponse"
  ]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(fromResponse));
  }
  return toObject;
}
function generateVideosOperationFromVertex$1(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(fromResponse));
  }
  return toObject;
}
function generateVideosResponseFromMldev$1(fromObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, [
    "generatedSamples"
  ]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosResponseFromVertex$1(fromObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromVertex$1(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generatedVideoFromMldev$1(fromObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromMldev$1(fromVideo));
  }
  return toObject;
}
function generatedVideoFromVertex$1(fromObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["_self"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromVertex$1(fromVideo));
  }
  return toObject;
}
function getOperationParametersToMldev(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
  }
  return toObject;
}
function getOperationParametersToVertex(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
  }
  return toObject;
}
function importFileOperationFromMldev$1(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], importFileResponseFromMldev$1(fromResponse));
  }
  return toObject;
}
function importFileResponseFromMldev$1(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromParent = getValueByPath(fromObject, ["parent"]);
  if (fromParent != null) {
    setValueByPath(toObject, ["parent"], fromParent);
  }
  const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
  if (fromDocumentName != null) {
    setValueByPath(toObject, ["documentName"], fromDocumentName);
  }
  return toObject;
}
function uploadToFileSearchStoreOperationFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], uploadToFileSearchStoreResponseFromMldev(fromResponse));
  }
  return toObject;
}
function uploadToFileSearchStoreResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromParent = getValueByPath(fromObject, ["parent"]);
  if (fromParent != null) {
    setValueByPath(toObject, ["parent"], fromParent);
  }
  const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
  if (fromDocumentName != null) {
    setValueByPath(toObject, ["documentName"], fromDocumentName);
  }
  return toObject;
}
function videoFromMldev$1(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["encoding"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function videoFromVertex$1(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function createFunctionResponsePartFromBase64(data, mimeType) {
  return {
    inlineData: {
      data,
      mimeType
    }
  };
}
function createFunctionResponsePartFromUri(uri, mimeType) {
  return {
    fileData: {
      fileUri: uri,
      mimeType
    }
  };
}
function createPartFromUri(uri, mimeType, mediaResolution) {
  return Object.assign({ fileData: {
    fileUri: uri,
    mimeType
  } }, mediaResolution && { mediaResolution: { level: mediaResolution } });
}
function createPartFromText(text) {
  return {
    text
  };
}
function createPartFromFunctionCall(name, args) {
  return {
    functionCall: {
      name,
      args
    }
  };
}
function createPartFromFunctionResponse(id, name, response, parts = []) {
  return {
    functionResponse: Object.assign({ id, name, response }, parts.length > 0 && { parts })
  };
}
function createPartFromBase64(data, mimeType, mediaResolution) {
  return Object.assign({ inlineData: {
    data,
    mimeType
  } }, mediaResolution && { mediaResolution: { level: mediaResolution } });
}
function createPartFromCodeExecutionResult(outcome, output) {
  return {
    codeExecutionResult: {
      outcome,
      output
    }
  };
}
function createPartFromExecutableCode(code, language) {
  return {
    executableCode: {
      code,
      language
    }
  };
}
function _isPart(obj) {
  if (typeof obj === "object" && obj !== null) {
    return "fileData" in obj || "text" in obj || "functionCall" in obj || "functionResponse" in obj || "inlineData" in obj || "videoMetadata" in obj || "codeExecutionResult" in obj || "executableCode" in obj;
  }
  return false;
}
function _toParts(partOrString) {
  const parts = [];
  if (typeof partOrString === "string") {
    parts.push(createPartFromText(partOrString));
  } else if (_isPart(partOrString)) {
    parts.push(partOrString);
  } else if (Array.isArray(partOrString)) {
    if (partOrString.length === 0) {
      throw new Error("partOrString cannot be an empty array");
    }
    for (const part of partOrString) {
      if (typeof part === "string") {
        parts.push(createPartFromText(part));
      } else if (_isPart(part)) {
        parts.push(part);
      } else {
        throw new Error("element in PartUnion must be a Part object or string");
      }
    }
  } else {
    throw new Error("partOrString must be a Part object, string, or array");
  }
  return parts;
}
function createUserContent(partOrString) {
  return {
    role: "user",
    parts: _toParts(partOrString)
  };
}
function createModelContent(partOrString) {
  return {
    role: "model",
    parts: _toParts(partOrString)
  };
}
function tModel(apiClient, model) {
  if (!model || typeof model !== "string") {
    throw new Error("model is required and must be a string");
  }
  if (model.includes("..") || model.includes("?") || model.includes("&")) {
    throw new Error("invalid model parameter");
  }
  if (apiClient.isVertexAI()) {
    if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
      return model;
    } else if (model.indexOf("/") >= 0) {
      const parts = model.split("/", 2);
      return `publishers/${parts[0]}/models/${parts[1]}`;
    } else {
      return `publishers/google/models/${model}`;
    }
  } else {
    if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
      return model;
    } else {
      return `models/${model}`;
    }
  }
}
function tCachesModel(apiClient, model) {
  const transformedModel = tModel(apiClient, model);
  if (!transformedModel) {
    return "";
  }
  if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
    return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
  } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
    return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
  } else {
    return transformedModel;
  }
}
function tBlobs(blobs) {
  if (Array.isArray(blobs)) {
    return blobs.map((blob) => tBlob(blob));
  } else {
    return [tBlob(blobs)];
  }
}
function tBlob(blob) {
  if (typeof blob === "object" && blob !== null) {
    return blob;
  }
  throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
}
function tImageBlob(blob) {
  const transformedBlob = tBlob(blob);
  if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
    return transformedBlob;
  }
  throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tAudioBlob(blob) {
  const transformedBlob = tBlob(blob);
  if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
    return transformedBlob;
  }
  throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tPart(origin) {
  if (origin === null || origin === void 0) {
    throw new Error("PartUnion is required");
  }
  if (typeof origin === "object") {
    return origin;
  }
  if (typeof origin === "string") {
    return { text: origin };
  }
  throw new Error(`Unsupported part type: ${typeof origin}`);
}
function tParts(origin) {
  if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
    throw new Error("PartListUnion is required");
  }
  if (Array.isArray(origin)) {
    return origin.map((item) => tPart(item));
  }
  return [tPart(origin)];
}
function _isContent(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
}
function _isFunctionCallPart(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
}
function _isFunctionResponsePart(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
}
function tContent(origin) {
  if (origin === null || origin === void 0) {
    throw new Error("ContentUnion is required");
  }
  if (_isContent(origin)) {
    return origin;
  }
  return {
    role: "user",
    parts: tParts(origin)
  };
}
function tContentsForEmbed(apiClient, origin) {
  if (!origin) {
    return [];
  }
  if (apiClient.isVertexAI() && Array.isArray(origin)) {
    return origin.flatMap((item) => {
      const content = tContent(item);
      if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
        return [content.parts[0].text];
      }
      return [];
    });
  } else if (apiClient.isVertexAI()) {
    const content = tContent(origin);
    if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
      return [content.parts[0].text];
    }
    return [];
  }
  if (Array.isArray(origin)) {
    return origin.map((item) => tContent(item));
  }
  return [tContent(origin)];
}
function tContents(origin) {
  if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
    throw new Error("contents are required");
  }
  if (!Array.isArray(origin)) {
    if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
      throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
    }
    return [tContent(origin)];
  }
  const result = [];
  const accumulatedParts = [];
  const isContentArray = _isContent(origin[0]);
  for (const item of origin) {
    const isContent = _isContent(item);
    if (isContent != isContentArray) {
      throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
    }
    if (isContent) {
      result.push(item);
    } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
      throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
    } else {
      accumulatedParts.push(item);
    }
  }
  if (!isContentArray) {
    result.push({ role: "user", parts: tParts(accumulatedParts) });
  }
  return result;
}
function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
  if (typeList.includes("null")) {
    resultingSchema["nullable"] = true;
  }
  const listWithoutNull = typeList.filter((type) => type !== "null");
  if (listWithoutNull.length === 1) {
    resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
  } else {
    resultingSchema["anyOf"] = [];
    for (const i of listWithoutNull) {
      resultingSchema["anyOf"].push({
        "type": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED
      });
    }
  }
}
function processJsonSchema(_jsonSchema) {
  const genAISchema = {};
  const schemaFieldNames = ["items"];
  const listSchemaFieldNames = ["anyOf"];
  const dictSchemaFieldNames = ["properties"];
  if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
    throw new Error("type and anyOf cannot be both populated.");
  }
  const incomingAnyOf = _jsonSchema["anyOf"];
  if (incomingAnyOf != null && incomingAnyOf.length == 2) {
    if (incomingAnyOf[0]["type"] === "null") {
      genAISchema["nullable"] = true;
      _jsonSchema = incomingAnyOf[1];
    } else if (incomingAnyOf[1]["type"] === "null") {
      genAISchema["nullable"] = true;
      _jsonSchema = incomingAnyOf[0];
    }
  }
  if (_jsonSchema["type"] instanceof Array) {
    flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
  }
  for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
    if (fieldValue == null) {
      continue;
    }
    if (fieldName == "type") {
      if (fieldValue === "null") {
        throw new Error("type: null can not be the only possible type for the field.");
      }
      if (fieldValue instanceof Array) {
        continue;
      }
      genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
    } else if (schemaFieldNames.includes(fieldName)) {
      genAISchema[fieldName] = processJsonSchema(fieldValue);
    } else if (listSchemaFieldNames.includes(fieldName)) {
      const listSchemaFieldValue = [];
      for (const item of fieldValue) {
        if (item["type"] == "null") {
          genAISchema["nullable"] = true;
          continue;
        }
        listSchemaFieldValue.push(processJsonSchema(item));
      }
      genAISchema[fieldName] = listSchemaFieldValue;
    } else if (dictSchemaFieldNames.includes(fieldName)) {
      const dictSchemaFieldValue = {};
      for (const [key, value] of Object.entries(fieldValue)) {
        dictSchemaFieldValue[key] = processJsonSchema(value);
      }
      genAISchema[fieldName] = dictSchemaFieldValue;
    } else {
      if (fieldName === "additionalProperties") {
        continue;
      }
      genAISchema[fieldName] = fieldValue;
    }
  }
  return genAISchema;
}
function tSchema(schema) {
  return processJsonSchema(schema);
}
function tSpeechConfig(speechConfig) {
  if (typeof speechConfig === "object") {
    return speechConfig;
  } else if (typeof speechConfig === "string") {
    return {
      voiceConfig: {
        prebuiltVoiceConfig: {
          voiceName: speechConfig
        }
      }
    };
  } else {
    throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
  }
}
function tLiveSpeechConfig(speechConfig) {
  if ("multiSpeakerVoiceConfig" in speechConfig) {
    throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
  }
  return speechConfig;
}
function tTool(tool) {
  if (tool.functionDeclarations) {
    for (const functionDeclaration of tool.functionDeclarations) {
      if (functionDeclaration.parameters) {
        if (!Object.keys(functionDeclaration.parameters).includes("$schema")) {
          functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
        } else {
          if (!functionDeclaration.parametersJsonSchema) {
            functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
            delete functionDeclaration.parameters;
          }
        }
      }
      if (functionDeclaration.response) {
        if (!Object.keys(functionDeclaration.response).includes("$schema")) {
          functionDeclaration.response = processJsonSchema(functionDeclaration.response);
        } else {
          if (!functionDeclaration.responseJsonSchema) {
            functionDeclaration.responseJsonSchema = functionDeclaration.response;
            delete functionDeclaration.response;
          }
        }
      }
    }
  }
  return tool;
}
function tTools(tools) {
  if (tools === void 0 || tools === null) {
    throw new Error("tools is required");
  }
  if (!Array.isArray(tools)) {
    throw new Error("tools is required and must be an array of Tools");
  }
  const result = [];
  for (const tool of tools) {
    result.push(tool);
  }
  return result;
}
function resourceName(client, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
  const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
  if (client.isVertexAI()) {
    if (resourceName2.startsWith("projects/")) {
      return resourceName2;
    } else if (resourceName2.startsWith("locations/")) {
      return `projects/${client.getProject()}/${resourceName2}`;
    } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
      return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName2}`;
    } else if (shouldAppendPrefix) {
      return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName2}`;
    } else {
      return resourceName2;
    }
  }
  if (shouldAppendPrefix) {
    return `${resourcePrefix}/${resourceName2}`;
  }
  return resourceName2;
}
function tCachedContentName(apiClient, name) {
  if (typeof name !== "string") {
    throw new Error("name must be a string");
  }
  return resourceName(apiClient, name, "cachedContents");
}
function tTuningJobStatus(status) {
  switch (status) {
    case "STATE_UNSPECIFIED":
      return "JOB_STATE_UNSPECIFIED";
    case "CREATING":
      return "JOB_STATE_RUNNING";
    case "ACTIVE":
      return "JOB_STATE_SUCCEEDED";
    case "FAILED":
      return "JOB_STATE_FAILED";
    default:
      return status;
  }
}
function tBytes(fromImageBytes) {
  return tBytes$1(fromImageBytes);
}
function _isFile(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
}
function isGeneratedVideo(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
}
function isVideo(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
}
function tFileName(fromName) {
  var _a2;
  let name;
  if (_isFile(fromName)) {
    name = fromName.name;
  }
  if (isVideo(fromName)) {
    name = fromName.uri;
    if (name === void 0) {
      return void 0;
    }
  }
  if (isGeneratedVideo(fromName)) {
    name = (_a2 = fromName.video) === null || _a2 === void 0 ? void 0 : _a2.uri;
    if (name === void 0) {
      return void 0;
    }
  }
  if (typeof fromName === "string") {
    name = fromName;
  }
  if (name === void 0) {
    throw new Error("Could not extract file name from the provided input.");
  }
  if (name.startsWith("https://")) {
    const suffix = name.split("files/")[1];
    const match = suffix.match(/[a-z0-9]+/);
    if (match === null) {
      throw new Error(`Could not extract file name from URI ${name}`);
    }
    name = match[0];
  } else if (name.startsWith("files/")) {
    name = name.split("files/")[1];
  }
  return name;
}
function tModelsUrl(apiClient, baseModels) {
  let res;
  if (apiClient.isVertexAI()) {
    res = baseModels ? "publishers/google/models" : "models";
  } else {
    res = baseModels ? "models" : "tunedModels";
  }
  return res;
}
function tExtractModels(response) {
  for (const key of ["models", "tunedModels", "publisherModels"]) {
    if (hasField(response, key)) {
      return response[key];
    }
  }
  return [];
}
function hasField(data, fieldName) {
  return data !== null && typeof data === "object" && fieldName in data;
}
function mcpToGeminiTool(mcpTool, config = {}) {
  const mcpToolSchema = mcpTool;
  const functionDeclaration = {
    name: mcpToolSchema["name"],
    description: mcpToolSchema["description"],
    parametersJsonSchema: mcpToolSchema["inputSchema"]
  };
  if (mcpToolSchema["outputSchema"]) {
    functionDeclaration["responseJsonSchema"] = mcpToolSchema["outputSchema"];
  }
  if (config.behavior) {
    functionDeclaration["behavior"] = config.behavior;
  }
  const geminiTool = {
    functionDeclarations: [
      functionDeclaration
    ]
  };
  return geminiTool;
}
function mcpToolsToGeminiTool(mcpTools, config = {}) {
  const functionDeclarations = [];
  const toolNames = /* @__PURE__ */ new Set();
  for (const mcpTool of mcpTools) {
    const mcpToolName = mcpTool.name;
    if (toolNames.has(mcpToolName)) {
      throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
    }
    toolNames.add(mcpToolName);
    const geminiTool = mcpToGeminiTool(mcpTool, config);
    if (geminiTool.functionDeclarations) {
      functionDeclarations.push(...geminiTool.functionDeclarations);
    }
  }
  return { functionDeclarations };
}
function tBatchJobSource(client, src) {
  let sourceObj;
  if (typeof src === "string") {
    if (client.isVertexAI()) {
      if (src.startsWith("gs://")) {
        sourceObj = { format: "jsonl", gcsUri: [src] };
      } else if (src.startsWith("bq://")) {
        sourceObj = { format: "bigquery", bigqueryUri: src };
      } else {
        throw new Error(`Unsupported string source for Vertex AI: ${src}`);
      }
    } else {
      if (src.startsWith("files/")) {
        sourceObj = { fileName: src };
      } else {
        throw new Error(`Unsupported string source for Gemini API: ${src}`);
      }
    }
  } else if (Array.isArray(src)) {
    if (client.isVertexAI()) {
      throw new Error("InlinedRequest[] is not supported in Vertex AI.");
    }
    sourceObj = { inlinedRequests: src };
  } else {
    sourceObj = src;
  }
  const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;
  const mldevSourcesCount = [
    sourceObj.inlinedRequests,
    sourceObj.fileName
  ].filter(Boolean).length;
  if (client.isVertexAI()) {
    if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {
      throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
    }
  } else {
    if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {
      throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
    }
  }
  return sourceObj;
}
function tBatchJobDestination(dest) {
  if (typeof dest !== "string") {
    return dest;
  }
  const destString = dest;
  if (destString.startsWith("gs://")) {
    return {
      format: "jsonl",
      gcsUri: destString
    };
  } else if (destString.startsWith("bq://")) {
    return {
      format: "bigquery",
      bigqueryUri: destString
    };
  } else {
    throw new Error(`Unsupported destination: ${destString}`);
  }
}
function tRecvBatchJobDestination(dest) {
  if (typeof dest !== "object" || dest === null) {
    return {};
  }
  const obj = dest;
  const inlineResponsesVal = obj["inlinedResponses"];
  if (typeof inlineResponsesVal !== "object" || inlineResponsesVal === null) {
    return dest;
  }
  const inlineResponsesObj = inlineResponsesVal;
  const responsesArray = inlineResponsesObj["inlinedResponses"];
  if (!Array.isArray(responsesArray) || responsesArray.length === 0) {
    return dest;
  }
  let hasEmbedding = false;
  for (const responseItem of responsesArray) {
    if (typeof responseItem !== "object" || responseItem === null) {
      continue;
    }
    const responseItemObj = responseItem;
    const responseVal = responseItemObj["response"];
    if (typeof responseVal !== "object" || responseVal === null) {
      continue;
    }
    const responseObj = responseVal;
    if (responseObj["embedding"] !== void 0) {
      hasEmbedding = true;
      break;
    }
  }
  if (hasEmbedding) {
    obj["inlinedEmbedContentResponses"] = obj["inlinedResponses"];
    delete obj["inlinedResponses"];
  }
  return dest;
}
function tBatchJobName(apiClient, name) {
  const nameString = name;
  if (!apiClient.isVertexAI()) {
    const mldevPattern = /batches\/[^/]+$/;
    if (mldevPattern.test(nameString)) {
      return nameString.split("/").pop();
    } else {
      throw new Error(`Invalid batch job name: ${nameString}.`);
    }
  }
  const vertexPattern = /^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/;
  if (vertexPattern.test(nameString)) {
    return nameString.split("/").pop();
  } else if (/^\d+$/.test(nameString)) {
    return nameString;
  } else {
    throw new Error(`Invalid batch job name: ${nameString}.`);
  }
}
function tJobState(state) {
  const stateString = state;
  if (stateString === "BATCH_STATE_UNSPECIFIED") {
    return "JOB_STATE_UNSPECIFIED";
  } else if (stateString === "BATCH_STATE_PENDING") {
    return "JOB_STATE_PENDING";
  } else if (stateString === "BATCH_STATE_RUNNING") {
    return "JOB_STATE_RUNNING";
  } else if (stateString === "BATCH_STATE_SUCCEEDED") {
    return "JOB_STATE_SUCCEEDED";
  } else if (stateString === "BATCH_STATE_FAILED") {
    return "JOB_STATE_FAILED";
  } else if (stateString === "BATCH_STATE_CANCELLED") {
    return "JOB_STATE_CANCELLED";
  } else if (stateString === "BATCH_STATE_EXPIRED") {
    return "JOB_STATE_EXPIRED";
  } else {
    return stateString;
  }
}
function batchJobDestinationFromMldev(fromObject) {
  const toObject = {};
  const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromInlinedResponses = getValueByPath(fromObject, [
    "inlinedResponses",
    "inlinedResponses"
  ]);
  if (fromInlinedResponses != null) {
    let transformedList = fromInlinedResponses;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return inlinedResponseFromMldev(item);
      });
    }
    setValueByPath(toObject, ["inlinedResponses"], transformedList);
  }
  const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [
    "inlinedEmbedContentResponses",
    "inlinedResponses"
  ]);
  if (fromInlinedEmbedContentResponses != null) {
    let transformedList = fromInlinedEmbedContentResponses;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["inlinedEmbedContentResponses"], transformedList);
  }
  return toObject;
}
function batchJobDestinationFromVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, [
    "gcsDestination",
    "outputUriPrefix"
  ]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, [
    "bigqueryDestination",
    "outputUri"
  ]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
  }
  return toObject;
}
function batchJobDestinationToVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["predictionsFormat"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
  }
  if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
    throw new Error("fileName parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedResponses"]) !== void 0) {
    throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedEmbedContentResponses"]) !== void 0) {
    throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function batchJobFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, [
    "metadata",
    "displayName"
  ]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromState = getValueByPath(fromObject, ["metadata", "state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tJobState(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, [
    "metadata",
    "createTime"
  ]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromEndTime = getValueByPath(fromObject, [
    "metadata",
    "endTime"
  ]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, [
    "metadata",
    "updateTime"
  ]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
  if (fromDest != null) {
    setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));
  }
  return toObject;
}
function batchJobFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tJobState(fromState));
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
  }
  const fromDest = getValueByPath(fromObject, ["outputConfig"]);
  if (fromDest != null) {
    setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));
  }
  const fromCompletionStats = getValueByPath(fromObject, [
    "completionStats"
  ]);
  if (fromCompletionStats != null) {
    setValueByPath(toObject, ["completionStats"], fromCompletionStats);
  }
  return toObject;
}
function batchJobSourceFromVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, [
    "bigquerySource",
    "inputUri"
  ]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
  }
  return toObject;
}
function batchJobSourceToMldev(apiClient, fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["format"]) !== void 0) {
    throw new Error("format parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["bigqueryUri"]) !== void 0) {
    throw new Error("bigqueryUri parameter is not supported in Gemini API.");
  }
  const fromFileName = getValueByPath(fromObject, ["fileName"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromInlinedRequests = getValueByPath(fromObject, [
    "inlinedRequests"
  ]);
  if (fromInlinedRequests != null) {
    let transformedList = fromInlinedRequests;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return inlinedRequestToMldev(apiClient, item);
      });
    }
    setValueByPath(toObject, ["requests", "requests"], transformedList);
  }
  return toObject;
}
function batchJobSourceToVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["instancesFormat"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
  }
  if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
    throw new Error("fileName parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedRequests"]) !== void 0) {
    throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function blobToMldev$4(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function cancelBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function cancelBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function candidateFromMldev$1(fromObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], fromContent);
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    let transformedList = fromSafetyRatings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["safetyRatings"], transformedList);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
  }
  return toObject;
}
function citationMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citationSources"]);
  if (fromCitations != null) {
    let transformedList = fromCitations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["citations"], transformedList);
  }
  return toObject;
}
function contentToMldev$4(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function createBatchJobConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
  }
  if (getValueByPath(fromObject, ["dest"]) !== void 0) {
    throw new Error("dest parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createBatchJobConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDest = getValueByPath(fromObject, ["dest"]);
  if (parentObject !== void 0 && fromDest != null) {
    setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
  }
  return toObject;
}
function createBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createBatchJobConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function createBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createBatchJobConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
  }
  return toObject;
}
function createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["batch", "inputConfig"], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function deleteBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function deleteBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function deleteResourceJobFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function deleteResourceJobFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function embedContentBatchToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContentsForEmbed(apiClient, fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["requests[]", "request", "content"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["_self"], embedContentConfigToMldev$1(fromConfig, toObject));
    moveValueByPath(toObject, { "requests[].*": "requests[].request.*" });
  }
  return toObject;
}
function embedContentConfigToMldev$1(fromObject, parentObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== void 0 && fromTaskType != null) {
    setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== void 0 && fromTitle != null) {
    setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== void 0 && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
  }
  if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
    throw new Error("mimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
    throw new Error("autoTruncate parameter is not supported in Gemini API.");
  }
  return toObject;
}
function embeddingsBatchJobSourceToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromFileName = getValueByPath(fromObject, ["fileName"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["file_name"], fromFileName);
  }
  const fromInlinedRequests = getValueByPath(fromObject, [
    "inlinedRequests"
  ]);
  if (fromInlinedRequests != null) {
    setValueByPath(toObject, ["requests"], embedContentBatchToMldev(apiClient, fromInlinedRequests));
  }
  return toObject;
}
function fileDataToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev$4(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionCallingConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
    throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== void 0 && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToMldev$1(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$4(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== void 0 && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
  }
  if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
  if (fromImageConfig != null) {
    setValueByPath(toObject, ["imageConfig"], imageConfigToMldev$1(fromImageConfig));
  }
  const fromEnableEnhancedCivicAnswers = getValueByPath(fromObject, [
    "enableEnhancedCivicAnswers"
  ]);
  if (fromEnableEnhancedCivicAnswers != null) {
    setValueByPath(toObject, ["enableEnhancedCivicAnswers"], fromEnableEnhancedCivicAnswers);
  }
  if (getValueByPath(fromObject, ["modelArmorConfig"]) !== void 0) {
    throw new Error("modelArmorConfig parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateContentResponseFromMldev$1(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function getBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function getBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function googleMapsToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function imageConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (fromAspectRatio != null) {
    setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (fromImageSize != null) {
    setValueByPath(toObject, ["imageSize"], fromImageSize);
  }
  if (getValueByPath(fromObject, ["personGeneration"]) !== void 0) {
    throw new Error("personGeneration parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
    throw new Error("outputMimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
    throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
  }
  return toObject;
}
function inlinedRequestToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["request", "contents"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ["request"], {})));
  }
  return toObject;
}
function inlinedResponseFromMldev(fromObject) {
  const toObject = {};
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function listBatchJobsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  if (getValueByPath(fromObject, ["filter"]) !== void 0) {
    throw new Error("filter parameter is not supported in Gemini API.");
  }
  return toObject;
}
function listBatchJobsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listBatchJobsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listBatchJobsConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listBatchJobsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listBatchJobsConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function listBatchJobsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
  if (fromBatchJobs != null) {
    let transformedList = fromBatchJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return batchJobFromMldev(item);
      });
    }
    setValueByPath(toObject, ["batchJobs"], transformedList);
  }
  return toObject;
}
function listBatchJobsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromBatchJobs = getValueByPath(fromObject, [
    "batchPredictionJobs"
  ]);
  if (fromBatchJobs != null) {
    let transformedList = fromBatchJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return batchJobFromVertex(item);
      });
    }
    setValueByPath(toObject, ["batchJobs"], transformedList);
  }
  return toObject;
}
function partToMldev$4(fromObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev$4(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function safetySettingToMldev$1(fromObject) {
  const toObject = {};
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  if (getValueByPath(fromObject, ["method"]) !== void 0) {
    throw new Error("method parameter is not supported in Gemini API.");
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function toolConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
  }
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
  }
  return toObject;
}
function toolToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$4(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function blobToMldev$3(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function contentToMldev$3(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$3(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function createCachedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (parentObject !== void 0 && fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$3(item);
      });
    }
    setValueByPath(parentObject, ["contents"], transformedList);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$3(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) {
    throw new Error("kmsKeyName parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createCachedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (parentObject !== void 0 && fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(parentObject, ["contents"], transformedList);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex$2(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
  }
  const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
  if (parentObject !== void 0 && fromKmsKeyName != null) {
    setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
  }
  return toObject;
}
function createCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createCachedContentConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function createCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createCachedContentConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function deleteCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  return toObject;
}
function deleteCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  return toObject;
}
function deleteCachedContentResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function deleteCachedContentResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function fileDataToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev$3(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionCallingConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
    throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionDeclarationToVertex$2(fromObject) {
  const toObject = {};
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function getCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  return toObject;
}
function getCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  return toObject;
}
function googleMapsToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function listCachedContentsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listCachedContentsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listCachedContentsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listCachedContentsConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listCachedContentsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listCachedContentsConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function listCachedContentsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromCachedContents = getValueByPath(fromObject, [
    "cachedContents"
  ]);
  if (fromCachedContents != null) {
    let transformedList = fromCachedContents;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["cachedContents"], transformedList);
  }
  return toObject;
}
function listCachedContentsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromCachedContents = getValueByPath(fromObject, [
    "cachedContents"
  ]);
  if (fromCachedContents != null) {
    let transformedList = fromCachedContents;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["cachedContents"], transformedList);
  }
  return toObject;
}
function partToMldev$3(fromObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev$3(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function toolConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
  }
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
  }
  return toObject;
}
function toolToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$3(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function toolToVertex$2(fromObject) {
  const toObject = {};
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
    throw new Error("fileSearch parameter is not supported in Vertex AI.");
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex$2(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function updateCachedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  return toObject;
}
function updateCachedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  return toObject;
}
function updateCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    updateCachedContentConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function updateCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    updateCachedContentConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f)
        i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function isValidResponse(response) {
  var _a2;
  if (response.candidates == void 0 || response.candidates.length === 0) {
    return false;
  }
  const content = (_a2 = response.candidates[0]) === null || _a2 === void 0 ? void 0 : _a2.content;
  if (content === void 0) {
    return false;
  }
  return isValidContent(content);
}
function isValidContent(content) {
  if (content.parts === void 0 || content.parts.length === 0) {
    return false;
  }
  for (const part of content.parts) {
    if (part === void 0 || Object.keys(part).length === 0) {
      return false;
    }
  }
  return true;
}
function validateHistory(history) {
  if (history.length === 0) {
    return;
  }
  for (const content of history) {
    if (content.role !== "user" && content.role !== "model") {
      throw new Error(`Role must be user or model, but got ${content.role}.`);
    }
  }
}
function extractCuratedHistory(comprehensiveHistory) {
  if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) {
    return [];
  }
  const curatedHistory = [];
  const length = comprehensiveHistory.length;
  let i = 0;
  while (i < length) {
    if (comprehensiveHistory[i].role === "user") {
      curatedHistory.push(comprehensiveHistory[i]);
      i++;
    } else {
      const modelOutput = [];
      let isValid = true;
      while (i < length && comprehensiveHistory[i].role === "model") {
        modelOutput.push(comprehensiveHistory[i]);
        if (isValid && !isValidContent(comprehensiveHistory[i])) {
          isValid = false;
        }
        i++;
      }
      if (isValid) {
        curatedHistory.push(...modelOutput);
      } else {
        curatedHistory.pop();
      }
    }
  }
  return curatedHistory;
}
function createFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromFile = getValueByPath(fromObject, ["file"]);
  if (fromFile != null) {
    setValueByPath(toObject, ["file"], fromFile);
  }
  return toObject;
}
function createFileResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function deleteFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
  }
  return toObject;
}
function deleteFileResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function getFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
  }
  return toObject;
}
function internalRegisterFilesParametersToMldev(fromObject) {
  const toObject = {};
  const fromUris = getValueByPath(fromObject, ["uris"]);
  if (fromUris != null) {
    setValueByPath(toObject, ["uris"], fromUris);
  }
  return toObject;
}
function listFilesConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listFilesParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listFilesConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listFilesResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromFiles = getValueByPath(fromObject, ["files"]);
  if (fromFiles != null) {
    let transformedList = fromFiles;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["files"], transformedList);
  }
  return toObject;
}
function registerFilesResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromFiles = getValueByPath(fromObject, ["files"]);
  if (fromFiles != null) {
    let transformedList = fromFiles;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["files"], transformedList);
  }
  return toObject;
}
function blobToMldev$2(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function contentToMldev$2(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function fileDataToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev$2(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionDeclarationToVertex$1(fromObject) {
  const toObject = {};
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function generationConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromModelSelectionConfig = getValueByPath(fromObject, [
    "modelSelectionConfig"
  ]);
  if (fromModelSelectionConfig != null) {
    setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  const fromAudioTimestamp = getValueByPath(fromObject, [
    "audioTimestamp"
  ]);
  if (fromAudioTimestamp != null) {
    setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (fromEnableAffectiveDialog != null) {
    setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
  }
  const fromRoutingConfig = getValueByPath(fromObject, [
    "routingConfig"
  ]);
  if (fromRoutingConfig != null) {
    setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], fromSpeechConfig);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
    throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function googleMapsToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function liveConnectConfigToMldev$1(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== void 0 && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== void 0 && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== void 0 && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== void 0 && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== void 0 && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== void 0 && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== void 0 && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (parentObject !== void 0 && fromThinkingConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$2(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== void 0 && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== void 0 && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== void 0 && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
  }
  if (getValueByPath(fromObject, ["explicitVadSignal"]) !== void 0) {
    throw new Error("explicitVadSignal parameter is not supported in Gemini API.");
  }
  return toObject;
}
function liveConnectConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], generationConfigToVertex$1(fromGenerationConfig));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== void 0 && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== void 0 && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== void 0 && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== void 0 && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== void 0 && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== void 0 && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== void 0 && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (parentObject !== void 0 && fromThinkingConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], tContent(fromSystemInstruction));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex$1(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== void 0 && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], fromSessionResumption);
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== void 0 && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== void 0 && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
  }
  const fromExplicitVadSignal = getValueByPath(fromObject, [
    "explicitVadSignal"
  ]);
  if (parentObject !== void 0 && fromExplicitVadSignal != null) {
    setValueByPath(parentObject, ["setup", "explicitVadSignal"], fromExplicitVadSignal);
  }
  return toObject;
}
function liveConnectParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
  }
  return toObject;
}
function liveConnectParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function liveMusicSetConfigParametersToMldev(fromObject) {
  const toObject = {};
  const fromMusicGenerationConfig = getValueByPath(fromObject, [
    "musicGenerationConfig"
  ]);
  if (fromMusicGenerationConfig != null) {
    setValueByPath(toObject, ["musicGenerationConfig"], fromMusicGenerationConfig);
  }
  return toObject;
}
function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
  const toObject = {};
  const fromWeightedPrompts = getValueByPath(fromObject, [
    "weightedPrompts"
  ]);
  if (fromWeightedPrompts != null) {
    let transformedList = fromWeightedPrompts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["weightedPrompts"], transformedList);
  }
  return toObject;
}
function liveSendRealtimeInputParametersToMldev(fromObject) {
  const toObject = {};
  const fromMedia = getValueByPath(fromObject, ["media"]);
  if (fromMedia != null) {
    let transformedList = tBlobs(fromMedia);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return blobToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["mediaChunks"], transformedList);
  }
  const fromAudio = getValueByPath(fromObject, ["audio"]);
  if (fromAudio != null) {
    setValueByPath(toObject, ["audio"], blobToMldev$2(tAudioBlob(fromAudio)));
  }
  const fromAudioStreamEnd = getValueByPath(fromObject, [
    "audioStreamEnd"
  ]);
  if (fromAudioStreamEnd != null) {
    setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], blobToMldev$2(tImageBlob(fromVideo)));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromActivityStart = getValueByPath(fromObject, [
    "activityStart"
  ]);
  if (fromActivityStart != null) {
    setValueByPath(toObject, ["activityStart"], fromActivityStart);
  }
  const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
  if (fromActivityEnd != null) {
    setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
  }
  return toObject;
}
function liveSendRealtimeInputParametersToVertex(fromObject) {
  const toObject = {};
  const fromMedia = getValueByPath(fromObject, ["media"]);
  if (fromMedia != null) {
    let transformedList = tBlobs(fromMedia);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["mediaChunks"], transformedList);
  }
  const fromAudio = getValueByPath(fromObject, ["audio"]);
  if (fromAudio != null) {
    setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
  }
  const fromAudioStreamEnd = getValueByPath(fromObject, [
    "audioStreamEnd"
  ]);
  if (fromAudioStreamEnd != null) {
    setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromActivityStart = getValueByPath(fromObject, [
    "activityStart"
  ]);
  if (fromActivityStart != null) {
    setValueByPath(toObject, ["activityStart"], fromActivityStart);
  }
  const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
  if (fromActivityEnd != null) {
    setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
  }
  return toObject;
}
function liveServerMessageFromVertex(fromObject) {
  const toObject = {};
  const fromSetupComplete = getValueByPath(fromObject, [
    "setupComplete"
  ]);
  if (fromSetupComplete != null) {
    setValueByPath(toObject, ["setupComplete"], fromSetupComplete);
  }
  const fromServerContent = getValueByPath(fromObject, [
    "serverContent"
  ]);
  if (fromServerContent != null) {
    setValueByPath(toObject, ["serverContent"], fromServerContent);
  }
  const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
  if (fromToolCall != null) {
    setValueByPath(toObject, ["toolCall"], fromToolCall);
  }
  const fromToolCallCancellation = getValueByPath(fromObject, [
    "toolCallCancellation"
  ]);
  if (fromToolCallCancellation != null) {
    setValueByPath(toObject, ["toolCallCancellation"], fromToolCallCancellation);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
  }
  const fromGoAway = getValueByPath(fromObject, ["goAway"]);
  if (fromGoAway != null) {
    setValueByPath(toObject, ["goAway"], fromGoAway);
  }
  const fromSessionResumptionUpdate = getValueByPath(fromObject, [
    "sessionResumptionUpdate"
  ]);
  if (fromSessionResumptionUpdate != null) {
    setValueByPath(toObject, ["sessionResumptionUpdate"], fromSessionResumptionUpdate);
  }
  const fromVoiceActivityDetectionSignal = getValueByPath(fromObject, [
    "voiceActivityDetectionSignal"
  ]);
  if (fromVoiceActivityDetectionSignal != null) {
    setValueByPath(toObject, ["voiceActivityDetectionSignal"], fromVoiceActivityDetectionSignal);
  }
  const fromVoiceActivity = getValueByPath(fromObject, [
    "voiceActivity"
  ]);
  if (fromVoiceActivity != null) {
    setValueByPath(toObject, ["voiceActivity"], voiceActivityFromVertex(fromVoiceActivity));
  }
  return toObject;
}
function partToMldev$2(fromObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev$2(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function sessionResumptionConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
    throw new Error("transparent parameter is not supported in Gemini API.");
  }
  return toObject;
}
function toolToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$2(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function toolToVertex$1(fromObject) {
  const toObject = {};
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
    throw new Error("fileSearch parameter is not supported in Vertex AI.");
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex$1(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function usageMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromPromptTokenCount = getValueByPath(fromObject, [
    "promptTokenCount"
  ]);
  if (fromPromptTokenCount != null) {
    setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  const fromResponseTokenCount = getValueByPath(fromObject, [
    "candidatesTokenCount"
  ]);
  if (fromResponseTokenCount != null) {
    setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
  }
  const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
    "toolUsePromptTokenCount"
  ]);
  if (fromToolUsePromptTokenCount != null) {
    setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
  }
  const fromThoughtsTokenCount = getValueByPath(fromObject, [
    "thoughtsTokenCount"
  ]);
  if (fromThoughtsTokenCount != null) {
    setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
  }
  const fromTotalTokenCount = getValueByPath(fromObject, [
    "totalTokenCount"
  ]);
  if (fromTotalTokenCount != null) {
    setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
  }
  const fromPromptTokensDetails = getValueByPath(fromObject, [
    "promptTokensDetails"
  ]);
  if (fromPromptTokensDetails != null) {
    let transformedList = fromPromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["promptTokensDetails"], transformedList);
  }
  const fromCacheTokensDetails = getValueByPath(fromObject, [
    "cacheTokensDetails"
  ]);
  if (fromCacheTokensDetails != null) {
    let transformedList = fromCacheTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
  }
  const fromResponseTokensDetails = getValueByPath(fromObject, [
    "candidatesTokensDetails"
  ]);
  if (fromResponseTokensDetails != null) {
    let transformedList = fromResponseTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["responseTokensDetails"], transformedList);
  }
  const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
    "toolUsePromptTokensDetails"
  ]);
  if (fromToolUsePromptTokensDetails != null) {
    let transformedList = fromToolUsePromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
  }
  const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
  if (fromTrafficType != null) {
    setValueByPath(toObject, ["trafficType"], fromTrafficType);
  }
  return toObject;
}
function voiceActivityFromVertex(fromObject) {
  const toObject = {};
  const fromVoiceActivityType = getValueByPath(fromObject, ["type"]);
  if (fromVoiceActivityType != null) {
    setValueByPath(toObject, ["voiceActivityType"], fromVoiceActivityType);
  }
  return toObject;
}
function blobToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function candidateFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], fromContent);
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    let transformedList = fromSafetyRatings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["safetyRatings"], transformedList);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
  }
  return toObject;
}
function citationMetadataFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citationSources"]);
  if (fromCitations != null) {
    let transformedList = fromCitations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["citations"], transformedList);
  }
  return toObject;
}
function computeTokensParametersToVertex(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  return toObject;
}
function computeTokensResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
  if (fromTokensInfo != null) {
    let transformedList = fromTokensInfo;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["tokensInfo"], transformedList);
  }
  return toObject;
}
function contentEmbeddingFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromValues = getValueByPath(fromObject, ["values"]);
  if (fromValues != null) {
    setValueByPath(toObject, ["values"], fromValues);
  }
  const fromStatistics = getValueByPath(fromObject, ["statistics"]);
  if (fromStatistics != null) {
    setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
  }
  return toObject;
}
function contentEmbeddingStatisticsFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromTruncated = getValueByPath(fromObject, ["truncated"]);
  if (fromTruncated != null) {
    setValueByPath(toObject, ["truncated"], fromTruncated);
  }
  const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  return toObject;
}
function contentToMldev$1(fromObject, rootObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function controlReferenceConfigToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromControlType = getValueByPath(fromObject, ["controlType"]);
  if (fromControlType != null) {
    setValueByPath(toObject, ["controlType"], fromControlType);
  }
  const fromEnableControlImageComputation = getValueByPath(fromObject, [
    "enableControlImageComputation"
  ]);
  if (fromEnableControlImageComputation != null) {
    setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
  }
  return toObject;
}
function countTokensConfigToMldev(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) {
    throw new Error("systemInstruction parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["tools"]) !== void 0) {
    throw new Error("tools parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) {
    throw new Error("generationConfig parameter is not supported in Gemini API.");
  }
  return toObject;
}
function countTokensConfigToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["generationConfig"], generationConfigToVertex(fromGenerationConfig));
  }
  return toObject;
}
function countTokensParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    countTokensConfigToMldev(fromConfig);
  }
  return toObject;
}
function countTokensParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    countTokensConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function countTokensResponseFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
  if (fromTotalTokens != null) {
    setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  return toObject;
}
function countTokensResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
  if (fromTotalTokens != null) {
    setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
  }
  return toObject;
}
function deleteModelParametersToMldev(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  return toObject;
}
function deleteModelParametersToVertex(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  return toObject;
}
function deleteModelResponseFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function deleteModelResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function editImageConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== void 0 && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== void 0 && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== void 0 && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromEditMode = getValueByPath(fromObject, ["editMode"]);
  if (parentObject !== void 0 && fromEditMode != null) {
    setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
  }
  const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
  if (parentObject !== void 0 && fromBaseSteps != null) {
    setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
  }
  return toObject;
}
function editImageParametersInternalToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromReferenceImages = getValueByPath(fromObject, [
    "referenceImages"
  ]);
  if (fromReferenceImages != null) {
    let transformedList = fromReferenceImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return referenceImageAPIInternalToVertex(item);
      });
    }
    setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    editImageConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function editImageResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function embedContentConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== void 0 && fromTaskType != null) {
    setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== void 0 && fromTitle != null) {
    setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== void 0 && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
  }
  if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
    throw new Error("mimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
    throw new Error("autoTruncate parameter is not supported in Gemini API.");
  }
  return toObject;
}
function embedContentConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== void 0 && fromTaskType != null) {
    setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== void 0 && fromTitle != null) {
    setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== void 0 && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (parentObject !== void 0 && fromMimeType != null) {
    setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
  }
  const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
  if (parentObject !== void 0 && fromAutoTruncate != null) {
    setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
  }
  return toObject;
}
function embedContentParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContentsForEmbed(apiClient, fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["requests[]", "content"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    embedContentConfigToMldev(fromConfig, toObject);
  }
  const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
  if (fromModelForEmbedContent !== void 0) {
    setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
  }
  return toObject;
}
function embedContentParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContentsForEmbed(apiClient, fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["instances[]", "content"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    embedContentConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function embedContentResponseFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
  if (fromEmbeddings != null) {
    let transformedList = fromEmbeddings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["embeddings"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  return toObject;
}
function embedContentResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromEmbeddings = getValueByPath(fromObject, [
    "predictions[]",
    "embeddings"
  ]);
  if (fromEmbeddings != null) {
    let transformedList = fromEmbeddings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentEmbeddingFromVertex(item);
      });
    }
    setValueByPath(toObject, ["embeddings"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  return toObject;
}
function endpointFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["endpoint"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDeployedModelId = getValueByPath(fromObject, [
    "deployedModelId"
  ]);
  if (fromDeployedModelId != null) {
    setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
  }
  return toObject;
}
function fileDataToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionCallingConfigToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
    throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionDeclarationToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function generateContentConfigToMldev(apiClient, fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== void 0 && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToMldev(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$1(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== void 0 && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
  }
  if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
  if (fromImageConfig != null) {
    setValueByPath(toObject, ["imageConfig"], imageConfigToMldev(fromImageConfig));
  }
  const fromEnableEnhancedCivicAnswers = getValueByPath(fromObject, [
    "enableEnhancedCivicAnswers"
  ]);
  if (fromEnableEnhancedCivicAnswers != null) {
    setValueByPath(toObject, ["enableEnhancedCivicAnswers"], fromEnableEnhancedCivicAnswers);
  }
  if (getValueByPath(fromObject, ["modelArmorConfig"]) !== void 0) {
    throw new Error("modelArmorConfig parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateContentConfigToVertex(apiClient, fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  const fromRoutingConfig = getValueByPath(fromObject, [
    "routingConfig"
  ]);
  if (fromRoutingConfig != null) {
    setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
  }
  const fromModelSelectionConfig = getValueByPath(fromObject, [
    "modelSelectionConfig"
  ]);
  if (fromModelSelectionConfig != null) {
    setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== void 0 && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== void 0 && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
  }
  const fromAudioTimestamp = getValueByPath(fromObject, [
    "audioTimestamp"
  ]);
  if (fromAudioTimestamp != null) {
    setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
  if (fromImageConfig != null) {
    setValueByPath(toObject, ["imageConfig"], imageConfigToVertex(fromImageConfig));
  }
  if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
    throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
  }
  const fromModelArmorConfig = getValueByPath(fromObject, [
    "modelArmorConfig"
  ]);
  if (parentObject !== void 0 && fromModelArmorConfig != null) {
    setValueByPath(parentObject, ["modelArmorConfig"], fromModelArmorConfig);
  }
  return toObject;
}
function generateContentParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function generateContentParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function generateContentResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromMldev(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function generateContentResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function generateImagesConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) {
    throw new Error("negativePrompt parameter is not supported in Gemini API.");
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== void 0 && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  if (getValueByPath(fromObject, ["seed"]) !== void 0) {
    throw new Error("seed parameter is not supported in Gemini API.");
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== void 0 && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) {
    throw new Error("addWatermark parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (parentObject !== void 0 && fromImageSize != null) {
    setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
  }
  if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
    throw new Error("enhancePrompt parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateImagesConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== void 0 && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== void 0 && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== void 0 && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (parentObject !== void 0 && fromImageSize != null) {
    setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  return toObject;
}
function generateImagesParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    generateImagesConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function generateImagesParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    generateImagesConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function generateImagesResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromMldev(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
    "positivePromptSafetyAttributes"
  ]);
  if (fromPositivePromptSafetyAttributes != null) {
    setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
  }
  return toObject;
}
function generateImagesResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
    "positivePromptSafetyAttributes"
  ]);
  if (fromPositivePromptSafetyAttributes != null) {
    setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
  }
  return toObject;
}
function generateVideosConfigToMldev(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromNumberOfVideos = getValueByPath(fromObject, [
    "numberOfVideos"
  ]);
  if (parentObject !== void 0 && fromNumberOfVideos != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
  }
  if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["fps"]) !== void 0) {
    throw new Error("fps parameter is not supported in Gemini API.");
  }
  const fromDurationSeconds = getValueByPath(fromObject, [
    "durationSeconds"
  ]);
  if (parentObject !== void 0 && fromDurationSeconds != null) {
    setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
  }
  if (getValueByPath(fromObject, ["seed"]) !== void 0) {
    throw new Error("seed parameter is not supported in Gemini API.");
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromResolution = getValueByPath(fromObject, ["resolution"]);
  if (parentObject !== void 0 && fromResolution != null) {
    setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) {
    throw new Error("pubsubTopic parameter is not supported in Gemini API.");
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) {
    throw new Error("generateAudio parameter is not supported in Gemini API.");
  }
  const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
  if (parentObject !== void 0 && fromLastFrame != null) {
    setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToMldev(fromLastFrame));
  }
  const fromReferenceImages = getValueByPath(fromObject, [
    "referenceImages"
  ]);
  if (parentObject !== void 0 && fromReferenceImages != null) {
    let transformedList = fromReferenceImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return videoGenerationReferenceImageToMldev(item);
      });
    }
    setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
  }
  if (getValueByPath(fromObject, ["mask"]) !== void 0) {
    throw new Error("mask parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["compressionQuality"]) !== void 0) {
    throw new Error("compressionQuality parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateVideosConfigToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromNumberOfVideos = getValueByPath(fromObject, [
    "numberOfVideos"
  ]);
  if (parentObject !== void 0 && fromNumberOfVideos != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
  }
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (parentObject !== void 0 && fromFps != null) {
    setValueByPath(parentObject, ["parameters", "fps"], fromFps);
  }
  const fromDurationSeconds = getValueByPath(fromObject, [
    "durationSeconds"
  ]);
  if (parentObject !== void 0 && fromDurationSeconds != null) {
    setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromResolution = getValueByPath(fromObject, ["resolution"]);
  if (parentObject !== void 0 && fromResolution != null) {
    setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
  if (parentObject !== void 0 && fromPubsubTopic != null) {
    setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  const fromGenerateAudio = getValueByPath(fromObject, [
    "generateAudio"
  ]);
  if (parentObject !== void 0 && fromGenerateAudio != null) {
    setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
  }
  const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
  if (parentObject !== void 0 && fromLastFrame != null) {
    setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
  }
  const fromReferenceImages = getValueByPath(fromObject, [
    "referenceImages"
  ]);
  if (parentObject !== void 0 && fromReferenceImages != null) {
    let transformedList = fromReferenceImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return videoGenerationReferenceImageToVertex(item);
      });
    }
    setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
  }
  const fromMask = getValueByPath(fromObject, ["mask"]);
  if (parentObject !== void 0 && fromMask != null) {
    setValueByPath(parentObject, ["instances[0]", "mask"], videoGenerationMaskToVertex(fromMask));
  }
  const fromCompressionQuality = getValueByPath(fromObject, [
    "compressionQuality"
  ]);
  if (parentObject !== void 0 && fromCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
  }
  return toObject;
}
function generateVideosOperationFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, [
    "response",
    "generateVideoResponse"
  ]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
  }
  return toObject;
}
function generateVideosOperationFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
  }
  return toObject;
}
function generateVideosParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["instances[0]", "video"], videoToMldev(fromVideo));
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    generateVideosSourceToMldev(fromSource, toObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    generateVideosConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function generateVideosParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    generateVideosSourceToVertex(fromSource, toObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    generateVideosConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function generateVideosResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, [
    "generatedSamples"
  ]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromMldev(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosSourceToMldev(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (parentObject !== void 0 && fromPrompt != null) {
    setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (parentObject !== void 0 && fromImage != null) {
    setValueByPath(parentObject, ["instances[0]", "image"], imageToMldev(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (parentObject !== void 0 && fromVideo != null) {
    setValueByPath(parentObject, ["instances[0]", "video"], videoToMldev(fromVideo));
  }
  return toObject;
}
function generateVideosSourceToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (parentObject !== void 0 && fromPrompt != null) {
    setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (parentObject !== void 0 && fromImage != null) {
    setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (parentObject !== void 0 && fromVideo != null) {
    setValueByPath(parentObject, ["instances[0]", "video"], videoToVertex(fromVideo));
  }
  return toObject;
}
function generatedImageFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["_self"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
  }
  const fromRaiFilteredReason = getValueByPath(fromObject, [
    "raiFilteredReason"
  ]);
  if (fromRaiFilteredReason != null) {
    setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
  }
  const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
  if (fromSafetyAttributes != null) {
    setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
  }
  return toObject;
}
function generatedImageFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["_self"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
  }
  const fromRaiFilteredReason = getValueByPath(fromObject, [
    "raiFilteredReason"
  ]);
  if (fromRaiFilteredReason != null) {
    setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
  }
  const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
  if (fromSafetyAttributes != null) {
    setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
  }
  const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromEnhancedPrompt != null) {
    setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
  }
  return toObject;
}
function generatedImageMaskFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromMask = getValueByPath(fromObject, ["_self"]);
  if (fromMask != null) {
    setValueByPath(toObject, ["mask"], imageFromVertex(fromMask));
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    let transformedList = fromLabels;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["labels"], transformedList);
  }
  return toObject;
}
function generatedVideoFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
  }
  return toObject;
}
function generatedVideoFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["_self"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
  }
  return toObject;
}
function generationConfigToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromModelSelectionConfig = getValueByPath(fromObject, [
    "modelSelectionConfig"
  ]);
  if (fromModelSelectionConfig != null) {
    setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  const fromAudioTimestamp = getValueByPath(fromObject, [
    "audioTimestamp"
  ]);
  if (fromAudioTimestamp != null) {
    setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (fromEnableAffectiveDialog != null) {
    setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
  }
  const fromRoutingConfig = getValueByPath(fromObject, [
    "routingConfig"
  ]);
  if (fromRoutingConfig != null) {
    setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], fromSpeechConfig);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
    throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function getModelParametersToMldev(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  return toObject;
}
function getModelParametersToVertex(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  return toObject;
}
function googleMapsToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function imageConfigToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (fromAspectRatio != null) {
    setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (fromImageSize != null) {
    setValueByPath(toObject, ["imageSize"], fromImageSize);
  }
  if (getValueByPath(fromObject, ["personGeneration"]) !== void 0) {
    throw new Error("personGeneration parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
    throw new Error("outputMimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
    throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
  }
  return toObject;
}
function imageConfigToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (fromAspectRatio != null) {
    setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (fromImageSize != null) {
    setValueByPath(toObject, ["imageSize"], fromImageSize);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (fromPersonGeneration != null) {
    setValueByPath(toObject, ["personGeneration"], fromPersonGeneration);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (fromOutputMimeType != null) {
    setValueByPath(toObject, ["imageOutputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (fromOutputCompressionQuality != null) {
    setValueByPath(toObject, ["imageOutputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  return toObject;
}
function imageFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromImageBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function imageFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromImageBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function imageToMldev(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function imageToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function listModelsConfigToMldev(apiClient, fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
  if (parentObject !== void 0 && fromQueryBase != null) {
    setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
  }
  return toObject;
}
function listModelsConfigToVertex(apiClient, fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
  if (parentObject !== void 0 && fromQueryBase != null) {
    setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
  }
  return toObject;
}
function listModelsParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listModelsConfigToMldev(apiClient, fromConfig, toObject);
  }
  return toObject;
}
function listModelsParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listModelsConfigToVertex(apiClient, fromConfig, toObject);
  }
  return toObject;
}
function listModelsResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromModels = getValueByPath(fromObject, ["_self"]);
  if (fromModels != null) {
    let transformedList = tExtractModels(fromModels);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modelFromMldev(item);
      });
    }
    setValueByPath(toObject, ["models"], transformedList);
  }
  return toObject;
}
function listModelsResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromModels = getValueByPath(fromObject, ["_self"]);
  if (fromModels != null) {
    let transformedList = tExtractModels(fromModels);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modelFromVertex(item);
      });
    }
    setValueByPath(toObject, ["models"], transformedList);
  }
  return toObject;
}
function maskReferenceConfigToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
  if (fromMaskMode != null) {
    setValueByPath(toObject, ["maskMode"], fromMaskMode);
  }
  const fromSegmentationClasses = getValueByPath(fromObject, [
    "segmentationClasses"
  ]);
  if (fromSegmentationClasses != null) {
    setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
  }
  const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
  if (fromMaskDilation != null) {
    setValueByPath(toObject, ["dilation"], fromMaskDilation);
  }
  return toObject;
}
function modelFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromVersion = getValueByPath(fromObject, ["version"]);
  if (fromVersion != null) {
    setValueByPath(toObject, ["version"], fromVersion);
  }
  const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModelInfo != null) {
    setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
  }
  const fromInputTokenLimit = getValueByPath(fromObject, [
    "inputTokenLimit"
  ]);
  if (fromInputTokenLimit != null) {
    setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
  }
  const fromOutputTokenLimit = getValueByPath(fromObject, [
    "outputTokenLimit"
  ]);
  if (fromOutputTokenLimit != null) {
    setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
  }
  const fromSupportedActions = getValueByPath(fromObject, [
    "supportedGenerationMethods"
  ]);
  if (fromSupportedActions != null) {
    setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromMaxTemperature = getValueByPath(fromObject, [
    "maxTemperature"
  ]);
  if (fromMaxTemperature != null) {
    setValueByPath(toObject, ["maxTemperature"], fromMaxTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromThinking = getValueByPath(fromObject, ["thinking"]);
  if (fromThinking != null) {
    setValueByPath(toObject, ["thinking"], fromThinking);
  }
  return toObject;
}
function modelFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromVersion = getValueByPath(fromObject, ["versionId"]);
  if (fromVersion != null) {
    setValueByPath(toObject, ["version"], fromVersion);
  }
  const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
  if (fromEndpoints != null) {
    let transformedList = fromEndpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return endpointFromVertex(item);
      });
    }
    setValueByPath(toObject, ["endpoints"], transformedList);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModelInfo != null) {
    setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (fromDefaultCheckpointId != null) {
    setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
  if (fromCheckpoints != null) {
    let transformedList = fromCheckpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["checkpoints"], transformedList);
  }
  return toObject;
}
function partToMldev$1(fromObject, rootObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev$1(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function productImageToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromProductImage = getValueByPath(fromObject, ["productImage"]);
  if (fromProductImage != null) {
    setValueByPath(toObject, ["image"], imageToVertex(fromProductImage));
  }
  return toObject;
}
function recontextImageConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
  if (parentObject !== void 0 && fromBaseSteps != null) {
    setValueByPath(parentObject, ["parameters", "baseSteps"], fromBaseSteps);
  }
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== void 0 && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  return toObject;
}
function recontextImageParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    recontextImageSourceToVertex(fromSource, toObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    recontextImageConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function recontextImageResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function recontextImageSourceToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (parentObject !== void 0 && fromPrompt != null) {
    setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromPersonImage = getValueByPath(fromObject, ["personImage"]);
  if (parentObject !== void 0 && fromPersonImage != null) {
    setValueByPath(parentObject, ["instances[0]", "personImage", "image"], imageToVertex(fromPersonImage));
  }
  const fromProductImages = getValueByPath(fromObject, [
    "productImages"
  ]);
  if (parentObject !== void 0 && fromProductImages != null) {
    let transformedList = fromProductImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return productImageToVertex(item);
      });
    }
    setValueByPath(parentObject, ["instances[0]", "productImages"], transformedList);
  }
  return toObject;
}
function referenceImageAPIInternalToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromReferenceImage = getValueByPath(fromObject, [
    "referenceImage"
  ]);
  if (fromReferenceImage != null) {
    setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
  }
  const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
  if (fromReferenceId != null) {
    setValueByPath(toObject, ["referenceId"], fromReferenceId);
  }
  const fromReferenceType = getValueByPath(fromObject, [
    "referenceType"
  ]);
  if (fromReferenceType != null) {
    setValueByPath(toObject, ["referenceType"], fromReferenceType);
  }
  const fromMaskImageConfig = getValueByPath(fromObject, [
    "maskImageConfig"
  ]);
  if (fromMaskImageConfig != null) {
    setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
  }
  const fromControlImageConfig = getValueByPath(fromObject, [
    "controlImageConfig"
  ]);
  if (fromControlImageConfig != null) {
    setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
  }
  const fromStyleImageConfig = getValueByPath(fromObject, [
    "styleImageConfig"
  ]);
  if (fromStyleImageConfig != null) {
    setValueByPath(toObject, ["styleImageConfig"], fromStyleImageConfig);
  }
  const fromSubjectImageConfig = getValueByPath(fromObject, [
    "subjectImageConfig"
  ]);
  if (fromSubjectImageConfig != null) {
    setValueByPath(toObject, ["subjectImageConfig"], fromSubjectImageConfig);
  }
  return toObject;
}
function safetyAttributesFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromCategories = getValueByPath(fromObject, [
    "safetyAttributes",
    "categories"
  ]);
  if (fromCategories != null) {
    setValueByPath(toObject, ["categories"], fromCategories);
  }
  const fromScores = getValueByPath(fromObject, [
    "safetyAttributes",
    "scores"
  ]);
  if (fromScores != null) {
    setValueByPath(toObject, ["scores"], fromScores);
  }
  const fromContentType = getValueByPath(fromObject, ["contentType"]);
  if (fromContentType != null) {
    setValueByPath(toObject, ["contentType"], fromContentType);
  }
  return toObject;
}
function safetyAttributesFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromCategories = getValueByPath(fromObject, [
    "safetyAttributes",
    "categories"
  ]);
  if (fromCategories != null) {
    setValueByPath(toObject, ["categories"], fromCategories);
  }
  const fromScores = getValueByPath(fromObject, [
    "safetyAttributes",
    "scores"
  ]);
  if (fromScores != null) {
    setValueByPath(toObject, ["scores"], fromScores);
  }
  const fromContentType = getValueByPath(fromObject, ["contentType"]);
  if (fromContentType != null) {
    setValueByPath(toObject, ["contentType"], fromContentType);
  }
  return toObject;
}
function safetySettingToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  if (getValueByPath(fromObject, ["method"]) !== void 0) {
    throw new Error("method parameter is not supported in Gemini API.");
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function scribbleImageToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageToVertex(fromImage));
  }
  return toObject;
}
function segmentImageConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (parentObject !== void 0 && fromMode != null) {
    setValueByPath(parentObject, ["parameters", "mode"], fromMode);
  }
  const fromMaxPredictions = getValueByPath(fromObject, [
    "maxPredictions"
  ]);
  if (parentObject !== void 0 && fromMaxPredictions != null) {
    setValueByPath(parentObject, ["parameters", "maxPredictions"], fromMaxPredictions);
  }
  const fromConfidenceThreshold = getValueByPath(fromObject, [
    "confidenceThreshold"
  ]);
  if (parentObject !== void 0 && fromConfidenceThreshold != null) {
    setValueByPath(parentObject, ["parameters", "confidenceThreshold"], fromConfidenceThreshold);
  }
  const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
  if (parentObject !== void 0 && fromMaskDilation != null) {
    setValueByPath(parentObject, ["parameters", "maskDilation"], fromMaskDilation);
  }
  const fromBinaryColorThreshold = getValueByPath(fromObject, [
    "binaryColorThreshold"
  ]);
  if (parentObject !== void 0 && fromBinaryColorThreshold != null) {
    setValueByPath(parentObject, ["parameters", "binaryColorThreshold"], fromBinaryColorThreshold);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  return toObject;
}
function segmentImageParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    segmentImageSourceToVertex(fromSource, toObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    segmentImageConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function segmentImageResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromGeneratedMasks = getValueByPath(fromObject, ["predictions"]);
  if (fromGeneratedMasks != null) {
    let transformedList = fromGeneratedMasks;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageMaskFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedMasks"], transformedList);
  }
  return toObject;
}
function segmentImageSourceToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (parentObject !== void 0 && fromPrompt != null) {
    setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (parentObject !== void 0 && fromImage != null) {
    setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromScribbleImage = getValueByPath(fromObject, [
    "scribbleImage"
  ]);
  if (parentObject !== void 0 && fromScribbleImage != null) {
    setValueByPath(parentObject, ["instances[0]", "scribble"], scribbleImageToVertex(fromScribbleImage));
  }
  return toObject;
}
function toolConfigToMldev(fromObject, rootObject) {
  const toObject = {};
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
  }
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
  }
  return toObject;
}
function toolToMldev$1(fromObject, rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$1(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function toolToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
    throw new Error("fileSearch parameter is not supported in Vertex AI.");
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function tunedModelInfoFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  return toObject;
}
function tunedModelInfoFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, [
    "labels",
    "google-vertex-llm-tuning-base-model-id"
  ]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  return toObject;
}
function updateModelConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== void 0 && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
    setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  return toObject;
}
function updateModelConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== void 0 && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
    setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  return toObject;
}
function updateModelParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    updateModelConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function updateModelParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    updateModelConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromEnhanceInputImage = getValueByPath(fromObject, [
    "enhanceInputImage"
  ]);
  if (parentObject !== void 0 && fromEnhanceInputImage != null) {
    setValueByPath(parentObject, ["parameters", "upscaleConfig", "enhanceInputImage"], fromEnhanceInputImage);
  }
  const fromImagePreservationFactor = getValueByPath(fromObject, [
    "imagePreservationFactor"
  ]);
  if (parentObject !== void 0 && fromImagePreservationFactor != null) {
    setValueByPath(parentObject, ["parameters", "upscaleConfig", "imagePreservationFactor"], fromImagePreservationFactor);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (parentObject !== void 0 && fromMode != null) {
    setValueByPath(parentObject, ["parameters", "mode"], fromMode);
  }
  return toObject;
}
function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromUpscaleFactor = getValueByPath(fromObject, [
    "upscaleFactor"
  ]);
  if (fromUpscaleFactor != null) {
    setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);
  }
  return toObject;
}
function upscaleImageResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function videoFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["encoding"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function videoFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function videoGenerationMaskToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["_self"], imageToVertex(fromImage));
  }
  const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
  if (fromMaskMode != null) {
    setValueByPath(toObject, ["maskMode"], fromMaskMode);
  }
  return toObject;
}
function videoGenerationReferenceImageToMldev(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageToMldev(fromImage));
  }
  const fromReferenceType = getValueByPath(fromObject, [
    "referenceType"
  ]);
  if (fromReferenceType != null) {
    setValueByPath(toObject, ["referenceType"], fromReferenceType);
  }
  return toObject;
}
function videoGenerationReferenceImageToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageToVertex(fromImage));
  }
  const fromReferenceType = getValueByPath(fromObject, [
    "referenceType"
  ]);
  if (fromReferenceType != null) {
    setValueByPath(toObject, ["referenceType"], fromReferenceType);
  }
  return toObject;
}
function videoToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["encodedVideo"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["encoding"], fromMimeType);
  }
  return toObject;
}
function videoToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function createFileSearchStoreConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  return toObject;
}
function createFileSearchStoreParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createFileSearchStoreConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromForce = getValueByPath(fromObject, ["force"]);
  if (parentObject !== void 0 && fromForce != null) {
    setValueByPath(parentObject, ["_query", "force"], fromForce);
  }
  return toObject;
}
function deleteFileSearchStoreParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    deleteFileSearchStoreConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function getFileSearchStoreParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function importFileConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromCustomMetadata = getValueByPath(fromObject, [
    "customMetadata"
  ]);
  if (parentObject !== void 0 && fromCustomMetadata != null) {
    let transformedList = fromCustomMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(parentObject, ["customMetadata"], transformedList);
  }
  const fromChunkingConfig = getValueByPath(fromObject, [
    "chunkingConfig"
  ]);
  if (parentObject !== void 0 && fromChunkingConfig != null) {
    setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
  }
  return toObject;
}
function importFileOperationFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], importFileResponseFromMldev(fromResponse));
  }
  return toObject;
}
function importFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromFileSearchStoreName = getValueByPath(fromObject, [
    "fileSearchStoreName"
  ]);
  if (fromFileSearchStoreName != null) {
    setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
  }
  const fromFileName = getValueByPath(fromObject, ["fileName"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    importFileConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function importFileResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromParent = getValueByPath(fromObject, ["parent"]);
  if (fromParent != null) {
    setValueByPath(toObject, ["parent"], fromParent);
  }
  const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
  if (fromDocumentName != null) {
    setValueByPath(toObject, ["documentName"], fromDocumentName);
  }
  return toObject;
}
function listFileSearchStoresConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listFileSearchStoresParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listFileSearchStoresConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listFileSearchStoresResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromFileSearchStores = getValueByPath(fromObject, [
    "fileSearchStores"
  ]);
  if (fromFileSearchStores != null) {
    let transformedList = fromFileSearchStores;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["fileSearchStores"], transformedList);
  }
  return toObject;
}
function uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (parentObject !== void 0 && fromMimeType != null) {
    setValueByPath(parentObject, ["mimeType"], fromMimeType);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromCustomMetadata = getValueByPath(fromObject, [
    "customMetadata"
  ]);
  if (parentObject !== void 0 && fromCustomMetadata != null) {
    let transformedList = fromCustomMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(parentObject, ["customMetadata"], transformedList);
  }
  const fromChunkingConfig = getValueByPath(fromObject, [
    "chunkingConfig"
  ]);
  if (parentObject !== void 0 && fromChunkingConfig != null) {
    setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
  }
  return toObject;
}
function uploadToFileSearchStoreParametersToMldev(fromObject) {
  const toObject = {};
  const fromFileSearchStoreName = getValueByPath(fromObject, [
    "fileSearchStoreName"
  ]);
  if (fromFileSearchStoreName != null) {
    setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
async function throwErrorIfNotOK(response) {
  var _a2;
  if (response === void 0) {
    throw new Error("response is undefined");
  }
  if (!response.ok) {
    const status = response.status;
    let errorBody;
    if ((_a2 = response.headers.get("content-type")) === null || _a2 === void 0 ? void 0 : _a2.includes("application/json")) {
      errorBody = await response.json();
    } else {
      errorBody = {
        error: {
          message: await response.text(),
          code: response.status,
          status: response.statusText
        }
      };
    }
    const errorMessage = JSON.stringify(errorBody);
    if (status >= 400 && status < 600) {
      const apiError = new ApiError({
        message: errorMessage,
        status
      });
      throw apiError;
    }
    throw new Error(errorMessage);
  }
}
function includeExtraBodyToRequestInit(requestInit, extraBody) {
  if (!extraBody || Object.keys(extraBody).length === 0) {
    return;
  }
  if (requestInit.body instanceof Blob) {
    console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
    return;
  }
  let currentBodyObject = {};
  if (typeof requestInit.body === "string" && requestInit.body.length > 0) {
    try {
      const parsedBody = JSON.parse(requestInit.body);
      if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) {
        currentBodyObject = parsedBody;
      } else {
        console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
        return;
      }
    } catch (e) {
      console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
      return;
    }
  }
  function deepMerge(target, source) {
    const output = Object.assign({}, target);
    for (const key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        const sourceValue = source[key];
        const targetValue = output[key];
        if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) {
          output[key] = deepMerge(targetValue, sourceValue);
        } else {
          if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {
            console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
          }
          output[key] = sourceValue;
        }
      }
    }
    return output;
  }
  const mergedBody = deepMerge(currentBodyObject, extraBody);
  requestInit.body = JSON.stringify(mergedBody);
}
function hasMcpToolUsage(tools) {
  for (const tool of tools) {
    if (isMcpCallableTool(tool)) {
      return true;
    }
    if (typeof tool === "object" && "inputSchema" in tool) {
      return true;
    }
  }
  return hasMcpToolUsageFromMcpToTool;
}
function setMcpUsageHeader(headers) {
  var _a2;
  const existingHeader = (_a2 = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a2 !== void 0 ? _a2 : "";
  headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
}
function isMcpCallableTool(object) {
  return object !== null && typeof object === "object" && object instanceof McpCallableTool;
}
function listAllTools(mcpClient_1) {
  return __asyncGenerator(this, arguments, function* listAllTools_1(mcpClient, maxTools = 100) {
    let cursor = void 0;
    let numTools = 0;
    while (numTools < maxTools) {
      const t = yield __await(mcpClient.listTools({ cursor }));
      for (const tool of t.tools) {
        yield yield __await(tool);
        numTools++;
      }
      if (!t.nextCursor) {
        break;
      }
      cursor = t.nextCursor;
    }
  });
}
function isMcpClient(client) {
  return client !== null && typeof client === "object" && "listTools" in client && typeof client.listTools === "function";
}
function mcpToTool(...args) {
  hasMcpToolUsageFromMcpToTool = true;
  if (args.length === 0) {
    throw new Error("No MCP clients provided");
  }
  const maybeConfig = args[args.length - 1];
  if (isMcpClient(maybeConfig)) {
    return McpCallableTool.create(args, {});
  }
  return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);
}
async function handleWebSocketMessage$1(apiClient, onmessage, event) {
  const serverMessage = new LiveMusicServerMessage();
  let data;
  if (event.data instanceof Blob) {
    data = JSON.parse(await event.data.text());
  } else {
    data = JSON.parse(event.data);
  }
  Object.assign(serverMessage, data);
  onmessage(serverMessage);
}
function headersToMap$1(headers) {
  const headerMap = {};
  headers.forEach((value, key) => {
    headerMap[key] = value;
  });
  return headerMap;
}
function mapToHeaders$1(map) {
  const headers = new Headers();
  for (const [key, value] of Object.entries(map)) {
    headers.append(key, value);
  }
  return headers;
}
async function handleWebSocketMessage(apiClient, onmessage, event) {
  const serverMessage = new LiveServerMessage();
  let jsonData;
  if (event.data instanceof Blob) {
    jsonData = await event.data.text();
  } else if (event.data instanceof ArrayBuffer) {
    jsonData = new TextDecoder().decode(event.data);
  } else {
    jsonData = event.data;
  }
  const data = JSON.parse(jsonData);
  if (apiClient.isVertexAI()) {
    const resp = liveServerMessageFromVertex(data);
    Object.assign(serverMessage, resp);
  } else {
    const resp = data;
    Object.assign(serverMessage, resp);
  }
  onmessage(serverMessage);
}
function headersToMap(headers) {
  const headerMap = {};
  headers.forEach((value, key) => {
    headerMap[key] = value;
  });
  return headerMap;
}
function mapToHeaders(map) {
  const headers = new Headers();
  for (const [key, value] of Object.entries(map)) {
    headers.append(key, value);
  }
  return headers;
}
function shouldDisableAfc(config) {
  var _a2, _b, _c;
  if ((_a2 = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a2 === void 0 ? void 0 : _a2.disable) {
    return true;
  }
  let callableToolsPresent = false;
  for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {
    if (isCallableTool(tool)) {
      callableToolsPresent = true;
      break;
    }
  }
  if (!callableToolsPresent) {
    return true;
  }
  const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
  if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
    console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
    return true;
  }
  return false;
}
function isCallableTool(tool) {
  return "callTool" in tool && typeof tool.callTool === "function";
}
function hasCallableTools(params) {
  var _a2, _b, _c;
  return (_c = (_b = (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
}
function findAfcIncompatibleToolIndexes(params) {
  var _a2;
  const afcIncompatibleToolIndexes = [];
  if (!((_a2 = params === null || params === void 0 ? void 0 : params.config) === null || _a2 === void 0 ? void 0 : _a2.tools)) {
    return afcIncompatibleToolIndexes;
  }
  params.config.tools.forEach((tool, index) => {
    if (isCallableTool(tool)) {
      return;
    }
    const geminiTool = tool;
    if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) {
      afcIncompatibleToolIndexes.push(index);
    }
  });
  return afcIncompatibleToolIndexes;
}
function shouldAppendAfcHistory(config) {
  var _a2;
  return !((_a2 = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a2 === void 0 ? void 0 : _a2.ignoreCallHistory);
}
function blobToMldev(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function contentToMldev(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromNewSessionExpireTime = getValueByPath(fromObject, [
    "newSessionExpireTime"
  ]);
  if (parentObject !== void 0 && fromNewSessionExpireTime != null) {
    setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
  }
  const fromUses = getValueByPath(fromObject, ["uses"]);
  if (parentObject !== void 0 && fromUses != null) {
    setValueByPath(parentObject, ["uses"], fromUses);
  }
  const fromLiveConnectConstraints = getValueByPath(fromObject, [
    "liveConnectConstraints"
  ]);
  if (parentObject !== void 0 && fromLiveConnectConstraints != null) {
    setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
  }
  const fromLockAdditionalFields = getValueByPath(fromObject, [
    "lockAdditionalFields"
  ]);
  if (parentObject !== void 0 && fromLockAdditionalFields != null) {
    setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
  }
  return toObject;
}
function createAuthTokenParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function fileDataToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function googleMapsToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function liveConnectConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== void 0 && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== void 0 && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== void 0 && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== void 0 && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== void 0 && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== void 0 && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== void 0 && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (parentObject !== void 0 && fromThinkingConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== void 0 && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== void 0 && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== void 0 && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
  }
  if (getValueByPath(fromObject, ["explicitVadSignal"]) !== void 0) {
    throw new Error("explicitVadSignal parameter is not supported in Gemini API.");
  }
  return toObject;
}
function liveConnectConstraintsToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function partToMldev(fromObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function sessionResumptionConfigToMldev(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
    throw new Error("transparent parameter is not supported in Gemini API.");
  }
  return toObject;
}
function toolToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function getFieldMasks(setup) {
  const fields = [];
  for (const key in setup) {
    if (Object.prototype.hasOwnProperty.call(setup, key)) {
      const value = setup[key];
      if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
        const field = Object.keys(value).map((kk) => `${key}.${kk}`);
        fields.push(...field);
      } else {
        fields.push(key);
      }
    }
  }
  return fields.join(",");
}
function convertBidiSetupToTokenSetup(requestDict, config) {
  let setupForMaskGeneration = null;
  const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
  if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
    const innerSetup = bidiGenerateContentSetupValue.setup;
    if (typeof innerSetup === "object" && innerSetup !== null) {
      requestDict["bidiGenerateContentSetup"] = innerSetup;
      setupForMaskGeneration = innerSetup;
    } else {
      delete requestDict["bidiGenerateContentSetup"];
    }
  } else if (bidiGenerateContentSetupValue !== void 0) {
    delete requestDict["bidiGenerateContentSetup"];
  }
  const preExistingFieldMask = requestDict["fieldMask"];
  if (setupForMaskGeneration) {
    const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
    if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {
      if (generatedMaskFromBidi) {
        requestDict["fieldMask"] = generatedMaskFromBidi;
      } else {
        delete requestDict["fieldMask"];
      }
    } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
      const generationConfigFields = [
        "temperature",
        "topK",
        "topP",
        "maxOutputTokens",
        "responseModalities",
        "seed",
        "speechConfig"
      ];
      let mappedFieldsFromPreExisting = [];
      if (preExistingFieldMask.length > 0) {
        mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
          if (generationConfigFields.includes(field)) {
            return `generationConfig.${field}`;
          }
          return field;
        });
      }
      const finalMaskParts = [];
      if (generatedMaskFromBidi) {
        finalMaskParts.push(generatedMaskFromBidi);
      }
      if (mappedFieldsFromPreExisting.length > 0) {
        finalMaskParts.push(...mappedFieldsFromPreExisting);
      }
      if (finalMaskParts.length > 0) {
        requestDict["fieldMask"] = finalMaskParts.join(",");
      } else {
        delete requestDict["fieldMask"];
      }
    } else {
      delete requestDict["fieldMask"];
    }
  } else {
    if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
      requestDict["fieldMask"] = preExistingFieldMask.join(",");
    } else {
      delete requestDict["fieldMask"];
    }
  }
  return requestDict;
}
function deleteDocumentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromForce = getValueByPath(fromObject, ["force"]);
  if (parentObject !== void 0 && fromForce != null) {
    setValueByPath(parentObject, ["_query", "force"], fromForce);
  }
  return toObject;
}
function deleteDocumentParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    deleteDocumentConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function getDocumentParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function listDocumentsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listDocumentsParametersToMldev(fromObject) {
  const toObject = {};
  const fromParent = getValueByPath(fromObject, ["parent"]);
  if (fromParent != null) {
    setValueByPath(toObject, ["_url", "parent"], fromParent);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listDocumentsConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listDocumentsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromDocuments = getValueByPath(fromObject, ["documents"]);
  if (fromDocuments != null) {
    let transformedList = fromDocuments;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["documents"], transformedList);
  }
  return toObject;
}
function isAbortError(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new GeminiNextGenAPIClient({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream = globalThis.ReadableStream;
  if (typeof ReadableStream === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      var _a2;
      await ((_a2 = iter.return) === null || _a2 === void 0 ? void 0 : _a2.call(iter));
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result === null || result === void 0 ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  var _a2, _b;
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await ((_b = (_a2 = stream[Symbol.asyncIterator]()).return) === null || _b === void 0 ? void 0 : _b.call(_a2));
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName !== null && fileName !== void 0 ? fileName : "unknown_file", options);
}
function getName(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options);
  }
  const parts = await getBytes(value);
  name || (name = getName(value));
  if (!(options === null || options === void 0 ? void 0 : options.type)) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = Object.assign(Object.assign({}, options), { type });
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes(value) {
  var _a2, e_1, _b, _c;
  var _d;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    try {
      for (var _e = true, value_1 = __asyncValues(value), value_1_1; value_1_1 = await value_1.next(), _a2 = value_1_1.done, !_a2; _e = true) {
        _c = value_1_1.value;
        _e = false;
        const chunk = _c;
        parts.push(...await getBytes(chunk));
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (!_e && !_a2 && (_b = value_1.return))
          await _b.call(value_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  } else {
    const constructor = (_d = value === null || value === void 0 ? void 0 : value.constructor) === null || _d === void 0 ? void 0 : _d.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}
function encodeURIPath(str) {
  return str.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
function encodeUTF8(str) {
  let encoder;
  return (encodeUTF8_ !== null && encodeUTF8_ !== void 0 ? encodeUTF8_ : (encoder = new globalThis.TextEncoder(), encodeUTF8_ = encoder.encode.bind(encoder)))(str);
}
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ !== null && decodeUTF8_ !== void 0 ? decodeUTF8_ : (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex !== null && startIndex !== void 0 ? startIndex : 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
function noop() {
}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
function loggerFor(client) {
  var _a2;
  const logger = client.logger;
  const logLevel = (_a2 = client.logLevel) !== null && _a2 !== void 0 ? _a2 : "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
function _iterSSEMessages(response, controller) {
  return __asyncGenerator(this, arguments, function* _iterSSEMessages_1() {
    var _a2, e_4, _b, _c;
    if (!response.body) {
      controller.abort();
      if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
        throw new GeminiNextGenAPIClientError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
      }
      throw new GeminiNextGenAPIClientError(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder();
    const lineDecoder = new LineDecoder();
    const iter = ReadableStreamToAsyncIterable(response.body);
    try {
      for (var _d = true, _e = __asyncValues(iterSSEChunks(iter)), _f; _f = yield __await(_e.next()), _a2 = _f.done, !_a2; _d = true) {
        _c = _f.value;
        _d = false;
        const sseChunk = _c;
        for (const line of lineDecoder.decode(sseChunk)) {
          const sse = sseDecoder.decode(line);
          if (sse)
            yield yield __await(sse);
        }
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (!_d && !_a2 && (_b = _e.return))
          yield __await(_b.call(_e));
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield yield __await(sse);
    }
  });
}
function iterSSEChunks(iterator) {
  return __asyncGenerator(this, arguments, function* iterSSEChunks_1() {
    var _a2, e_5, _b, _c;
    let data = new Uint8Array();
    try {
      for (var _d = true, iterator_3 = __asyncValues(iterator), iterator_3_1; iterator_3_1 = yield __await(iterator_3.next()), _a2 = iterator_3_1.done, !_a2; _d = true) {
        _c = iterator_3_1.value;
        _d = false;
        const chunk = _c;
        if (chunk == null) {
          continue;
        }
        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
        let newData = new Uint8Array(data.length + binaryChunk.length);
        newData.set(data);
        newData.set(binaryChunk, data.length);
        data = newData;
        let patternIndex;
        while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
          yield yield __await(data.slice(0, patternIndex));
          data = data.slice(patternIndex);
        }
      }
    } catch (e_5_1) {
      e_5 = { error: e_5_1 };
    } finally {
      try {
        if (!_d && !_a2 && (_b = iterator_3.return))
          yield __await(_b.call(iterator_3));
      } finally {
        if (e_5)
          throw e_5.error;
      }
    }
    if (data.length > 0) {
      yield yield __await(data);
    }
  });
}
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}
async function defaultParseResponse(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    var _a2;
    if (props.options.stream) {
      loggerFor(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client);
      }
      return Stream.fromSSEResponse(response, props.controller, client);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = (_a2 = contentType === null || contentType === void 0 ? void 0 : contentType.split(";")[0]) === null || _a2 === void 0 ? void 0 : _a2.trim();
    const isJSON = (mediaType === null || mediaType === void 0 ? void 0 : mediaType.includes("application/json")) || (mediaType === null || mediaType === void 0 ? void 0 : mediaType.endsWith("+json"));
    if (isJSON) {
      const json = await response.json();
      return json;
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers !== null && headers !== void 0 ? headers : {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
function cancelTuningJobParametersToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function cancelTuningJobParametersToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function cancelTuningJobResponseFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function cancelTuningJobResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) {
    throw new Error("validationDataset parameter is not supported in Gemini API.");
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
  }
  if (getValueByPath(fromObject, ["description"]) !== void 0) {
    throw new Error("description parameter is not supported in Gemini API.");
  }
  const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
  if (parentObject !== void 0 && fromEpochCount != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
  }
  const fromLearningRateMultiplier = getValueByPath(fromObject, [
    "learningRateMultiplier"
  ]);
  if (fromLearningRateMultiplier != null) {
    setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
  }
  if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) {
    throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["preTunedModelCheckpointId"]) !== void 0) {
    throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) {
    throw new Error("adapterSize parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["tuningMode"]) !== void 0) {
    throw new Error("tuningMode parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["customBaseModel"]) !== void 0) {
    throw new Error("customBaseModel parameter is not supported in Gemini API.");
  }
  const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
  if (parentObject !== void 0 && fromBatchSize != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
  }
  const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
  if (parentObject !== void 0 && fromLearningRate != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["beta"]) !== void 0) {
    throw new Error("beta parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["baseTeacherModel"]) !== void 0) {
    throw new Error("baseTeacherModel parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["tunedTeacherModelSource"]) !== void 0) {
    throw new Error("tunedTeacherModelSource parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["sftLossWeightMultiplier"]) !== void 0) {
    throw new Error("sftLossWeightMultiplier parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputUri"]) !== void 0) {
    throw new Error("outputUri parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  let discriminatorValidationDataset = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorValidationDataset === void 0) {
    discriminatorValidationDataset = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorValidationDataset === "SUPERVISED_FINE_TUNING") {
    const fromValidationDataset = getValueByPath(fromObject, [
      "validationDataset"
    ]);
    if (parentObject !== void 0 && fromValidationDataset != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
    }
  } else if (discriminatorValidationDataset === "PREFERENCE_TUNING") {
    const fromValidationDataset = getValueByPath(fromObject, [
      "validationDataset"
    ]);
    if (parentObject !== void 0 && fromValidationDataset != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
    }
  } else if (discriminatorValidationDataset === "DISTILLATION") {
    const fromValidationDataset = getValueByPath(fromObject, [
      "validationDataset"
    ]);
    if (parentObject !== void 0 && fromValidationDataset != null) {
      setValueByPath(parentObject, ["distillationSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
    }
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
    setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== void 0 && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  let discriminatorEpochCount = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorEpochCount === void 0) {
    discriminatorEpochCount = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorEpochCount === "SUPERVISED_FINE_TUNING") {
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
    }
  } else if (discriminatorEpochCount === "PREFERENCE_TUNING") {
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], fromEpochCount);
    }
  } else if (discriminatorEpochCount === "DISTILLATION") {
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["distillationSpec", "hyperParameters", "epochCount"], fromEpochCount);
    }
  }
  let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorLearningRateMultiplier === void 0) {
    discriminatorLearningRateMultiplier = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorLearningRateMultiplier === "SUPERVISED_FINE_TUNING") {
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
  } else if (discriminatorLearningRateMultiplier === "PREFERENCE_TUNING") {
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
      setValueByPath(parentObject, [
        "preferenceOptimizationSpec",
        "hyperParameters",
        "learningRateMultiplier"
      ], fromLearningRateMultiplier);
    }
  } else if (discriminatorLearningRateMultiplier === "DISTILLATION") {
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
      setValueByPath(parentObject, ["distillationSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
  }
  let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ["config", "method"]);
  if (discriminatorExportLastCheckpointOnly === void 0) {
    discriminatorExportLastCheckpointOnly = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorExportLastCheckpointOnly === "SUPERVISED_FINE_TUNING") {
    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
      "exportLastCheckpointOnly"
    ]);
    if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
    }
  } else if (discriminatorExportLastCheckpointOnly === "PREFERENCE_TUNING") {
    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
      "exportLastCheckpointOnly"
    ]);
    if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
    }
  } else if (discriminatorExportLastCheckpointOnly === "DISTILLATION") {
    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
      "exportLastCheckpointOnly"
    ]);
    if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
      setValueByPath(parentObject, ["distillationSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
    }
  }
  let discriminatorAdapterSize = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorAdapterSize === void 0) {
    discriminatorAdapterSize = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorAdapterSize === "SUPERVISED_FINE_TUNING") {
    const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
    if (parentObject !== void 0 && fromAdapterSize != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
    }
  } else if (discriminatorAdapterSize === "PREFERENCE_TUNING") {
    const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
    if (parentObject !== void 0 && fromAdapterSize != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
    }
  } else if (discriminatorAdapterSize === "DISTILLATION") {
    const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
    if (parentObject !== void 0 && fromAdapterSize != null) {
      setValueByPath(parentObject, ["distillationSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
    }
  }
  let discriminatorTuningMode = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorTuningMode === void 0) {
    discriminatorTuningMode = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorTuningMode === "SUPERVISED_FINE_TUNING") {
    const fromTuningMode = getValueByPath(fromObject, ["tuningMode"]);
    if (parentObject !== void 0 && fromTuningMode != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "tuningMode"], fromTuningMode);
    }
  }
  const fromCustomBaseModel = getValueByPath(fromObject, [
    "customBaseModel"
  ]);
  if (parentObject !== void 0 && fromCustomBaseModel != null) {
    setValueByPath(parentObject, ["customBaseModel"], fromCustomBaseModel);
  }
  let discriminatorBatchSize = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorBatchSize === void 0) {
    discriminatorBatchSize = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorBatchSize === "SUPERVISED_FINE_TUNING") {
    const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
    if (parentObject !== void 0 && fromBatchSize != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "batchSize"], fromBatchSize);
    }
  }
  let discriminatorLearningRate = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorLearningRate === void 0) {
    discriminatorLearningRate = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorLearningRate === "SUPERVISED_FINE_TUNING") {
    const fromLearningRate = getValueByPath(fromObject, [
      "learningRate"
    ]);
    if (parentObject !== void 0 && fromLearningRate != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRate"], fromLearningRate);
    }
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromBeta = getValueByPath(fromObject, ["beta"]);
  if (parentObject !== void 0 && fromBeta != null) {
    setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "beta"], fromBeta);
  }
  const fromBaseTeacherModel = getValueByPath(fromObject, [
    "baseTeacherModel"
  ]);
  if (parentObject !== void 0 && fromBaseTeacherModel != null) {
    setValueByPath(parentObject, ["distillationSpec", "baseTeacherModel"], fromBaseTeacherModel);
  }
  const fromTunedTeacherModelSource = getValueByPath(fromObject, [
    "tunedTeacherModelSource"
  ]);
  if (parentObject !== void 0 && fromTunedTeacherModelSource != null) {
    setValueByPath(parentObject, ["distillationSpec", "tunedTeacherModelSource"], fromTunedTeacherModelSource);
  }
  const fromSftLossWeightMultiplier = getValueByPath(fromObject, [
    "sftLossWeightMultiplier"
  ]);
  if (parentObject !== void 0 && fromSftLossWeightMultiplier != null) {
    setValueByPath(parentObject, ["distillationSpec", "hyperParameters", "sftLossWeightMultiplier"], fromSftLossWeightMultiplier);
  }
  const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
  if (parentObject !== void 0 && fromOutputUri != null) {
    setValueByPath(parentObject, ["outputUri"], fromOutputUri);
  }
  return toObject;
}
function createTuningJobParametersPrivateToMldev(fromObject, rootObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromPreTunedModel = getValueByPath(fromObject, [
    "preTunedModel"
  ]);
  if (fromPreTunedModel != null) {
    setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
  }
  const fromTrainingDataset = getValueByPath(fromObject, [
    "trainingDataset"
  ]);
  if (fromTrainingDataset != null) {
    tuningDatasetToMldev(fromTrainingDataset);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createTuningJobConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function createTuningJobParametersPrivateToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromPreTunedModel = getValueByPath(fromObject, [
    "preTunedModel"
  ]);
  if (fromPreTunedModel != null) {
    setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
  }
  const fromTrainingDataset = getValueByPath(fromObject, [
    "trainingDataset"
  ]);
  if (fromTrainingDataset != null) {
    tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createTuningJobConfigToVertex(fromConfig, toObject, rootObject);
  }
  return toObject;
}
function getTuningJobParametersToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function getTuningJobParametersToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listTuningJobsParametersToMldev(fromObject, rootObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listTuningJobsConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listTuningJobsParametersToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listTuningJobsConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function listTuningJobsResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
  if (fromTuningJobs != null) {
    let transformedList = fromTuningJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningJobFromMldev(item);
      });
    }
    setValueByPath(toObject, ["tuningJobs"], transformedList);
  }
  return toObject;
}
function listTuningJobsResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
  if (fromTuningJobs != null) {
    let transformedList = fromTuningJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningJobFromVertex(item);
      });
    }
    setValueByPath(toObject, ["tuningJobs"], transformedList);
  }
  return toObject;
}
function tunedModelFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["name"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromEndpoint = getValueByPath(fromObject, ["name"]);
  if (fromEndpoint != null) {
    setValueByPath(toObject, ["endpoint"], fromEndpoint);
  }
  return toObject;
}
function tuningDatasetToMldev(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== void 0) {
    throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
  }
  const fromExamples = getValueByPath(fromObject, ["examples"]);
  if (fromExamples != null) {
    let transformedList = fromExamples;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["examples", "examples"], transformedList);
  }
  return toObject;
}
function tuningDatasetToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  let discriminatorGcsUri = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorGcsUri === void 0) {
    discriminatorGcsUri = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorGcsUri === "SUPERVISED_FINE_TUNING") {
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (parentObject !== void 0 && fromGcsUri != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
    }
  } else if (discriminatorGcsUri === "PREFERENCE_TUNING") {
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (parentObject !== void 0 && fromGcsUri != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromGcsUri);
    }
  } else if (discriminatorGcsUri === "DISTILLATION") {
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (parentObject !== void 0 && fromGcsUri != null) {
      setValueByPath(parentObject, ["distillationSpec", "promptDatasetUri"], fromGcsUri);
    }
  }
  let discriminatorVertexDatasetResource = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorVertexDatasetResource === void 0) {
    discriminatorVertexDatasetResource = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorVertexDatasetResource === "SUPERVISED_FINE_TUNING") {
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (parentObject !== void 0 && fromVertexDatasetResource != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
    }
  } else if (discriminatorVertexDatasetResource === "PREFERENCE_TUNING") {
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (parentObject !== void 0 && fromVertexDatasetResource != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromVertexDatasetResource);
    }
  } else if (discriminatorVertexDatasetResource === "DISTILLATION") {
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (parentObject !== void 0 && fromVertexDatasetResource != null) {
      setValueByPath(parentObject, ["distillationSpec", "promptDatasetUri"], fromVertexDatasetResource);
    }
  }
  if (getValueByPath(fromObject, ["examples"]) !== void 0) {
    throw new Error("examples parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function tuningJobFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, [
    "tuningTask",
    "startTime"
  ]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, [
    "tuningTask",
    "completeTime"
  ]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTunedModel = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModel != null) {
    setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
  }
  return toObject;
}
function tuningJobFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
  if (fromTunedModel != null) {
    setValueByPath(toObject, ["tunedModel"], fromTunedModel);
  }
  const fromPreTunedModel = getValueByPath(fromObject, [
    "preTunedModel"
  ]);
  if (fromPreTunedModel != null) {
    setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
  }
  const fromSupervisedTuningSpec = getValueByPath(fromObject, [
    "supervisedTuningSpec"
  ]);
  if (fromSupervisedTuningSpec != null) {
    setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
  }
  const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [
    "preferenceOptimizationSpec"
  ]);
  if (fromPreferenceOptimizationSpec != null) {
    setValueByPath(toObject, ["preferenceOptimizationSpec"], fromPreferenceOptimizationSpec);
  }
  const fromDistillationSpec = getValueByPath(fromObject, [
    "distillationSpec"
  ]);
  if (fromDistillationSpec != null) {
    setValueByPath(toObject, ["distillationSpec"], fromDistillationSpec);
  }
  const fromTuningDataStats = getValueByPath(fromObject, [
    "tuningDataStats"
  ]);
  if (fromTuningDataStats != null) {
    setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
  }
  const fromEncryptionSpec = getValueByPath(fromObject, [
    "encryptionSpec"
  ]);
  if (fromEncryptionSpec != null) {
    setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
  }
  const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
    "partnerModelTuningSpec"
  ]);
  if (fromPartnerModelTuningSpec != null) {
    setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
  }
  const fromCustomBaseModel = getValueByPath(fromObject, [
    "customBaseModel"
  ]);
  if (fromCustomBaseModel != null) {
    setValueByPath(toObject, ["customBaseModel"], fromCustomBaseModel);
  }
  const fromExperiment = getValueByPath(fromObject, ["experiment"]);
  if (fromExperiment != null) {
    setValueByPath(toObject, ["experiment"], fromExperiment);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
  if (fromOutputUri != null) {
    setValueByPath(toObject, ["outputUri"], fromOutputUri);
  }
  const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
  if (fromPipelineJob != null) {
    setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
  }
  const fromServiceAccount = getValueByPath(fromObject, [
    "serviceAccount"
  ]);
  if (fromServiceAccount != null) {
    setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (fromTunedModelDisplayName != null) {
    setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  const fromVeoTuningSpec = getValueByPath(fromObject, [
    "veoTuningSpec"
  ]);
  if (fromVeoTuningSpec != null) {
    setValueByPath(toObject, ["veoTuningSpec"], fromVeoTuningSpec);
  }
  return toObject;
}
function tuningOperationFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function tuningValidationDatasetToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
  }
  const fromVertexDatasetResource = getValueByPath(fromObject, [
    "vertexDatasetResource"
  ]);
  if (fromVertexDatasetResource != null) {
    setValueByPath(toObject, ["validationDatasetUri"], fromVertexDatasetResource);
  }
  return toObject;
}
async function uploadBlob(file, uploadUrl, apiClient) {
  var _a2;
  const response = await uploadBlobInternal(file, uploadUrl, apiClient);
  const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
  if (((_a2 = response === null || response === void 0 ? void 0 : response.headers) === null || _a2 === void 0 ? void 0 : _a2[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
    throw new Error("Failed to upload file: Upload status is not finalized.");
  }
  return responseJson["file"];
}
async function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {
  var _a2;
  const response = await uploadBlobInternal(file, uploadUrl, apiClient);
  const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
  if (((_a2 = response === null || response === void 0 ? void 0 : response.headers) === null || _a2 === void 0 ? void 0 : _a2[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
    throw new Error("Failed to upload file: Upload status is not finalized.");
  }
  const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);
  const typedResp = new UploadToFileSearchStoreOperation();
  Object.assign(typedResp, resp);
  return typedResp;
}
async function uploadBlobInternal(file, uploadUrl, apiClient) {
  var _a2, _b;
  let fileSize = 0;
  let offset = 0;
  let response = new HttpResponse(new Response());
  let uploadCommand = "upload";
  fileSize = file.size;
  while (offset < fileSize) {
    const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
    const chunk = file.slice(offset, offset + chunkSize);
    if (offset + chunkSize >= fileSize) {
      uploadCommand += ", finalize";
    }
    let retryCount = 0;
    let currentDelayMs = INITIAL_RETRY_DELAY_MS;
    while (retryCount < MAX_RETRY_COUNT) {
      response = await apiClient.request({
        path: "",
        body: chunk,
        httpMethod: "POST",
        httpOptions: {
          apiVersion: "",
          baseUrl: uploadUrl,
          headers: {
            "X-Goog-Upload-Command": uploadCommand,
            "X-Goog-Upload-Offset": String(offset),
            "Content-Length": String(chunkSize)
          }
        }
      });
      if ((_a2 = response === null || response === void 0 ? void 0 : response.headers) === null || _a2 === void 0 ? void 0 : _a2[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
        break;
      }
      retryCount++;
      await sleep(currentDelayMs);
      currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
    }
    offset += chunkSize;
    if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
      break;
    }
    if (fileSize <= offset) {
      throw new Error("All content has been uploaded, but the upload status is not finalized.");
    }
  }
  return response;
}
async function getBlobStat(file) {
  const fileStat = { size: file.size, type: file.type };
  return fileStat;
}
function sleep(ms) {
  return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
}
var _defaultBaseGeminiUrl, _defaultBaseVertexUrl, BaseModule, Outcome, Language, FunctionResponseScheduling, Type, ApiSpec, AuthType, HttpElementLocation, PhishBlockThreshold, Behavior, DynamicRetrievalConfigMode, FunctionCallingConfigMode, ThinkingLevel, HarmCategory, HarmBlockMethod, HarmBlockThreshold, FinishReason, HarmProbability, HarmSeverity, UrlRetrievalStatus, BlockedReason, TrafficType, Modality, MediaResolution, TuningMode, AdapterSize, JobState, TuningTask, PartMediaResolutionLevel, ResourceScope, FeatureSelectionPreference, Environment, SafetyFilterLevel, PersonGeneration, ImagePromptLanguage, MaskReferenceMode, ControlReferenceType, SubjectReferenceType, EditMode, SegmentMode, VideoGenerationReferenceType, VideoGenerationMaskMode, VideoCompressionQuality, TuningMethod, DocumentState, FileState, FileSource, TurnCompleteReason, MediaModality, VadSignalType, VoiceActivityType, StartSensitivity, EndSensitivity, ActivityHandling, TurnCoverage, Scale, MusicGenerationMode, LiveMusicPlaybackControl, FunctionResponseBlob, FunctionResponseFileData, FunctionResponsePart, FunctionResponse, HttpResponse, GenerateContentResponsePromptFeedback, GenerateContentResponseUsageMetadata, GenerateContentResponse, EmbedContentResponse, GenerateImagesResponse, EditImageResponse, UpscaleImageResponse, RecontextImageResponse, SegmentImageResponse, ListModelsResponse, DeleteModelResponse, CountTokensResponse, ComputeTokensResponse, GenerateVideosResponse, GenerateVideosOperation, ListTuningJobsResponse, CancelTuningJobResponse, DeleteCachedContentResponse, ListCachedContentsResponse, ListDocumentsResponse, ListFileSearchStoresResponse, UploadToFileSearchStoreResumableResponse, ImportFileResponse, ImportFileOperation, ListFilesResponse, CreateFileResponse, DeleteFileResponse, RegisterFilesResponse, InlinedResponse, SingleEmbedContentResponse, InlinedEmbedContentResponse, ListBatchJobsResponse, ReplayResponse, RawReferenceImage, MaskReferenceImage, ControlReferenceImage, StyleReferenceImage, SubjectReferenceImage, ContentReferenceImage, LiveServerMessage, LiveClientToolResponse, LiveSendToolResponseParameters, LiveMusicServerMessage, UploadToFileSearchStoreResponse, UploadToFileSearchStoreOperation, PagedItem, Pager, Batches, Caches, Chats, Chat, ApiError, Files, CONTENT_TYPE_HEADER, SERVER_TIMEOUT_HEADER, USER_AGENT_HEADER, GOOGLE_API_CLIENT_HEADER, SDK_VERSION, LIBRARY_LABEL, VERTEX_AI_API_DEFAULT_VERSION, GOOGLE_AI_API_DEFAULT_VERSION, ApiClient, MCP_LABEL, hasMcpToolUsageFromMcpToTool, McpCallableTool, LiveMusic, LiveMusicSession, FUNCTION_RESPONSE_REQUIRES_ID, Live, defaultLiveSendClientContentParamerters, Session, DEFAULT_MAX_REMOTE_CALLS, Models, Operations, Tokens, Documents, FileSearchStores, uuid4Internal, uuid4, castToError, GeminiNextGenAPIClientError, APIError, APIUserAbortError, APIConnectionError, APIConnectionTimeoutError, BadRequestError, AuthenticationError, PermissionDeniedError, NotFoundError, ConflictError, UnprocessableEntityError, RateLimitError, InternalServerError, startsWithSchemeRegexp, isAbsoluteURL, isArrayInternal, isArray, isReadonlyArrayInternal, isReadonlyArray, validatePositiveInteger, safeJSON, sleep$1, VERSION, getPlatformProperties, normalizeArch, normalizePlatform, _platformHeaders, getPlatformHeaders, FallbackEncoder, checkFileSupport, isAsyncIterable, isBlobLike, isFileLike, isResponseLike, APIResource, EMPTY, createPathTagFunction, path, BaseInteractions, Interactions, encodeUTF8_, decodeUTF8_, LineDecoder, levelNumbers, parseLogLevel, noopLogger, cachedLoggers, formatRequestDetails, Stream, SSEDecoder, APIPromise, brand_privateNullableHeaders, buildHeaders, readEnv, _a, BaseGeminiNextGenAPIClient, GeminiNextGenAPIClient, Tunings, BrowserDownloader, MAX_CHUNK_SIZE, MAX_RETRY_COUNT, INITIAL_RETRY_DELAY_MS, DELAY_MULTIPLIER, X_GOOG_UPLOAD_STATUS_HEADER_FIELD, BrowserUploader, BrowserWebSocketFactory, BrowserWebSocket, GOOGLE_API_KEY_HEADER, WebAuth, LANGUAGE_LABEL_PREFIX, GoogleGenAI;
var init_web = __esm({
  "../../node_modules/.pnpm/@google+genai@1.39.0/node_modules/@google/genai/dist/web/index.mjs"() {
    _defaultBaseGeminiUrl = void 0;
    _defaultBaseVertexUrl = void 0;
    BaseModule = class {
    };
    (function(Outcome2) {
      Outcome2["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
      Outcome2["OUTCOME_OK"] = "OUTCOME_OK";
      Outcome2["OUTCOME_FAILED"] = "OUTCOME_FAILED";
      Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
    })(Outcome || (Outcome = {}));
    (function(Language2) {
      Language2["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
      Language2["PYTHON"] = "PYTHON";
    })(Language || (Language = {}));
    (function(FunctionResponseScheduling2) {
      FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
      FunctionResponseScheduling2["SILENT"] = "SILENT";
      FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
      FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
    })(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
    (function(Type2) {
      Type2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
      Type2["STRING"] = "STRING";
      Type2["NUMBER"] = "NUMBER";
      Type2["INTEGER"] = "INTEGER";
      Type2["BOOLEAN"] = "BOOLEAN";
      Type2["ARRAY"] = "ARRAY";
      Type2["OBJECT"] = "OBJECT";
      Type2["NULL"] = "NULL";
    })(Type || (Type = {}));
    (function(ApiSpec2) {
      ApiSpec2["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
      ApiSpec2["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
      ApiSpec2["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
    })(ApiSpec || (ApiSpec = {}));
    (function(AuthType2) {
      AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
      AuthType2["NO_AUTH"] = "NO_AUTH";
      AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
      AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
      AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
      AuthType2["OAUTH"] = "OAUTH";
      AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
    })(AuthType || (AuthType = {}));
    (function(HttpElementLocation2) {
      HttpElementLocation2["HTTP_IN_UNSPECIFIED"] = "HTTP_IN_UNSPECIFIED";
      HttpElementLocation2["HTTP_IN_QUERY"] = "HTTP_IN_QUERY";
      HttpElementLocation2["HTTP_IN_HEADER"] = "HTTP_IN_HEADER";
      HttpElementLocation2["HTTP_IN_PATH"] = "HTTP_IN_PATH";
      HttpElementLocation2["HTTP_IN_BODY"] = "HTTP_IN_BODY";
      HttpElementLocation2["HTTP_IN_COOKIE"] = "HTTP_IN_COOKIE";
    })(HttpElementLocation || (HttpElementLocation = {}));
    (function(PhishBlockThreshold2) {
      PhishBlockThreshold2["PHISH_BLOCK_THRESHOLD_UNSPECIFIED"] = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED";
      PhishBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_HIGH_AND_ABOVE"] = "BLOCK_HIGH_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_HIGHER_AND_ABOVE"] = "BLOCK_HIGHER_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_VERY_HIGH_AND_ABOVE"] = "BLOCK_VERY_HIGH_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_ONLY_EXTREMELY_HIGH"] = "BLOCK_ONLY_EXTREMELY_HIGH";
    })(PhishBlockThreshold || (PhishBlockThreshold = {}));
    (function(Behavior2) {
      Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
      Behavior2["BLOCKING"] = "BLOCKING";
      Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
    })(Behavior || (Behavior = {}));
    (function(DynamicRetrievalConfigMode2) {
      DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
    })(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
    (function(FunctionCallingConfigMode2) {
      FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      FunctionCallingConfigMode2["AUTO"] = "AUTO";
      FunctionCallingConfigMode2["ANY"] = "ANY";
      FunctionCallingConfigMode2["NONE"] = "NONE";
      FunctionCallingConfigMode2["VALIDATED"] = "VALIDATED";
    })(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
    (function(ThinkingLevel2) {
      ThinkingLevel2["THINKING_LEVEL_UNSPECIFIED"] = "THINKING_LEVEL_UNSPECIFIED";
      ThinkingLevel2["LOW"] = "LOW";
      ThinkingLevel2["MEDIUM"] = "MEDIUM";
      ThinkingLevel2["HIGH"] = "HIGH";
      ThinkingLevel2["MINIMAL"] = "MINIMAL";
    })(ThinkingLevel || (ThinkingLevel = {}));
    (function(HarmCategory2) {
      HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
      HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
      HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
      HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
      HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
      HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
      HarmCategory2["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
      HarmCategory2["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
      HarmCategory2["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
      HarmCategory2["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
      HarmCategory2["HARM_CATEGORY_JAILBREAK"] = "HARM_CATEGORY_JAILBREAK";
    })(HarmCategory || (HarmCategory = {}));
    (function(HarmBlockMethod2) {
      HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
      HarmBlockMethod2["SEVERITY"] = "SEVERITY";
      HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
    })(HarmBlockMethod || (HarmBlockMethod = {}));
    (function(HarmBlockThreshold2) {
      HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
      HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
      HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
      HarmBlockThreshold2["OFF"] = "OFF";
    })(HarmBlockThreshold || (HarmBlockThreshold = {}));
    (function(FinishReason2) {
      FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
      FinishReason2["STOP"] = "STOP";
      FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
      FinishReason2["SAFETY"] = "SAFETY";
      FinishReason2["RECITATION"] = "RECITATION";
      FinishReason2["LANGUAGE"] = "LANGUAGE";
      FinishReason2["OTHER"] = "OTHER";
      FinishReason2["BLOCKLIST"] = "BLOCKLIST";
      FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
      FinishReason2["SPII"] = "SPII";
      FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
      FinishReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
      FinishReason2["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
      FinishReason2["IMAGE_PROHIBITED_CONTENT"] = "IMAGE_PROHIBITED_CONTENT";
      FinishReason2["NO_IMAGE"] = "NO_IMAGE";
      FinishReason2["IMAGE_RECITATION"] = "IMAGE_RECITATION";
      FinishReason2["IMAGE_OTHER"] = "IMAGE_OTHER";
    })(FinishReason || (FinishReason = {}));
    (function(HarmProbability2) {
      HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
      HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
      HarmProbability2["LOW"] = "LOW";
      HarmProbability2["MEDIUM"] = "MEDIUM";
      HarmProbability2["HIGH"] = "HIGH";
    })(HarmProbability || (HarmProbability = {}));
    (function(HarmSeverity2) {
      HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
      HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
      HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
      HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
      HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
    })(HarmSeverity || (HarmSeverity = {}));
    (function(UrlRetrievalStatus2) {
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_PAYWALL"] = "URL_RETRIEVAL_STATUS_PAYWALL";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSAFE"] = "URL_RETRIEVAL_STATUS_UNSAFE";
    })(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
    (function(BlockedReason2) {
      BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
      BlockedReason2["SAFETY"] = "SAFETY";
      BlockedReason2["OTHER"] = "OTHER";
      BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
      BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
      BlockedReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
      BlockedReason2["MODEL_ARMOR"] = "MODEL_ARMOR";
      BlockedReason2["JAILBREAK"] = "JAILBREAK";
    })(BlockedReason || (BlockedReason = {}));
    (function(TrafficType2) {
      TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
      TrafficType2["ON_DEMAND"] = "ON_DEMAND";
      TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
    })(TrafficType || (TrafficType = {}));
    (function(Modality2) {
      Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
      Modality2["TEXT"] = "TEXT";
      Modality2["IMAGE"] = "IMAGE";
      Modality2["AUDIO"] = "AUDIO";
    })(Modality || (Modality = {}));
    (function(MediaResolution2) {
      MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
      MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
      MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
      MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
    })(MediaResolution || (MediaResolution = {}));
    (function(TuningMode2) {
      TuningMode2["TUNING_MODE_UNSPECIFIED"] = "TUNING_MODE_UNSPECIFIED";
      TuningMode2["TUNING_MODE_FULL"] = "TUNING_MODE_FULL";
      TuningMode2["TUNING_MODE_PEFT_ADAPTER"] = "TUNING_MODE_PEFT_ADAPTER";
    })(TuningMode || (TuningMode = {}));
    (function(AdapterSize2) {
      AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
      AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
      AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
      AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
      AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
      AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
      AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
    })(AdapterSize || (AdapterSize = {}));
    (function(JobState2) {
      JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
      JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
      JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
      JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
      JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
      JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
      JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
      JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
      JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
      JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
      JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
      JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
    })(JobState || (JobState = {}));
    (function(TuningTask2) {
      TuningTask2["TUNING_TASK_UNSPECIFIED"] = "TUNING_TASK_UNSPECIFIED";
      TuningTask2["TUNING_TASK_I2V"] = "TUNING_TASK_I2V";
      TuningTask2["TUNING_TASK_T2V"] = "TUNING_TASK_T2V";
      TuningTask2["TUNING_TASK_R2V"] = "TUNING_TASK_R2V";
    })(TuningTask || (TuningTask = {}));
    (function(PartMediaResolutionLevel2) {
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_ULTRA_HIGH"] = "MEDIA_RESOLUTION_ULTRA_HIGH";
    })(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));
    (function(ResourceScope2) {
      ResourceScope2["COLLECTION"] = "COLLECTION";
    })(ResourceScope || (ResourceScope = {}));
    (function(FeatureSelectionPreference2) {
      FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
      FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
      FeatureSelectionPreference2["BALANCED"] = "BALANCED";
      FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
    })(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
    (function(Environment2) {
      Environment2["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
      Environment2["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
    })(Environment || (Environment = {}));
    (function(SafetyFilterLevel2) {
      SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
      SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
    })(SafetyFilterLevel || (SafetyFilterLevel = {}));
    (function(PersonGeneration2) {
      PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
      PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
      PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
    })(PersonGeneration || (PersonGeneration = {}));
    (function(ImagePromptLanguage2) {
      ImagePromptLanguage2["auto"] = "auto";
      ImagePromptLanguage2["en"] = "en";
      ImagePromptLanguage2["ja"] = "ja";
      ImagePromptLanguage2["ko"] = "ko";
      ImagePromptLanguage2["hi"] = "hi";
      ImagePromptLanguage2["zh"] = "zh";
      ImagePromptLanguage2["pt"] = "pt";
      ImagePromptLanguage2["es"] = "es";
    })(ImagePromptLanguage || (ImagePromptLanguage = {}));
    (function(MaskReferenceMode2) {
      MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
      MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
      MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
      MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
      MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
    })(MaskReferenceMode || (MaskReferenceMode = {}));
    (function(ControlReferenceType2) {
      ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
      ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
      ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
      ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
    })(ControlReferenceType || (ControlReferenceType = {}));
    (function(SubjectReferenceType2) {
      SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
      SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
      SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
      SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
    })(SubjectReferenceType || (SubjectReferenceType = {}));
    (function(EditMode2) {
      EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
      EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
      EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
      EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
      EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
      EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
      EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
      EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
    })(EditMode || (EditMode = {}));
    (function(SegmentMode2) {
      SegmentMode2["FOREGROUND"] = "FOREGROUND";
      SegmentMode2["BACKGROUND"] = "BACKGROUND";
      SegmentMode2["PROMPT"] = "PROMPT";
      SegmentMode2["SEMANTIC"] = "SEMANTIC";
      SegmentMode2["INTERACTIVE"] = "INTERACTIVE";
    })(SegmentMode || (SegmentMode = {}));
    (function(VideoGenerationReferenceType2) {
      VideoGenerationReferenceType2["ASSET"] = "ASSET";
      VideoGenerationReferenceType2["STYLE"] = "STYLE";
    })(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));
    (function(VideoGenerationMaskMode2) {
      VideoGenerationMaskMode2["INSERT"] = "INSERT";
      VideoGenerationMaskMode2["REMOVE"] = "REMOVE";
      VideoGenerationMaskMode2["REMOVE_STATIC"] = "REMOVE_STATIC";
      VideoGenerationMaskMode2["OUTPAINT"] = "OUTPAINT";
    })(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));
    (function(VideoCompressionQuality2) {
      VideoCompressionQuality2["OPTIMIZED"] = "OPTIMIZED";
      VideoCompressionQuality2["LOSSLESS"] = "LOSSLESS";
    })(VideoCompressionQuality || (VideoCompressionQuality = {}));
    (function(TuningMethod2) {
      TuningMethod2["SUPERVISED_FINE_TUNING"] = "SUPERVISED_FINE_TUNING";
      TuningMethod2["PREFERENCE_TUNING"] = "PREFERENCE_TUNING";
      TuningMethod2["DISTILLATION"] = "DISTILLATION";
    })(TuningMethod || (TuningMethod = {}));
    (function(DocumentState2) {
      DocumentState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
      DocumentState2["STATE_PENDING"] = "STATE_PENDING";
      DocumentState2["STATE_ACTIVE"] = "STATE_ACTIVE";
      DocumentState2["STATE_FAILED"] = "STATE_FAILED";
    })(DocumentState || (DocumentState = {}));
    (function(FileState2) {
      FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
      FileState2["PROCESSING"] = "PROCESSING";
      FileState2["ACTIVE"] = "ACTIVE";
      FileState2["FAILED"] = "FAILED";
    })(FileState || (FileState = {}));
    (function(FileSource2) {
      FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
      FileSource2["UPLOADED"] = "UPLOADED";
      FileSource2["GENERATED"] = "GENERATED";
      FileSource2["REGISTERED"] = "REGISTERED";
    })(FileSource || (FileSource = {}));
    (function(TurnCompleteReason2) {
      TurnCompleteReason2["TURN_COMPLETE_REASON_UNSPECIFIED"] = "TURN_COMPLETE_REASON_UNSPECIFIED";
      TurnCompleteReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
      TurnCompleteReason2["RESPONSE_REJECTED"] = "RESPONSE_REJECTED";
      TurnCompleteReason2["NEED_MORE_INPUT"] = "NEED_MORE_INPUT";
    })(TurnCompleteReason || (TurnCompleteReason = {}));
    (function(MediaModality2) {
      MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
      MediaModality2["TEXT"] = "TEXT";
      MediaModality2["IMAGE"] = "IMAGE";
      MediaModality2["VIDEO"] = "VIDEO";
      MediaModality2["AUDIO"] = "AUDIO";
      MediaModality2["DOCUMENT"] = "DOCUMENT";
    })(MediaModality || (MediaModality = {}));
    (function(VadSignalType2) {
      VadSignalType2["VAD_SIGNAL_TYPE_UNSPECIFIED"] = "VAD_SIGNAL_TYPE_UNSPECIFIED";
      VadSignalType2["VAD_SIGNAL_TYPE_SOS"] = "VAD_SIGNAL_TYPE_SOS";
      VadSignalType2["VAD_SIGNAL_TYPE_EOS"] = "VAD_SIGNAL_TYPE_EOS";
    })(VadSignalType || (VadSignalType = {}));
    (function(VoiceActivityType2) {
      VoiceActivityType2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
      VoiceActivityType2["ACTIVITY_START"] = "ACTIVITY_START";
      VoiceActivityType2["ACTIVITY_END"] = "ACTIVITY_END";
    })(VoiceActivityType || (VoiceActivityType = {}));
    (function(StartSensitivity2) {
      StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
      StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
      StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
    })(StartSensitivity || (StartSensitivity = {}));
    (function(EndSensitivity2) {
      EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
      EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
      EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
    })(EndSensitivity || (EndSensitivity = {}));
    (function(ActivityHandling2) {
      ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
      ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
      ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
    })(ActivityHandling || (ActivityHandling = {}));
    (function(TurnCoverage2) {
      TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
      TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
      TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
    })(TurnCoverage || (TurnCoverage = {}));
    (function(Scale2) {
      Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
      Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
      Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
      Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
      Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
      Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
      Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
      Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
      Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
      Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
      Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
      Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
      Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
    })(Scale || (Scale = {}));
    (function(MusicGenerationMode2) {
      MusicGenerationMode2["MUSIC_GENERATION_MODE_UNSPECIFIED"] = "MUSIC_GENERATION_MODE_UNSPECIFIED";
      MusicGenerationMode2["QUALITY"] = "QUALITY";
      MusicGenerationMode2["DIVERSITY"] = "DIVERSITY";
      MusicGenerationMode2["VOCALIZATION"] = "VOCALIZATION";
    })(MusicGenerationMode || (MusicGenerationMode = {}));
    (function(LiveMusicPlaybackControl2) {
      LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
      LiveMusicPlaybackControl2["PLAY"] = "PLAY";
      LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
      LiveMusicPlaybackControl2["STOP"] = "STOP";
      LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
    })(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
    FunctionResponseBlob = class {
    };
    FunctionResponseFileData = class {
    };
    FunctionResponsePart = class {
    };
    FunctionResponse = class {
    };
    HttpResponse = class {
      constructor(response) {
        const headers = {};
        for (const pair of response.headers.entries()) {
          headers[pair[0]] = pair[1];
        }
        this.headers = headers;
        this.responseInternal = response;
      }
      json() {
        return this.responseInternal.json();
      }
    };
    GenerateContentResponsePromptFeedback = class {
    };
    GenerateContentResponseUsageMetadata = class {
    };
    GenerateContentResponse = class {
      /**
       * Returns the concatenation of all text parts from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the text from the first
       * one will be returned.
       * If there are non-text parts in the response, the concatenation of all text
       * parts will be returned, and a warning will be logged.
       * If there are thought parts in the response, the concatenation of all text
       * parts excluding the thought parts will be returned.
       *
       * @example
       * ```ts
       * const response = await ai.models.generateContent({
       *   model: 'gemini-2.0-flash',
       *   contents:
       *     'Why is the sky blue?',
       * });
       *
       * console.debug(response.text);
       * ```
       */
      get text() {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        if (((_d = (_c = (_b = (_a2 = this.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning text from the first one.");
        }
        let text = "";
        let anyTextPartText = false;
        const nonTextParts = [];
        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "text" && fieldName !== "thought" && fieldName !== "thoughtSignature" && (fieldValue !== null || fieldValue !== void 0)) {
              nonTextParts.push(fieldName);
            }
          }
          if (typeof part.text === "string") {
            if (typeof part.thought === "boolean" && part.thought) {
              continue;
            }
            anyTextPartText = true;
            text += part.text;
          }
        }
        if (nonTextParts.length > 0) {
          console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
        }
        return anyTextPartText ? text : void 0;
      }
      /**
       * Returns the concatenation of all inline data parts from the first candidate
       * in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the inline data from the
       * first one will be returned. If there are non-inline data parts in the
       * response, the concatenation of all inline data parts will be returned, and
       * a warning will be logged.
       */
      get data() {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        if (((_d = (_c = (_b = (_a2 = this.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning data from the first one.");
        }
        let data = "";
        const nonDataParts = [];
        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) {
              nonDataParts.push(fieldName);
            }
          }
          if (part.inlineData && typeof part.inlineData.data === "string") {
            data += atob(part.inlineData.data);
          }
        }
        if (nonDataParts.length > 0) {
          console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
        }
        return data.length > 0 ? btoa(data) : void 0;
      }
      /**
       * Returns the function calls from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the function calls from
       * the first one will be returned.
       * If there are no function calls in the response, undefined will be returned.
       *
       * @example
       * ```ts
       * const controlLightFunctionDeclaration: FunctionDeclaration = {
       *   name: 'controlLight',
       *   parameters: {
       *   type: Type.OBJECT,
       *   description: 'Set the brightness and color temperature of a room light.',
       *   properties: {
       *     brightness: {
       *       type: Type.NUMBER,
       *       description:
       *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
       *     },
       *     colorTemperature: {
       *       type: Type.STRING,
       *       description:
       *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
       *     },
       *   },
       *   required: ['brightness', 'colorTemperature'],
       *  };
       *  const response = await ai.models.generateContent({
       *     model: 'gemini-2.0-flash',
       *     contents: 'Dim the lights so the room feels cozy and warm.',
       *     config: {
       *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
       *       toolConfig: {
       *         functionCallingConfig: {
       *           mode: FunctionCallingConfigMode.ANY,
       *           allowedFunctionNames: ['controlLight'],
       *         },
       *       },
       *     },
       *   });
       *  console.debug(JSON.stringify(response.functionCalls));
       * ```
       */
      get functionCalls() {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        if (((_d = (_c = (_b = (_a2 = this.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning function calls from the first one.");
        }
        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {
          return void 0;
        }
        return functionCalls;
      }
      /**
       * Returns the first executable code from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the executable code from
       * the first one will be returned.
       * If there are no executable code in the response, undefined will be
       * returned.
       *
       * @example
       * ```ts
       * const response = await ai.models.generateContent({
       *   model: 'gemini-2.0-flash',
       *   contents:
       *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
       *   config: {
       *     tools: [{codeExecution: {}}],
       *   },
       * });
       *
       * console.debug(response.executableCode);
       * ```
       */
      get executableCode() {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
        if (((_d = (_c = (_b = (_a2 = this.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning executable code from the first one.");
        }
        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== void 0);
        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {
          return void 0;
        }
        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
      }
      /**
       * Returns the first code execution result from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the code execution result from
       * the first one will be returned.
       * If there are no code execution result in the response, undefined will be returned.
       *
       * @example
       * ```ts
       * const response = await ai.models.generateContent({
       *   model: 'gemini-2.0-flash',
       *   contents:
       *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
       *   config: {
       *     tools: [{codeExecution: {}}],
       *   },
       * });
       *
       * console.debug(response.codeExecutionResult);
       * ```
       */
      get codeExecutionResult() {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
        if (((_d = (_c = (_b = (_a2 = this.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
        }
        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== void 0);
        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {
          return void 0;
        }
        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
      }
    };
    EmbedContentResponse = class {
    };
    GenerateImagesResponse = class {
    };
    EditImageResponse = class {
    };
    UpscaleImageResponse = class {
    };
    RecontextImageResponse = class {
    };
    SegmentImageResponse = class {
    };
    ListModelsResponse = class {
    };
    DeleteModelResponse = class {
    };
    CountTokensResponse = class {
    };
    ComputeTokensResponse = class {
    };
    GenerateVideosResponse = class {
    };
    GenerateVideosOperation = class _GenerateVideosOperation {
      /**
       * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
       * @internal
       */
      _fromAPIResponse({ apiResponse, _isVertexAI }) {
        const operation = new _GenerateVideosOperation();
        let response;
        const op = apiResponse;
        if (_isVertexAI) {
          response = generateVideosOperationFromVertex$1(op);
        } else {
          response = generateVideosOperationFromMldev$1(op);
        }
        Object.assign(operation, response);
        return operation;
      }
    };
    ListTuningJobsResponse = class {
    };
    CancelTuningJobResponse = class {
    };
    DeleteCachedContentResponse = class {
    };
    ListCachedContentsResponse = class {
    };
    ListDocumentsResponse = class {
    };
    ListFileSearchStoresResponse = class {
    };
    UploadToFileSearchStoreResumableResponse = class {
    };
    ImportFileResponse = class {
    };
    ImportFileOperation = class _ImportFileOperation {
      /**
       * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
       * @internal
       */
      _fromAPIResponse({ apiResponse, _isVertexAI }) {
        const operation = new _ImportFileOperation();
        const op = apiResponse;
        const response = importFileOperationFromMldev$1(op);
        Object.assign(operation, response);
        return operation;
      }
    };
    ListFilesResponse = class {
    };
    CreateFileResponse = class {
    };
    DeleteFileResponse = class {
    };
    RegisterFilesResponse = class {
    };
    InlinedResponse = class {
    };
    SingleEmbedContentResponse = class {
    };
    InlinedEmbedContentResponse = class {
    };
    ListBatchJobsResponse = class {
    };
    ReplayResponse = class {
    };
    RawReferenceImage = class {
      /** Internal method to convert to ReferenceImageAPIInternal. */
      toReferenceImageAPI() {
        const referenceImageAPI = {
          referenceType: "REFERENCE_TYPE_RAW",
          referenceImage: this.referenceImage,
          referenceId: this.referenceId
        };
        return referenceImageAPI;
      }
    };
    MaskReferenceImage = class {
      /** Internal method to convert to ReferenceImageAPIInternal. */
      toReferenceImageAPI() {
        const referenceImageAPI = {
          referenceType: "REFERENCE_TYPE_MASK",
          referenceImage: this.referenceImage,
          referenceId: this.referenceId,
          maskImageConfig: this.config
        };
        return referenceImageAPI;
      }
    };
    ControlReferenceImage = class {
      /** Internal method to convert to ReferenceImageAPIInternal. */
      toReferenceImageAPI() {
        const referenceImageAPI = {
          referenceType: "REFERENCE_TYPE_CONTROL",
          referenceImage: this.referenceImage,
          referenceId: this.referenceId,
          controlImageConfig: this.config
        };
        return referenceImageAPI;
      }
    };
    StyleReferenceImage = class {
      /** Internal method to convert to ReferenceImageAPIInternal. */
      toReferenceImageAPI() {
        const referenceImageAPI = {
          referenceType: "REFERENCE_TYPE_STYLE",
          referenceImage: this.referenceImage,
          referenceId: this.referenceId,
          styleImageConfig: this.config
        };
        return referenceImageAPI;
      }
    };
    SubjectReferenceImage = class {
      /* Internal method to convert to ReferenceImageAPIInternal. */
      toReferenceImageAPI() {
        const referenceImageAPI = {
          referenceType: "REFERENCE_TYPE_SUBJECT",
          referenceImage: this.referenceImage,
          referenceId: this.referenceId,
          subjectImageConfig: this.config
        };
        return referenceImageAPI;
      }
    };
    ContentReferenceImage = class {
      /** Internal method to convert to ReferenceImageAPIInternal. */
      toReferenceImageAPI() {
        const referenceImageAPI = {
          referenceType: "REFERENCE_TYPE_CONTENT",
          referenceImage: this.referenceImage,
          referenceId: this.referenceId
        };
        return referenceImageAPI;
      }
    };
    LiveServerMessage = class {
      /**
       * Returns the concatenation of all text parts from the server content if present.
       *
       * @remarks
       * If there are non-text parts in the response, the concatenation of all text
       * parts will be returned, and a warning will be logged.
       */
      get text() {
        var _a2, _b, _c;
        let text = "";
        let anyTextPartFound = false;
        const nonTextParts = [];
        for (const part of (_c = (_b = (_a2 = this.serverContent) === null || _a2 === void 0 ? void 0 : _a2.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
              nonTextParts.push(fieldName);
            }
          }
          if (typeof part.text === "string") {
            if (typeof part.thought === "boolean" && part.thought) {
              continue;
            }
            anyTextPartFound = true;
            text += part.text;
          }
        }
        if (nonTextParts.length > 0) {
          console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
        }
        return anyTextPartFound ? text : void 0;
      }
      /**
       * Returns the concatenation of all inline data parts from the server content if present.
       *
       * @remarks
       * If there are non-inline data parts in the
       * response, the concatenation of all inline data parts will be returned, and
       * a warning will be logged.
       */
      get data() {
        var _a2, _b, _c;
        let data = "";
        const nonDataParts = [];
        for (const part of (_c = (_b = (_a2 = this.serverContent) === null || _a2 === void 0 ? void 0 : _a2.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "inlineData" && fieldValue !== null) {
              nonDataParts.push(fieldName);
            }
          }
          if (part.inlineData && typeof part.inlineData.data === "string") {
            data += atob(part.inlineData.data);
          }
        }
        if (nonDataParts.length > 0) {
          console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
        }
        return data.length > 0 ? btoa(data) : void 0;
      }
    };
    LiveClientToolResponse = class {
    };
    LiveSendToolResponseParameters = class {
      constructor() {
        this.functionResponses = [];
      }
    };
    LiveMusicServerMessage = class {
      /**
       * Returns the first audio chunk from the server content, if present.
       *
       * @remarks
       * If there are no audio chunks in the response, undefined will be returned.
       */
      get audioChunk() {
        if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
          return this.serverContent.audioChunks[0];
        }
        return void 0;
      }
    };
    UploadToFileSearchStoreResponse = class {
    };
    UploadToFileSearchStoreOperation = class _UploadToFileSearchStoreOperation {
      /**
       * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
       * @internal
       */
      _fromAPIResponse({ apiResponse, _isVertexAI }) {
        const operation = new _UploadToFileSearchStoreOperation();
        const op = apiResponse;
        const response = uploadToFileSearchStoreOperationFromMldev(op);
        Object.assign(operation, response);
        return operation;
      }
    };
    (function(PagedItem2) {
      PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
      PagedItem2["PAGED_ITEM_MODELS"] = "models";
      PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
      PagedItem2["PAGED_ITEM_FILES"] = "files";
      PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
      PagedItem2["PAGED_ITEM_FILE_SEARCH_STORES"] = "fileSearchStores";
      PagedItem2["PAGED_ITEM_DOCUMENTS"] = "documents";
    })(PagedItem || (PagedItem = {}));
    Pager = class {
      constructor(name, request, response, params) {
        this.pageInternal = [];
        this.paramsInternal = {};
        this.requestInternal = request;
        this.init(name, response, params);
      }
      init(name, response, params) {
        var _a2, _b;
        this.nameInternal = name;
        this.pageInternal = response[this.nameInternal] || [];
        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;
        this.idxInternal = 0;
        let requestParams = { config: {} };
        if (!params || Object.keys(params).length === 0) {
          requestParams = { config: {} };
        } else if (typeof params === "object") {
          requestParams = Object.assign({}, params);
        } else {
          requestParams = params;
        }
        if (requestParams["config"]) {
          requestParams["config"]["pageToken"] = response["nextPageToken"];
        }
        this.paramsInternal = requestParams;
        this.pageInternalSize = (_b = (_a2 = requestParams["config"]) === null || _a2 === void 0 ? void 0 : _a2["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
      }
      initNextPage(response) {
        this.init(this.nameInternal, response, this.paramsInternal);
      }
      /**
       * Returns the current page, which is a list of items.
       *
       * @remarks
       * The first page is retrieved when the pager is created. The returned list of
       * items could be a subset of the entire list.
       */
      get page() {
        return this.pageInternal;
      }
      /**
       * Returns the type of paged item (for example, ``batch_jobs``).
       */
      get name() {
        return this.nameInternal;
      }
      /**
       * Returns the length of the page fetched each time by this pager.
       *
       * @remarks
       * The number of items in the page is less than or equal to the page length.
       */
      get pageSize() {
        return this.pageInternalSize;
      }
      /**
       * Returns the headers of the API response.
       */
      get sdkHttpResponse() {
        return this.sdkHttpResponseInternal;
      }
      /**
       * Returns the parameters when making the API request for the next page.
       *
       * @remarks
       * Parameters contain a set of optional configs that can be
       * used to customize the API request. For example, the `pageToken` parameter
       * contains the token to request the next page.
       */
      get params() {
        return this.paramsInternal;
      }
      /**
       * Returns the total number of items in the current page.
       */
      get pageLength() {
        return this.pageInternal.length;
      }
      /**
       * Returns the item at the given index.
       */
      getItem(index) {
        return this.pageInternal[index];
      }
      /**
       * Returns an async iterator that support iterating through all items
       * retrieved from the API.
       *
       * @remarks
       * The iterator will automatically fetch the next page if there are more items
       * to fetch from the API.
       *
       * @example
       *
       * ```ts
       * const pager = await ai.files.list({config: {pageSize: 10}});
       * for await (const file of pager) {
       *   console.log(file.name);
       * }
       * ```
       */
      [Symbol.asyncIterator]() {
        return {
          next: async () => {
            if (this.idxInternal >= this.pageLength) {
              if (this.hasNextPage()) {
                await this.nextPage();
              } else {
                return { value: void 0, done: true };
              }
            }
            const item = this.getItem(this.idxInternal);
            this.idxInternal += 1;
            return { value: item, done: false };
          },
          return: async () => {
            return { value: void 0, done: true };
          }
        };
      }
      /**
       * Fetches the next page of items. This makes a new API request.
       *
       * @throws {Error} If there are no more pages to fetch.
       *
       * @example
       *
       * ```ts
       * const pager = await ai.files.list({config: {pageSize: 10}});
       * let page = pager.page;
       * while (true) {
       *   for (const file of page) {
       *     console.log(file.name);
       *   }
       *   if (!pager.hasNextPage()) {
       *     break;
       *   }
       *   page = await pager.nextPage();
       * }
       * ```
       */
      async nextPage() {
        if (!this.hasNextPage()) {
          throw new Error("No more pages to fetch.");
        }
        const response = await this.requestInternal(this.params);
        this.initNextPage(response);
        return this.page;
      }
      /**
       * Returns true if there are more pages to fetch from the API.
       */
      hasNextPage() {
        var _a2;
        if (((_a2 = this.params["config"]) === null || _a2 === void 0 ? void 0 : _a2["pageToken"]) !== void 0) {
          return true;
        }
        return false;
      }
    };
    Batches = class extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = async (params = {}) => {
          return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);
        };
        this.create = async (params) => {
          if (this.apiClient.isVertexAI()) {
            params.config = this.formatDestination(params.src, params.config);
          }
          return this.createInternal(params);
        };
        this.createEmbeddings = async (params) => {
          console.warn("batches.createEmbeddings() is experimental and may change without notice.");
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support batches.createEmbeddings.");
          }
          return this.createEmbeddingsInternal(params);
        };
      }
      // Helper function to handle inlined generate content requests
      createInlinedGenerateContentRequest(params) {
        const body = createBatchJobParametersToMldev(
          this.apiClient,
          // Use instance apiClient
          params
        );
        const urlParams = body["_url"];
        const path5 = formatMap("{model}:batchGenerateContent", urlParams);
        const batch = body["batch"];
        const inputConfig = batch["inputConfig"];
        const requestsWrapper = inputConfig["requests"];
        const requests = requestsWrapper["requests"];
        const newRequests = [];
        for (const request of requests) {
          const requestDict = Object.assign({}, request);
          if (requestDict["systemInstruction"]) {
            const systemInstructionValue = requestDict["systemInstruction"];
            delete requestDict["systemInstruction"];
            const requestContent = requestDict["request"];
            requestContent["systemInstruction"] = systemInstructionValue;
            requestDict["request"] = requestContent;
          }
          newRequests.push(requestDict);
        }
        requestsWrapper["requests"] = newRequests;
        delete body["config"];
        delete body["_url"];
        delete body["_query"];
        return { path: path5, body };
      }
      // Helper function to get the first GCS URI
      getGcsUri(src) {
        if (typeof src === "string") {
          return src.startsWith("gs://") ? src : void 0;
        }
        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {
          return src.gcsUri[0];
        }
        return void 0;
      }
      // Helper function to get the BigQuery URI
      getBigqueryUri(src) {
        if (typeof src === "string") {
          return src.startsWith("bq://") ? src : void 0;
        }
        if (!Array.isArray(src)) {
          return src.bigqueryUri;
        }
        return void 0;
      }
      // Function to format the destination configuration for Vertex AI
      formatDestination(src, config) {
        const newConfig = config ? Object.assign({}, config) : {};
        const timestampStr = Date.now().toString();
        if (!newConfig.displayName) {
          newConfig.displayName = `genaiBatchJob_${timestampStr}`;
        }
        if (newConfig.dest === void 0) {
          const gcsUri = this.getGcsUri(src);
          const bigqueryUri = this.getBigqueryUri(src);
          if (gcsUri) {
            if (gcsUri.endsWith(".jsonl")) {
              newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;
            } else {
              newConfig.dest = `${gcsUri}_dest_${timestampStr}`;
            }
          } else if (bigqueryUri) {
            newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;
          } else {
            throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
          }
        }
        return newConfig;
      }
      /**
       * Internal method to create batch job.
       *
       * @param params - The parameters for create batch job request.
       * @return The created batch job.
       *
       */
      async createInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = createBatchJobParametersToVertex(this.apiClient, params);
          path5 = formatMap("batchPredictionJobs", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = batchJobFromVertex(apiResponse);
            return resp;
          });
        } else {
          const body = createBatchJobParametersToMldev(this.apiClient, params);
          path5 = formatMap("{model}:batchGenerateContent", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = batchJobFromMldev(apiResponse);
            return resp;
          });
        }
      }
      /**
       * Internal method to create batch job.
       *
       * @param params - The parameters for create batch job request.
       * @return The created batch job.
       *
       */
      async createEmbeddingsInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);
          path5 = formatMap("{model}:asyncBatchEmbedContent", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = batchJobFromMldev(apiResponse);
            return resp;
          });
        }
      }
      /**
       * Gets batch job configurations.
       *
       * @param params - The parameters for the get request.
       * @return The batch job.
       *
       * @example
       * ```ts
       * await ai.batches.get({name: '...'}); // The server-generated resource name.
       * ```
       */
      async get(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = getBatchJobParametersToVertex(this.apiClient, params);
          path5 = formatMap("batchPredictionJobs/{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = batchJobFromVertex(apiResponse);
            return resp;
          });
        } else {
          const body = getBatchJobParametersToMldev(this.apiClient, params);
          path5 = formatMap("batches/{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = batchJobFromMldev(apiResponse);
            return resp;
          });
        }
      }
      /**
       * Cancels a batch job.
       *
       * @param params - The parameters for the cancel request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
       * ```
       */
      async cancel(params) {
        var _a2, _b, _c, _d;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = cancelBatchJobParametersToVertex(this.apiClient, params);
          path5 = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          await this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          });
        } else {
          const body = cancelBatchJobParametersToMldev(this.apiClient, params);
          path5 = formatMap("batches/{name}:cancel", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          await this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          });
        }
      }
      async listInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = listBatchJobsParametersToVertex(params);
          path5 = formatMap("batchPredictionJobs", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = listBatchJobsResponseFromVertex(apiResponse);
            const typedResp = new ListBatchJobsResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = listBatchJobsParametersToMldev(params);
          path5 = formatMap("batches", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = listBatchJobsResponseFromMldev(apiResponse);
            const typedResp = new ListBatchJobsResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Deletes a batch job.
       *
       * @param params - The parameters for the delete request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.batches.delete({name: '...'}); // The server-generated resource name.
       * ```
       */
      async delete(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = deleteBatchJobParametersToVertex(this.apiClient, params);
          path5 = formatMap("batchPredictionJobs/{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "DELETE",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = deleteResourceJobFromVertex(apiResponse);
            return resp;
          });
        } else {
          const body = deleteBatchJobParametersToMldev(this.apiClient, params);
          path5 = formatMap("batches/{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "DELETE",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = deleteResourceJobFromMldev(apiResponse);
            return resp;
          });
        }
      }
    };
    Caches = class extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = async (params = {}) => {
          return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);
        };
      }
      /**
       * Creates a cached contents resource.
       *
       * @remarks
       * Context caching is only supported for specific models. See [Gemini
       * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
       * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
       * for more information.
       *
       * @param params - The parameters for the create request.
       * @return The created cached content.
       *
       * @example
       * ```ts
       * const contents = ...; // Initialize the content to cache.
       * const response = await ai.caches.create({
       *   model: 'gemini-2.0-flash-001',
       *   config: {
       *    'contents': contents,
       *    'displayName': 'test cache',
       *    'systemInstruction': 'What is the sum of the two pdfs?',
       *    'ttl': '86400s',
       *  }
       * });
       * ```
       */
      async create(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = createCachedContentParametersToVertex(this.apiClient, params);
          path5 = formatMap("cachedContents", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        } else {
          const body = createCachedContentParametersToMldev(this.apiClient, params);
          path5 = formatMap("cachedContents", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        }
      }
      /**
       * Gets cached content configurations.
       *
       * @param params - The parameters for the get request.
       * @return The cached content.
       *
       * @example
       * ```ts
       * await ai.caches.get({name: '...'}); // The server-generated resource name.
       * ```
       */
      async get(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = getCachedContentParametersToVertex(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        } else {
          const body = getCachedContentParametersToMldev(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        }
      }
      /**
       * Deletes cached content.
       *
       * @param params - The parameters for the delete request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.caches.delete({name: '...'}); // The server-generated resource name.
       * ```
       */
      async delete(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = deleteCachedContentParametersToVertex(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "DELETE",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = deleteCachedContentResponseFromVertex(apiResponse);
            const typedResp = new DeleteCachedContentResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = deleteCachedContentParametersToMldev(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "DELETE",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = deleteCachedContentResponseFromMldev(apiResponse);
            const typedResp = new DeleteCachedContentResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Updates cached content configurations.
       *
       * @param params - The parameters for the update request.
       * @return The updated cached content.
       *
       * @example
       * ```ts
       * const response = await ai.caches.update({
       *   name: '...',  // The server-generated resource name.
       *   config: {'ttl': '7600s'}
       * });
       * ```
       */
      async update(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = updateCachedContentParametersToVertex(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "PATCH",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        } else {
          const body = updateCachedContentParametersToMldev(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "PATCH",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        }
      }
      async listInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = listCachedContentsParametersToVertex(params);
          path5 = formatMap("cachedContents", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = listCachedContentsResponseFromVertex(apiResponse);
            const typedResp = new ListCachedContentsResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = listCachedContentsParametersToMldev(params);
          path5 = formatMap("cachedContents", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = listCachedContentsResponseFromMldev(apiResponse);
            const typedResp = new ListCachedContentsResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
    };
    Chats = class {
      constructor(modelsModule, apiClient) {
        this.modelsModule = modelsModule;
        this.apiClient = apiClient;
      }
      /**
       * Creates a new chat session.
       *
       * @remarks
       * The config in the params will be used for all requests within the chat
       * session unless overridden by a per-request `config` in
       * @see {@link types.SendMessageParameters#config}.
       *
       * @param params - Parameters for creating a chat session.
       * @returns A new chat session.
       *
       * @example
       * ```ts
       * const chat = ai.chats.create({
       *   model: 'gemini-2.0-flash'
       *   config: {
       *     temperature: 0.5,
       *     maxOutputTokens: 1024,
       *   }
       * });
       * ```
       */
      create(params) {
        return new Chat(
          this.apiClient,
          this.modelsModule,
          params.model,
          params.config,
          // Deep copy the history to avoid mutating the history outside of the
          // chat session.
          structuredClone(params.history)
        );
      }
    };
    Chat = class {
      constructor(apiClient, modelsModule, model, config = {}, history = []) {
        this.apiClient = apiClient;
        this.modelsModule = modelsModule;
        this.model = model;
        this.config = config;
        this.history = history;
        this.sendPromise = Promise.resolve();
        validateHistory(history);
      }
      /**
       * Sends a message to the model and returns the response.
       *
       * @remarks
       * This method will wait for the previous message to be processed before
       * sending the next message.
       *
       * @see {@link Chat#sendMessageStream} for streaming method.
       * @param params - parameters for sending messages within a chat session.
       * @returns The model's response.
       *
       * @example
       * ```ts
       * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
       * const response = await chat.sendMessage({
       *   message: 'Why is the sky blue?'
       * });
       * console.log(response.text);
       * ```
       */
      async sendMessage(params) {
        var _a2;
        await this.sendPromise;
        const inputContent = tContent(params.message);
        const responsePromise = this.modelsModule.generateContent({
          model: this.model,
          contents: this.getHistory(true).concat(inputContent),
          config: (_a2 = params.config) !== null && _a2 !== void 0 ? _a2 : this.config
        });
        this.sendPromise = (async () => {
          var _a3, _b, _c;
          const response = await responsePromise;
          const outputContent = (_b = (_a3 = response.candidates) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.content;
          const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
          const index = this.getHistory(true).length;
          let automaticFunctionCallingHistory = [];
          if (fullAutomaticFunctionCallingHistory != null) {
            automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
          }
          const modelOutput = outputContent ? [outputContent] : [];
          this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
          return;
        })();
        await this.sendPromise.catch(() => {
          this.sendPromise = Promise.resolve();
        });
        return responsePromise;
      }
      /**
       * Sends a message to the model and returns the response in chunks.
       *
       * @remarks
       * This method will wait for the previous message to be processed before
       * sending the next message.
       *
       * @see {@link Chat#sendMessage} for non-streaming method.
       * @param params - parameters for sending the message.
       * @return The model's response.
       *
       * @example
       * ```ts
       * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
       * const response = await chat.sendMessageStream({
       *   message: 'Why is the sky blue?'
       * });
       * for await (const chunk of response) {
       *   console.log(chunk.text);
       * }
       * ```
       */
      async sendMessageStream(params) {
        var _a2;
        await this.sendPromise;
        const inputContent = tContent(params.message);
        const streamResponse = this.modelsModule.generateContentStream({
          model: this.model,
          contents: this.getHistory(true).concat(inputContent),
          config: (_a2 = params.config) !== null && _a2 !== void 0 ? _a2 : this.config
        });
        this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
        const response = await streamResponse;
        const result = this.processStreamResponse(response, inputContent);
        return result;
      }
      /**
       * Returns the chat history.
       *
       * @remarks
       * The history is a list of contents alternating between user and model.
       *
       * There are two types of history:
       * - The `curated history` contains only the valid turns between user and
       * model, which will be included in the subsequent requests sent to the model.
       * - The `comprehensive history` contains all turns, including invalid or
       *   empty model outputs, providing a complete record of the history.
       *
       * The history is updated after receiving the response from the model,
       * for streaming response, it means receiving the last chunk of the response.
       *
       * The `comprehensive history` is returned by default. To get the `curated
       * history`, set the `curated` parameter to `true`.
       *
       * @param curated - whether to return the curated history or the comprehensive
       *     history.
       * @return History contents alternating between user and model for the entire
       *     chat session.
       */
      getHistory(curated = false) {
        const history = curated ? extractCuratedHistory(this.history) : this.history;
        return structuredClone(history);
      }
      processStreamResponse(streamResponse, inputContent) {
        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
          var _a2, e_1, _b, _c;
          var _d, _e;
          const outputContent = [];
          try {
            for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _a2 = streamResponse_1_1.done, !_a2; _f = true) {
              _c = streamResponse_1_1.value;
              _f = false;
              const chunk = _c;
              if (isValidResponse(chunk)) {
                const content = (_e = (_d = chunk.candidates) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.content;
                if (content !== void 0) {
                  outputContent.push(content);
                }
              }
              yield yield __await(chunk);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_f && !_a2 && (_b = streamResponse_1.return))
                yield __await(_b.call(streamResponse_1));
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          this.recordHistory(inputContent, outputContent);
        });
      }
      recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
        let outputContents = [];
        if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) {
          outputContents = modelOutput;
        } else {
          outputContents.push({
            role: "model",
            parts: []
          });
        }
        if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
          this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
        } else {
          this.history.push(userInput);
        }
        this.history.push(...outputContents);
      }
    };
    ApiError = class _ApiError extends Error {
      constructor(options) {
        super(options.message);
        this.name = "ApiError";
        this.status = options.status;
        Object.setPrototypeOf(this, _ApiError.prototype);
      }
    };
    Files = class extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = async (params = {}) => {
          return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);
        };
      }
      /**
       * Uploads a file asynchronously to the Gemini API.
       * This method is not available in Vertex AI.
       * Supported upload sources:
       * - Node.js: File path (string) or Blob object.
       * - Browser: Blob object (e.g., File).
       *
       * @remarks
       * The `mimeType` can be specified in the `config` parameter. If omitted:
       *  - For file path (string) inputs, the `mimeType` will be inferred from the
       *     file extension.
       *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
       *     property.
       * Somex eamples for file extension to mimeType mapping:
       * .txt -> text/plain
       * .json -> application/json
       * .jpg  -> image/jpeg
       * .png -> image/png
       * .mp3 -> audio/mpeg
       * .mp4 -> video/mp4
       *
       * This section can contain multiple paragraphs and code examples.
       *
       * @param params - Optional parameters specified in the
       *        `types.UploadFileParameters` interface.
       *         @see {@link types.UploadFileParameters#config} for the optional
       *         config in the parameters.
       * @return A promise that resolves to a `types.File` object.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       * the `mimeType` can be provided in the `params.config` parameter.
       * @throws An error occurs if a suitable upload location cannot be established.
       *
       * @example
       * The following code uploads a file to Gemini API.
       *
       * ```ts
       * const file = await ai.files.upload({file: 'file.txt', config: {
       *   mimeType: 'text/plain',
       * }});
       * console.log(file.name);
       * ```
       */
      async upload(params) {
        if (this.apiClient.isVertexAI()) {
          throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
        }
        return this.apiClient.uploadFile(params.file, params.config).then((resp) => {
          return resp;
        });
      }
      /**
       * Downloads a remotely stored file asynchronously to a location specified in
       * the `params` object. This method only works on Node environment, to
       * download files in the browser, use a browser compliant method like an <a>
       * tag.
       *
       * @param params - The parameters for the download request.
       *
       * @example
       * The following code downloads an example file named "files/mehozpxf877d" as
       * "file.txt".
       *
       * ```ts
       * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
       * ```
       */
      async download(params) {
        await this.apiClient.downloadFile(params);
      }
      /**
       * Registers Google Cloud Storage files for use with the API.
       * This method is only available in Node.js environments.
       */
      async registerFiles(params) {
        throw new Error("registerFiles is only supported in Node.js environments.");
      }
      async _registerFiles(params) {
        return this.registerFilesInternal(params);
      }
      async listInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = listFilesParametersToMldev(params);
          path5 = formatMap("files", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = listFilesResponseFromMldev(apiResponse);
            const typedResp = new ListFilesResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      async createInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = createFileParametersToMldev(params);
          path5 = formatMap("upload/v1beta/files", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = createFileResponseFromMldev(apiResponse);
            const typedResp = new CreateFileResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Retrieves the file information from the service.
       *
       * @param params - The parameters for the get request
       * @return The Promise that resolves to the types.File object requested.
       *
       * @example
       * ```ts
       * const config: GetFileParameters = {
       *   name: fileName,
       * };
       * file = await ai.files.get(config);
       * console.log(file.name);
       * ```
       */
      async get(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = getFileParametersToMldev(params);
          path5 = formatMap("files/{file}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        }
      }
      /**
       * Deletes a remotely stored file.
       *
       * @param params - The parameters for the delete request.
       * @return The DeleteFileResponse, the response for the delete method.
       *
       * @example
       * The following code deletes an example file named "files/mehozpxf877d".
       *
       * ```ts
       * await ai.files.delete({name: file.name});
       * ```
       */
      async delete(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = deleteFileParametersToMldev(params);
          path5 = formatMap("files/{file}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "DELETE",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = deleteFileResponseFromMldev(apiResponse);
            const typedResp = new DeleteFileResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      async registerFilesInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = internalRegisterFilesParametersToMldev(params);
          path5 = formatMap("files:register", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = registerFilesResponseFromMldev(apiResponse);
            const typedResp = new RegisterFilesResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
    };
    CONTENT_TYPE_HEADER = "Content-Type";
    SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
    USER_AGENT_HEADER = "User-Agent";
    GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
    SDK_VERSION = "1.39.0";
    LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
    VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
    GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
    ApiClient = class {
      constructor(opts) {
        var _a2, _b, _c;
        this.clientOptions = Object.assign({}, opts);
        this.customBaseUrl = (_a2 = opts.httpOptions) === null || _a2 === void 0 ? void 0 : _a2.baseUrl;
        if (this.clientOptions.vertexai) {
          if (this.clientOptions.project && this.clientOptions.location) {
            this.clientOptions.apiKey = void 0;
          } else if (this.clientOptions.apiKey) {
            this.clientOptions.project = void 0;
            this.clientOptions.location = void 0;
          }
        }
        const initHttpOptions = {};
        if (this.clientOptions.vertexai) {
          if (!this.clientOptions.location && !this.clientOptions.apiKey && !this.customBaseUrl) {
            this.clientOptions.location = "global";
          }
          const hasSufficientAuth = this.clientOptions.project && this.clientOptions.location || this.clientOptions.apiKey;
          if (!hasSufficientAuth && !this.customBaseUrl) {
            throw new Error("Authentication is not set up. Please provide either a project and location, or an API key, or a custom base URL.");
          }
          const hasConstructorAuth = opts.project && opts.location || !!opts.apiKey;
          if (this.customBaseUrl && !hasConstructorAuth) {
            initHttpOptions.baseUrl = this.customBaseUrl;
            this.clientOptions.project = void 0;
            this.clientOptions.location = void 0;
          } else if (this.clientOptions.apiKey || this.clientOptions.location === "global") {
            initHttpOptions.baseUrl = "https://aiplatform.googleapis.com/";
          } else if (this.clientOptions.project && this.clientOptions.location) {
            initHttpOptions.baseUrl = `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
          }
          initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : VERTEX_AI_API_DEFAULT_VERSION;
        } else {
          if (!this.clientOptions.apiKey) {
            throw new ApiError({
              message: "API key must be set when using the Gemini API.",
              status: 403
            });
          }
          initHttpOptions.apiVersion = (_c = this.clientOptions.apiVersion) !== null && _c !== void 0 ? _c : GOOGLE_AI_API_DEFAULT_VERSION;
          initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
        }
        initHttpOptions.headers = this.getDefaultHeaders();
        this.clientOptions.httpOptions = initHttpOptions;
        if (opts.httpOptions) {
          this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
        }
      }
      isVertexAI() {
        var _a2;
        return (_a2 = this.clientOptions.vertexai) !== null && _a2 !== void 0 ? _a2 : false;
      }
      getProject() {
        return this.clientOptions.project;
      }
      getLocation() {
        return this.clientOptions.location;
      }
      getCustomBaseUrl() {
        return this.customBaseUrl;
      }
      async getAuthHeaders() {
        const headers = new Headers();
        await this.clientOptions.auth.addAuthHeaders(headers);
        return headers;
      }
      getApiVersion() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) {
          return this.clientOptions.httpOptions.apiVersion;
        }
        throw new Error("API version is not set.");
      }
      getBaseUrl() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) {
          return this.clientOptions.httpOptions.baseUrl;
        }
        throw new Error("Base URL is not set.");
      }
      getRequestUrl() {
        return this.getRequestUrlInternal(this.clientOptions.httpOptions);
      }
      getHeaders() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) {
          return this.clientOptions.httpOptions.headers;
        } else {
          throw new Error("Headers are not set.");
        }
      }
      getRequestUrlInternal(httpOptions) {
        if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) {
          throw new Error("HTTP options are not correctly set.");
        }
        const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
        const urlElement = [baseUrl];
        if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
          urlElement.push(httpOptions.apiVersion);
        }
        return urlElement.join("/");
      }
      getBaseResourcePath() {
        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
      }
      getApiKey() {
        return this.clientOptions.apiKey;
      }
      getWebsocketBaseUrl() {
        const baseUrl = this.getBaseUrl();
        const urlParts = new URL(baseUrl);
        urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
        return urlParts.toString();
      }
      setBaseUrl(url) {
        if (this.clientOptions.httpOptions) {
          this.clientOptions.httpOptions.baseUrl = url;
        } else {
          throw new Error("HTTP options are not correctly set.");
        }
      }
      constructUrl(path5, httpOptions, prependProjectLocation) {
        const urlElement = [this.getRequestUrlInternal(httpOptions)];
        if (prependProjectLocation) {
          urlElement.push(this.getBaseResourcePath());
        }
        if (path5 !== "") {
          urlElement.push(path5);
        }
        const url = new URL(`${urlElement.join("/")}`);
        return url;
      }
      shouldPrependVertexProjectPath(request, httpOptions) {
        if (httpOptions.baseUrl && httpOptions.baseUrlResourceScope === ResourceScope.COLLECTION) {
          return false;
        }
        if (this.clientOptions.apiKey) {
          return false;
        }
        if (!this.clientOptions.vertexai) {
          return false;
        }
        if (request.path.startsWith("projects/")) {
          return false;
        }
        if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
          return false;
        }
        return true;
      }
      async request(request) {
        let patchedHttpOptions = this.clientOptions.httpOptions;
        if (request.httpOptions) {
          patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
        }
        const prependProjectLocation = this.shouldPrependVertexProjectPath(request, patchedHttpOptions);
        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
        if (request.queryParams) {
          for (const [key, value] of Object.entries(request.queryParams)) {
            url.searchParams.append(key, String(value));
          }
        }
        let requestInit = {};
        if (request.httpMethod === "GET") {
          if (request.body && request.body !== "{}") {
            throw new Error("Request body should be empty for GET request, but got non empty request body");
          }
        } else {
          requestInit.body = request.body;
        }
        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
        return this.unaryApiCall(url, requestInit, request.httpMethod);
      }
      patchHttpOptions(baseHttpOptions, requestHttpOptions) {
        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
        for (const [key, value] of Object.entries(requestHttpOptions)) {
          if (typeof value === "object") {
            patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
          } else if (value !== void 0) {
            patchedHttpOptions[key] = value;
          }
        }
        return patchedHttpOptions;
      }
      async requestStream(request) {
        let patchedHttpOptions = this.clientOptions.httpOptions;
        if (request.httpOptions) {
          patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
        }
        const prependProjectLocation = this.shouldPrependVertexProjectPath(request, patchedHttpOptions);
        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
        if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
          url.searchParams.set("alt", "sse");
        }
        let requestInit = {};
        requestInit.body = request.body;
        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
        return this.streamApiCall(url, requestInit, request.httpMethod);
      }
      async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {
        if (httpOptions && httpOptions.timeout || abortSignal) {
          const abortController = new AbortController();
          const signal = abortController.signal;
          if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
            const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
            if (timeoutHandle && typeof timeoutHandle.unref === "function") {
              timeoutHandle.unref();
            }
          }
          if (abortSignal) {
            abortSignal.addEventListener("abort", () => {
              abortController.abort();
            });
          }
          requestInit.signal = signal;
        }
        if (httpOptions && httpOptions.extraBody !== null) {
          includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
        }
        requestInit.headers = await this.getHeadersInternal(httpOptions, url);
        return requestInit;
      }
      async unaryApiCall(url, requestInit, httpMethod) {
        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
          await throwErrorIfNotOK(response);
          return new HttpResponse(response);
        }).catch((e) => {
          if (e instanceof Error) {
            throw e;
          } else {
            throw new Error(JSON.stringify(e));
          }
        });
      }
      async streamApiCall(url, requestInit, httpMethod) {
        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
          await throwErrorIfNotOK(response);
          return this.processStreamResponse(response);
        }).catch((e) => {
          if (e instanceof Error) {
            throw e;
          } else {
            throw new Error(JSON.stringify(e));
          }
        });
      }
      processStreamResponse(response) {
        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
          var _a2;
          const reader = (_a2 = response === null || response === void 0 ? void 0 : response.body) === null || _a2 === void 0 ? void 0 : _a2.getReader();
          const decoder = new TextDecoder("utf-8");
          if (!reader) {
            throw new Error("Response body is empty");
          }
          try {
            let buffer = "";
            const dataPrefix = "data:";
            const delimiters = ["\n\n", "\r\r", "\r\n\r\n"];
            while (true) {
              const { done, value } = yield __await(reader.read());
              if (done) {
                if (buffer.trim().length > 0) {
                  throw new Error("Incomplete JSON segment at the end");
                }
                break;
              }
              const chunkString = decoder.decode(value, { stream: true });
              try {
                const chunkJson = JSON.parse(chunkString);
                if ("error" in chunkJson) {
                  const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
                  const status = errorJson["status"];
                  const code = errorJson["code"];
                  const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
                  if (code >= 400 && code < 600) {
                    const apiError = new ApiError({
                      message: errorMessage,
                      status: code
                    });
                    throw apiError;
                  }
                }
              } catch (e) {
                const error = e;
                if (error.name === "ApiError") {
                  throw e;
                }
              }
              buffer += chunkString;
              let delimiterIndex = -1;
              let delimiterLength = 0;
              while (true) {
                delimiterIndex = -1;
                delimiterLength = 0;
                for (const delimiter of delimiters) {
                  const index = buffer.indexOf(delimiter);
                  if (index !== -1 && (delimiterIndex === -1 || index < delimiterIndex)) {
                    delimiterIndex = index;
                    delimiterLength = delimiter.length;
                  }
                }
                if (delimiterIndex === -1) {
                  break;
                }
                const eventString = buffer.substring(0, delimiterIndex);
                buffer = buffer.substring(delimiterIndex + delimiterLength);
                const trimmedEvent = eventString.trim();
                if (trimmedEvent.startsWith(dataPrefix)) {
                  const processedChunkString = trimmedEvent.substring(dataPrefix.length).trim();
                  try {
                    const partialResponse = new Response(processedChunkString, {
                      headers: response === null || response === void 0 ? void 0 : response.headers,
                      status: response === null || response === void 0 ? void 0 : response.status,
                      statusText: response === null || response === void 0 ? void 0 : response.statusText
                    });
                    yield yield __await(new HttpResponse(partialResponse));
                  } catch (e) {
                    throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);
                  }
                }
              }
            }
          } finally {
            reader.releaseLock();
          }
        });
      }
      async apiCall(url, requestInit) {
        return fetch(url, requestInit).catch((e) => {
          throw new Error(`exception ${e} sending request`);
        });
      }
      getDefaultHeaders() {
        const headers = {};
        const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
        headers[USER_AGENT_HEADER] = versionHeaderValue;
        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
        headers[CONTENT_TYPE_HEADER] = "application/json";
        return headers;
      }
      async getHeadersInternal(httpOptions, url) {
        const headers = new Headers();
        if (httpOptions && httpOptions.headers) {
          for (const [key, value] of Object.entries(httpOptions.headers)) {
            headers.append(key, value);
          }
          if (httpOptions.timeout && httpOptions.timeout > 0) {
            headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
          }
        }
        await this.clientOptions.auth.addAuthHeaders(headers, url);
        return headers;
      }
      getFileName(file) {
        var _a2;
        let fileName = "";
        if (typeof file === "string") {
          fileName = file.replace(/[/\\]+$/, "");
          fileName = (_a2 = fileName.split(/[/\\]/).pop()) !== null && _a2 !== void 0 ? _a2 : "";
        }
        return fileName;
      }
      /**
       * Uploads a file asynchronously using Gemini API only, this is not supported
       * in Vertex AI.
       *
       * @param file The string path to the file to be uploaded or a Blob object.
       * @param config Optional parameters specified in the `UploadFileConfig`
       *     interface. @see {@link types.UploadFileConfig}
       * @return A promise that resolves to a `File` object.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       */
      async uploadFile(file, config) {
        var _a2;
        const fileToUpload = {};
        if (config != null) {
          fileToUpload.mimeType = config.mimeType;
          fileToUpload.name = config.name;
          fileToUpload.displayName = config.displayName;
        }
        if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
          fileToUpload.name = `files/${fileToUpload.name}`;
        }
        const uploader = this.clientOptions.uploader;
        const fileStat = await uploader.stat(file);
        fileToUpload.sizeBytes = String(fileStat.size);
        const mimeType = (_a2 = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a2 !== void 0 ? _a2 : fileStat.type;
        if (mimeType === void 0 || mimeType === "") {
          throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
        }
        fileToUpload.mimeType = mimeType;
        const body = {
          file: fileToUpload
        };
        const fileName = this.getFileName(file);
        const path5 = formatMap("upload/v1beta/files", body["_url"]);
        const uploadUrl = await this.fetchUploadUrl(path5, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
        return uploader.upload(file, uploadUrl, this);
      }
      /**
       * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported
       * in Vertex AI.
       *
       * @param fileSearchStoreName The name of the file search store to upload the file to.
       * @param file The string path to the file to be uploaded or a Blob object.
       * @param config Optional parameters specified in the `UploadFileConfig`
       *     interface. @see {@link UploadFileConfig}
       * @return A promise that resolves to a `File` object.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       */
      async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {
        var _a2;
        const uploader = this.clientOptions.uploader;
        const fileStat = await uploader.stat(file);
        const sizeBytes = String(fileStat.size);
        const mimeType = (_a2 = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a2 !== void 0 ? _a2 : fileStat.type;
        if (mimeType === void 0 || mimeType === "") {
          throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
        }
        const path5 = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;
        const fileName = this.getFileName(file);
        const body = {};
        if (config != null) {
          uploadToFileSearchStoreConfigToMldev(config, body);
        }
        const uploadUrl = await this.fetchUploadUrl(path5, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
        return uploader.uploadToFileSearchStore(file, uploadUrl, this);
      }
      /**
       * Downloads a file asynchronously to the specified path.
       *
       * @params params - The parameters for the download request, see {@link
       * types.DownloadFileParameters}
       */
      async downloadFile(params) {
        const downloader = this.clientOptions.downloader;
        await downloader.download(params, this);
      }
      async fetchUploadUrl(path5, sizeBytes, mimeType, fileName, body, configHttpOptions) {
        var _a2;
        let httpOptions = {};
        if (configHttpOptions) {
          httpOptions = configHttpOptions;
        } else {
          httpOptions = {
            apiVersion: "",
            // api-version is set in the path.
            headers: Object.assign({ "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${sizeBytes}`, "X-Goog-Upload-Header-Content-Type": `${mimeType}` }, fileName ? { "X-Goog-Upload-File-Name": fileName } : {})
          };
        }
        const httpResponse = await this.request({
          path: path5,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions
        });
        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {
          throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
        }
        const uploadUrl = (_a2 = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a2 === void 0 ? void 0 : _a2["x-goog-upload-url"];
        if (uploadUrl === void 0) {
          throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
        }
        return uploadUrl;
      }
    };
    MCP_LABEL = "mcp_used/unknown";
    hasMcpToolUsageFromMcpToTool = false;
    McpCallableTool = class _McpCallableTool {
      constructor(mcpClients = [], config) {
        this.mcpTools = [];
        this.functionNameToMcpClient = {};
        this.mcpClients = mcpClients;
        this.config = config;
      }
      /**
       * Creates a McpCallableTool.
       */
      static create(mcpClients, config) {
        return new _McpCallableTool(mcpClients, config);
      }
      /**
       * Validates the function names are not duplicate and initialize the function
       * name to MCP client mapping.
       *
       * @throws {Error} if the MCP tools from the MCP clients have duplicate tool
       *     names.
       */
      async initialize() {
        var _a2, e_1, _b, _c;
        if (this.mcpTools.length > 0) {
          return;
        }
        const functionMap = {};
        const mcpTools = [];
        for (const mcpClient of this.mcpClients) {
          try {
            for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a2 = _f.done, !_a2; _d = true) {
              _c = _f.value;
              _d = false;
              const mcpTool = _c;
              mcpTools.push(mcpTool);
              const mcpToolName = mcpTool.name;
              if (functionMap[mcpToolName]) {
                throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
              }
              functionMap[mcpToolName] = mcpClient;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a2 && (_b = _e.return))
                await _b.call(_e);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        this.mcpTools = mcpTools;
        this.functionNameToMcpClient = functionMap;
      }
      async tool() {
        await this.initialize();
        return mcpToolsToGeminiTool(this.mcpTools, this.config);
      }
      async callTool(functionCalls) {
        await this.initialize();
        const functionCallResponseParts = [];
        for (const functionCall of functionCalls) {
          if (functionCall.name in this.functionNameToMcpClient) {
            const mcpClient = this.functionNameToMcpClient[functionCall.name];
            let requestOptions = void 0;
            if (this.config.timeout) {
              requestOptions = {
                timeout: this.config.timeout
              };
            }
            const callToolResponse = await mcpClient.callTool(
              {
                name: functionCall.name,
                arguments: functionCall.args
              },
              // Set the result schema to undefined to allow MCP to rely on the
              // default schema.
              void 0,
              requestOptions
            );
            functionCallResponseParts.push({
              functionResponse: {
                name: functionCall.name,
                response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
              }
            });
          }
        }
        return functionCallResponseParts;
      }
    };
    LiveMusic = class {
      constructor(apiClient, auth, webSocketFactory) {
        this.apiClient = apiClient;
        this.auth = auth;
        this.webSocketFactory = webSocketFactory;
      }
      /**
           Establishes a connection to the specified model and returns a
           LiveMusicSession object representing that connection.
      
           @experimental
      
           @remarks
      
           @param params - The parameters for establishing a connection to the model.
           @return A live session.
      
           @example
           ```ts
           let model = 'models/lyria-realtime-exp';
           const session = await ai.live.music.connect({
             model: model,
             callbacks: {
               onmessage: (e: MessageEvent) => {
                 console.log('Received message from the server: %s\n', debug(e.data));
               },
               onerror: (e: ErrorEvent) => {
                 console.log('Error occurred: %s\n', debug(e.error));
               },
               onclose: (e: CloseEvent) => {
                 console.log('Connection closed.');
               },
             },
           });
           ```
          */
      async connect(params) {
        var _a2, _b;
        if (this.apiClient.isVertexAI()) {
          throw new Error("Live music is not supported for Vertex AI.");
        }
        console.warn("Live music generation is experimental and may change in future versions.");
        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
        const apiVersion = this.apiClient.getApiVersion();
        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
        const apiKey = this.apiClient.getApiKey();
        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;
        let onopenResolve = () => {
        };
        const onopenPromise = new Promise((resolve) => {
          onopenResolve = resolve;
        });
        const callbacks = params.callbacks;
        const onopenAwaitedCallback = function() {
          onopenResolve({});
        };
        const apiClient = this.apiClient;
        const websocketCallbacks = {
          onopen: onopenAwaitedCallback,
          onmessage: (event) => {
            void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
          },
          onerror: (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a2 !== void 0 ? _a2 : function(e) {
          },
          onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
          }
        };
        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
        conn.connect();
        await onopenPromise;
        const model = tModel(this.apiClient, params.model);
        const setup = { model };
        const clientMessage = { setup };
        conn.send(JSON.stringify(clientMessage));
        return new LiveMusicSession(conn, this.apiClient);
      }
    };
    LiveMusicSession = class {
      constructor(conn, apiClient) {
        this.conn = conn;
        this.apiClient = apiClient;
      }
      /**
          Sets inputs to steer music generation. Updates the session's current
          weighted prompts.
      
          @param params - Contains one property, `weightedPrompts`.
      
            - `weightedPrompts` to send to the model; weights are normalized to
              sum to 1.0.
      
          @experimental
         */
      async setWeightedPrompts(params) {
        if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
          throw new Error("Weighted prompts must be set and contain at least one entry.");
        }
        const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);
        this.conn.send(JSON.stringify({ clientContent }));
      }
      /**
          Sets a configuration to the model. Updates the session's current
          music generation config.
      
          @param params - Contains one property, `musicGenerationConfig`.
      
            - `musicGenerationConfig` to set in the model. Passing an empty or
          undefined config to the model will reset the config to defaults.
      
          @experimental
         */
      async setMusicGenerationConfig(params) {
        if (!params.musicGenerationConfig) {
          params.musicGenerationConfig = {};
        }
        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
        this.conn.send(JSON.stringify(setConfigParameters));
      }
      sendPlaybackControl(playbackControl) {
        const clientMessage = { playbackControl };
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
       * Start the music stream.
       *
       * @experimental
       */
      play() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
      }
      /**
       * Temporarily halt the music stream. Use `play` to resume from the current
       * position.
       *
       * @experimental
       */
      pause() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
      }
      /**
       * Stop the music stream and reset the state. Retains the current prompts
       * and config.
       *
       * @experimental
       */
      stop() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
      }
      /**
       * Resets the context of the music generation without stopping it.
       * Retains the current prompts and config.
       *
       * @experimental
       */
      resetContext() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
      }
      /**
           Terminates the WebSocket connection.
      
           @experimental
         */
      close() {
        this.conn.close();
      }
    };
    FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
    Live = class {
      constructor(apiClient, auth, webSocketFactory) {
        this.apiClient = apiClient;
        this.auth = auth;
        this.webSocketFactory = webSocketFactory;
        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
      }
      /**
           Establishes a connection to the specified model with the given
           configuration and returns a Session object representing that connection.
      
           @experimental Built-in MCP support is an experimental feature, may change in
           future versions.
      
           @remarks
      
           @param params - The parameters for establishing a connection to the model.
           @return A live session.
      
           @example
           ```ts
           let model: string;
           if (GOOGLE_GENAI_USE_VERTEXAI) {
             model = 'gemini-2.0-flash-live-preview-04-09';
           } else {
             model = 'gemini-live-2.5-flash-preview';
           }
           const session = await ai.live.connect({
             model: model,
             config: {
               responseModalities: [Modality.AUDIO],
             },
             callbacks: {
               onopen: () => {
                 console.log('Connected to the socket.');
               },
               onmessage: (e: MessageEvent) => {
                 console.log('Received message from the server: %s\n', debug(e.data));
               },
               onerror: (e: ErrorEvent) => {
                 console.log('Error occurred: %s\n', debug(e.error));
               },
               onclose: (e: CloseEvent) => {
                 console.log('Connection closed.');
               },
             },
           });
           ```
          */
      async connect(params) {
        var _a2, _b, _c, _d, _e, _f;
        if (params.config && params.config.httpOptions) {
          throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
        }
        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
        const apiVersion = this.apiClient.getApiVersion();
        let url;
        const clientHeaders = this.apiClient.getHeaders();
        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
          setMcpUsageHeader(clientHeaders);
        }
        const headers = mapToHeaders(clientHeaders);
        if (this.apiClient.isVertexAI()) {
          const project = this.apiClient.getProject();
          const location = this.apiClient.getLocation();
          const apiKey = this.apiClient.getApiKey();
          const hasStandardAuth = !!project && !!location || !!apiKey;
          if (this.apiClient.getCustomBaseUrl() && !hasStandardAuth) {
            url = websocketBaseUrl;
          } else {
            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
            await this.auth.addAuthHeaders(headers, url);
          }
        } else {
          const apiKey = this.apiClient.getApiKey();
          let method = "BidiGenerateContent";
          let keyName = "key";
          if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith("auth_tokens/")) {
            console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
            if (apiVersion !== "v1alpha") {
              console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
            }
            method = "BidiGenerateContentConstrained";
            keyName = "access_token";
          }
          url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;
        }
        let onopenResolve = () => {
        };
        const onopenPromise = new Promise((resolve) => {
          onopenResolve = resolve;
        });
        const callbacks = params.callbacks;
        const onopenAwaitedCallback = function() {
          var _a3;
          (_a3 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a3 === void 0 ? void 0 : _a3.call(callbacks);
          onopenResolve({});
        };
        const apiClient = this.apiClient;
        const websocketCallbacks = {
          onopen: onopenAwaitedCallback,
          onmessage: (event) => {
            void handleWebSocketMessage(apiClient, callbacks.onmessage, event);
          },
          onerror: (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a2 !== void 0 ? _a2 : function(e) {
          },
          onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
          }
        };
        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
        conn.connect();
        await onopenPromise;
        let transformedModel = tModel(this.apiClient, params.model);
        if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
          const project = this.apiClient.getProject();
          const location = this.apiClient.getLocation();
          if (project && location) {
            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
          }
        }
        let clientMessage = {};
        if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) {
          if (params.config === void 0) {
            params.config = { responseModalities: [Modality.AUDIO] };
          } else {
            params.config.responseModalities = [Modality.AUDIO];
          }
        }
        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {
          console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
        }
        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];
        const convertedTools = [];
        for (const tool of inputTools) {
          if (this.isCallableTool(tool)) {
            const callableTool = tool;
            convertedTools.push(await callableTool.tool());
          } else {
            convertedTools.push(tool);
          }
        }
        if (convertedTools.length > 0) {
          params.config.tools = convertedTools;
        }
        const liveConnectParameters = {
          model: transformedModel,
          config: params.config,
          callbacks: params.callbacks
        };
        if (this.apiClient.isVertexAI()) {
          clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
        } else {
          clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
        }
        delete clientMessage["config"];
        conn.send(JSON.stringify(clientMessage));
        return new Session(conn, this.apiClient);
      }
      // TODO: b/416041229 - Abstract this method to a common place.
      isCallableTool(tool) {
        return "callTool" in tool && typeof tool.callTool === "function";
      }
    };
    defaultLiveSendClientContentParamerters = {
      turnComplete: true
    };
    Session = class {
      constructor(conn, apiClient) {
        this.conn = conn;
        this.apiClient = apiClient;
      }
      tLiveClientContent(apiClient, params) {
        if (params.turns !== null && params.turns !== void 0) {
          let contents = [];
          try {
            contents = tContents(params.turns);
            if (!apiClient.isVertexAI()) {
              contents = contents.map((item) => contentToMldev$1(item));
            }
          } catch (_a2) {
            throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
          }
          return {
            clientContent: { turns: contents, turnComplete: params.turnComplete }
          };
        }
        return {
          clientContent: { turnComplete: params.turnComplete }
        };
      }
      tLiveClienttToolResponse(apiClient, params) {
        let functionResponses = [];
        if (params.functionResponses == null) {
          throw new Error("functionResponses is required.");
        }
        if (!Array.isArray(params.functionResponses)) {
          functionResponses = [params.functionResponses];
        } else {
          functionResponses = params.functionResponses;
        }
        if (functionResponses.length === 0) {
          throw new Error("functionResponses is required.");
        }
        for (const functionResponse of functionResponses) {
          if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
            throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
          }
          if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
            throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
          }
        }
        const clientMessage = {
          toolResponse: { functionResponses }
        };
        return clientMessage;
      }
      /**
          Send a message over the established connection.
      
          @param params - Contains two **optional** properties, `turns` and
              `turnComplete`.
      
            - `turns` will be converted to a `Content[]`
            - `turnComplete: true` [default] indicates that you are done sending
              content and expect a response. If `turnComplete: false`, the server
              will wait for additional messages before starting generation.
      
          @experimental
      
          @remarks
          There are two ways to send messages to the live API:
          `sendClientContent` and `sendRealtimeInput`.
      
          `sendClientContent` messages are added to the model context **in order**.
          Having a conversation using `sendClientContent` messages is roughly
          equivalent to using the `Chat.sendMessageStream`, except that the state of
          the `chat` history is stored on the API server instead of locally.
      
          Because of `sendClientContent`'s order guarantee, the model cannot respons
          as quickly to `sendClientContent` messages as to `sendRealtimeInput`
          messages. This makes the biggest difference when sending objects that have
          significant preprocessing time (typically images).
      
          The `sendClientContent` message sends a `Content[]`
          which has more options than the `Blob` sent by `sendRealtimeInput`.
      
          So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
      
          - Sending anything that can't be represented as a `Blob` (text,
          `sendClientContent({turns="Hello?"}`)).
          - Managing turns when not using audio input and voice activity detection.
            (`sendClientContent({turnComplete:true})` or the short form
          `sendClientContent()`)
          - Prefilling a conversation context
            ```
            sendClientContent({
                turns: [
                  Content({role:user, parts:...}),
                  Content({role:user, parts:...}),
                  ...
                ]
            })
            ```
          @experimental
         */
      sendClientContent(params) {
        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
        const clientMessage = this.tLiveClientContent(this.apiClient, params);
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
          Send a realtime message over the established connection.
      
          @param params - Contains one property, `media`.
      
            - `media` will be converted to a `Blob`
      
          @experimental
      
          @remarks
          Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
      
          With `sendRealtimeInput` the api will respond to audio automatically
          based on voice activity detection (VAD).
      
          `sendRealtimeInput` is optimized for responsivness at the expense of
          deterministic ordering guarantees. Audio and video tokens are to the
          context when they become available.
      
          Note: The Call signature expects a `Blob` object, but only a subset
          of audio and image mimetypes are allowed.
         */
      sendRealtimeInput(params) {
        let clientMessage = {};
        if (this.apiClient.isVertexAI()) {
          clientMessage = {
            "realtimeInput": liveSendRealtimeInputParametersToVertex(params)
          };
        } else {
          clientMessage = {
            "realtimeInput": liveSendRealtimeInputParametersToMldev(params)
          };
        }
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
          Send a function response message over the established connection.
      
          @param params - Contains property `functionResponses`.
      
            - `functionResponses` will be converted to a `functionResponses[]`
      
          @remarks
          Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
      
          Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
      
          @experimental
         */
      sendToolResponse(params) {
        if (params.functionResponses == null) {
          throw new Error("Tool response parameters are required.");
        }
        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
           Terminates the WebSocket connection.
      
           @experimental
      
           @example
           ```ts
           let model: string;
           if (GOOGLE_GENAI_USE_VERTEXAI) {
             model = 'gemini-2.0-flash-live-preview-04-09';
           } else {
             model = 'gemini-live-2.5-flash-preview';
           }
           const session = await ai.live.connect({
             model: model,
             config: {
               responseModalities: [Modality.AUDIO],
             }
           });
      
           session.close();
           ```
         */
      close() {
        this.conn.close();
      }
    };
    DEFAULT_MAX_REMOTE_CALLS = 10;
    Models = class extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.generateContent = async (params) => {
          var _a2, _b, _c, _d, _e;
          const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
          this.maybeMoveToResponseJsonSchem(params);
          if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {
            return await this.generateContentInternal(transformedParams);
          }
          const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
          if (incompatibleToolIndexes.length > 0) {
            const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
            throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);
          }
          let response;
          let functionResponseContent;
          const automaticFunctionCallingHistory = tContents(transformedParams.contents);
          const maxRemoteCalls = (_c = (_b = (_a2 = transformedParams.config) === null || _a2 === void 0 ? void 0 : _a2.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
          let remoteCalls = 0;
          while (remoteCalls < maxRemoteCalls) {
            response = await this.generateContentInternal(transformedParams);
            if (!response.functionCalls || response.functionCalls.length === 0) {
              break;
            }
            const responseContent = response.candidates[0].content;
            const functionResponseParts = [];
            for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {
              if (isCallableTool(tool)) {
                const callableTool = tool;
                const parts = await callableTool.callTool(response.functionCalls);
                functionResponseParts.push(...parts);
              }
            }
            remoteCalls++;
            functionResponseContent = {
              role: "user",
              parts: functionResponseParts
            };
            transformedParams.contents = tContents(transformedParams.contents);
            transformedParams.contents.push(responseContent);
            transformedParams.contents.push(functionResponseContent);
            if (shouldAppendAfcHistory(transformedParams.config)) {
              automaticFunctionCallingHistory.push(responseContent);
              automaticFunctionCallingHistory.push(functionResponseContent);
            }
          }
          if (shouldAppendAfcHistory(transformedParams.config)) {
            response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
          }
          return response;
        };
        this.generateContentStream = async (params) => {
          var _a2, _b, _c, _d, _e;
          this.maybeMoveToResponseJsonSchem(params);
          if (shouldDisableAfc(params.config)) {
            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
            return await this.generateContentStreamInternal(transformedParams);
          }
          const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
          if (incompatibleToolIndexes.length > 0) {
            const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
            throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`);
          }
          const streamFunctionCall = (_c = (_b = (_a2 = params === null || params === void 0 ? void 0 : params.config) === null || _a2 === void 0 ? void 0 : _a2.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;
          const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;
          if (streamFunctionCall && !disableAfc) {
            throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature.");
          }
          return await this.processAfcStream(params);
        };
        this.generateImages = async (params) => {
          return await this.generateImagesInternal(params).then((apiResponse) => {
            var _a2;
            let positivePromptSafetyAttributes;
            const generatedImages = [];
            if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {
              for (const generatedImage of apiResponse.generatedImages) {
                if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a2 = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a2 === void 0 ? void 0 : _a2.contentType) === "Positive Prompt") {
                  positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
                } else {
                  generatedImages.push(generatedImage);
                }
              }
            }
            let response;
            if (positivePromptSafetyAttributes) {
              response = {
                generatedImages,
                positivePromptSafetyAttributes,
                sdkHttpResponse: apiResponse.sdkHttpResponse
              };
            } else {
              response = {
                generatedImages,
                sdkHttpResponse: apiResponse.sdkHttpResponse
              };
            }
            return response;
          });
        };
        this.list = async (params) => {
          var _a2;
          const defaultConfig = {
            queryBase: true
          };
          const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);
          const actualParams = {
            config: actualConfig
          };
          if (this.apiClient.isVertexAI()) {
            if (!actualParams.config.queryBase) {
              if ((_a2 = actualParams.config) === null || _a2 === void 0 ? void 0 : _a2.filter) {
                throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
              } else {
                actualParams.config.filter = "labels.tune-type:*";
              }
            }
          }
          return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), await this.listInternal(actualParams), actualParams);
        };
        this.editImage = async (params) => {
          const paramsInternal = {
            model: params.model,
            prompt: params.prompt,
            referenceImages: [],
            config: params.config
          };
          if (params.referenceImages) {
            if (params.referenceImages) {
              paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
            }
          }
          return await this.editImageInternal(paramsInternal);
        };
        this.upscaleImage = async (params) => {
          let apiConfig = {
            numberOfImages: 1,
            mode: "upscale"
          };
          if (params.config) {
            apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
          }
          const apiParams = {
            model: params.model,
            image: params.image,
            upscaleFactor: params.upscaleFactor,
            config: apiConfig
          };
          return await this.upscaleImageInternal(apiParams);
        };
        this.generateVideos = async (params) => {
          var _a2, _b, _c, _d, _e, _f;
          if ((params.prompt || params.image || params.video) && params.source) {
            throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
          }
          if (!this.apiClient.isVertexAI()) {
            if (((_a2 = params.video) === null || _a2 === void 0 ? void 0 : _a2.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {
              params.video = {
                uri: params.video.uri,
                mimeType: params.video.mimeType
              };
            } else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {
              params.source.video = {
                uri: params.source.video.uri,
                mimeType: params.source.video.mimeType
              };
            }
          }
          return await this.generateVideosInternal(params);
        };
      }
      /**
       * This logic is needed for GenerateContentConfig only.
       * Previously we made GenerateContentConfig.responseSchema field to accept
       * unknown. Since v1.9.0, we switch to use backend JSON schema support.
       * To maintain backward compatibility, we move the data that was treated as
       * JSON schema from the responseSchema field to the responseJsonSchema field.
       */
      maybeMoveToResponseJsonSchem(params) {
        if (params.config && params.config.responseSchema) {
          if (!params.config.responseJsonSchema) {
            if (Object.keys(params.config.responseSchema).includes("$schema")) {
              params.config.responseJsonSchema = params.config.responseSchema;
              delete params.config.responseSchema;
            }
          }
        }
        return;
      }
      /**
       * Transforms the CallableTools in the parameters to be simply Tools, it
       * copies the params into a new object and replaces the tools, it does not
       * modify the original params. Also sets the MCP usage header if there are
       * MCP tools in the parameters.
       */
      async processParamsMaybeAddMcpUsage(params) {
        var _a2, _b, _c;
        const tools = (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.tools;
        if (!tools) {
          return params;
        }
        const transformedTools = await Promise.all(tools.map(async (tool) => {
          if (isCallableTool(tool)) {
            const callableTool = tool;
            return await callableTool.tool();
          }
          return tool;
        }));
        const newParams = {
          model: params.model,
          contents: params.contents,
          config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
        };
        newParams.config.tools = transformedTools;
        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
          const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
          let newHeaders = Object.assign({}, headers);
          if (Object.keys(newHeaders).length === 0) {
            newHeaders = this.apiClient.getDefaultHeaders();
          }
          setMcpUsageHeader(newHeaders);
          newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
        }
        return newParams;
      }
      async initAfcToolsMap(params) {
        var _a2, _b, _c;
        const afcTools = /* @__PURE__ */ new Map();
        for (const tool of (_b = (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.tools) !== null && _b !== void 0 ? _b : []) {
          if (isCallableTool(tool)) {
            const callableTool = tool;
            const toolDeclaration = await callableTool.tool();
            for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
              if (!declaration.name) {
                throw new Error("Function declaration name is required.");
              }
              if (afcTools.has(declaration.name)) {
                throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
              }
              afcTools.set(declaration.name, callableTool);
            }
          }
        }
        return afcTools;
      }
      async processAfcStream(params) {
        var _a2, _b, _c;
        const maxRemoteCalls = (_c = (_b = (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
        let wereFunctionsCalled = false;
        let remoteCallCount = 0;
        const afcToolsMap = await this.initAfcToolsMap(params);
        return function(models, afcTools, params2) {
          return __asyncGenerator(this, arguments, function* () {
            var _a3, e_1, _b2, _c2;
            var _d, _e;
            while (remoteCallCount < maxRemoteCalls) {
              if (wereFunctionsCalled) {
                remoteCallCount++;
                wereFunctionsCalled = false;
              }
              const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params2));
              const response = yield __await(models.generateContentStreamInternal(transformedParams));
              const functionResponses = [];
              const responseContents = [];
              try {
                for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _a3 = response_1_1.done, !_a3; _f = true) {
                  _c2 = response_1_1.value;
                  _f = false;
                  const chunk = _c2;
                  yield yield __await(chunk);
                  if (chunk.candidates && ((_d = chunk.candidates[0]) === null || _d === void 0 ? void 0 : _d.content)) {
                    responseContents.push(chunk.candidates[0].content);
                    for (const part of (_e = chunk.candidates[0].content.parts) !== null && _e !== void 0 ? _e : []) {
                      if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                        if (!part.functionCall.name) {
                          throw new Error("Function call name was not returned by the model.");
                        }
                        if (!afcTools.has(part.functionCall.name)) {
                          throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                        } else {
                          const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                          functionResponses.push(...responseParts);
                        }
                      }
                    }
                  }
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (!_f && !_a3 && (_b2 = response_1.return))
                    yield __await(_b2.call(response_1));
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
              if (functionResponses.length > 0) {
                wereFunctionsCalled = true;
                const typedResponseChunk = new GenerateContentResponse();
                typedResponseChunk.candidates = [
                  {
                    content: {
                      role: "user",
                      parts: functionResponses
                    }
                  }
                ];
                yield yield __await(typedResponseChunk);
                const newContents = [];
                newContents.push(...responseContents);
                newContents.push({
                  role: "user",
                  parts: functionResponses
                });
                const updatedContents = tContents(params2.contents).concat(newContents);
                params2.contents = updatedContents;
              } else {
                break;
              }
            }
          });
        }(this, afcToolsMap, params);
      }
      async generateContentInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = generateContentParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}:generateContent", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = generateContentResponseFromVertex(apiResponse);
            const typedResp = new GenerateContentResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = generateContentParametersToMldev(this.apiClient, params);
          path5 = formatMap("{model}:generateContent", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = generateContentResponseFromMldev(apiResponse);
            const typedResp = new GenerateContentResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      async generateContentStreamInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = generateContentParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          const apiClient = this.apiClient;
          response = apiClient.requestStream({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          });
          return response.then(function(apiResponse) {
            return __asyncGenerator(this, arguments, function* () {
              var _a3, e_2, _b2, _c2;
              try {
                for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a3 = apiResponse_1_1.done, !_a3; _d2 = true) {
                  _c2 = apiResponse_1_1.value;
                  _d2 = false;
                  const chunk = _c2;
                  const resp = generateContentResponseFromVertex(yield __await(chunk.json()), params);
                  resp["sdkHttpResponse"] = {
                    headers: chunk.headers
                  };
                  const typedResp = new GenerateContentResponse();
                  Object.assign(typedResp, resp);
                  yield yield __await(typedResp);
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (!_d2 && !_a3 && (_b2 = apiResponse_1.return))
                    yield __await(_b2.call(apiResponse_1));
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
            });
          });
        } else {
          const body = generateContentParametersToMldev(this.apiClient, params);
          path5 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          const apiClient = this.apiClient;
          response = apiClient.requestStream({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          });
          return response.then(function(apiResponse) {
            return __asyncGenerator(this, arguments, function* () {
              var _a3, e_3, _b2, _c2;
              try {
                for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a3 = apiResponse_2_1.done, !_a3; _d2 = true) {
                  _c2 = apiResponse_2_1.value;
                  _d2 = false;
                  const chunk = _c2;
                  const resp = generateContentResponseFromMldev(yield __await(chunk.json()), params);
                  resp["sdkHttpResponse"] = {
                    headers: chunk.headers
                  };
                  const typedResp = new GenerateContentResponse();
                  Object.assign(typedResp, resp);
                  yield yield __await(typedResp);
                }
              } catch (e_3_1) {
                e_3 = { error: e_3_1 };
              } finally {
                try {
                  if (!_d2 && !_a3 && (_b2 = apiResponse_2.return))
                    yield __await(_b2.call(apiResponse_2));
                } finally {
                  if (e_3)
                    throw e_3.error;
                }
              }
            });
          });
        }
      }
      /**
       * Calculates embeddings for the given contents. Only text is supported.
       *
       * @param params - The parameters for embedding contents.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.embedContent({
       *  model: 'text-embedding-004',
       *  contents: [
       *    'What is your name?',
       *    'What is your favorite color?',
       *  ],
       *  config: {
       *    outputDimensionality: 64,
       *  },
       * });
       * console.log(response);
       * ```
       */
      async embedContent(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = embedContentParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}:predict", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = embedContentResponseFromVertex(apiResponse);
            const typedResp = new EmbedContentResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = embedContentParametersToMldev(this.apiClient, params);
          path5 = formatMap("{model}:batchEmbedContents", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = embedContentResponseFromMldev(apiResponse);
            const typedResp = new EmbedContentResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Private method for generating images.
       */
      async generateImagesInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = generateImagesParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}:predict", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = generateImagesResponseFromVertex(apiResponse);
            const typedResp = new GenerateImagesResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = generateImagesParametersToMldev(this.apiClient, params);
          path5 = formatMap("{model}:predict", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = generateImagesResponseFromMldev(apiResponse);
            const typedResp = new GenerateImagesResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Private method for editing an image.
       */
      async editImageInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = editImageParametersInternalToVertex(this.apiClient, params);
          path5 = formatMap("{model}:predict", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = editImageResponseFromVertex(apiResponse);
            const typedResp = new EditImageResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          throw new Error("This method is only supported by the Vertex AI.");
        }
      }
      /**
       * Private method for upscaling an image.
       */
      async upscaleImageInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
          path5 = formatMap("{model}:predict", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = upscaleImageResponseFromVertex(apiResponse);
            const typedResp = new UpscaleImageResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          throw new Error("This method is only supported by the Vertex AI.");
        }
      }
      /**
       * Recontextualizes an image.
       *
       * There are two types of recontextualization currently supported:
       * 1) Imagen Product Recontext - Generate images of products in new scenes
       *    and contexts.
       * 2) Virtual Try-On: Generate images of persons modeling fashion products.
       *
       * @param params - The parameters for recontextualizing an image.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response1 = await ai.models.recontextImage({
       *  model: 'imagen-product-recontext-preview-06-30',
       *  source: {
       *    prompt: 'In a modern kitchen setting.',
       *    productImages: [productImage],
       *  },
       *  config: {
       *    numberOfImages: 1,
       *  },
       * });
       * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
       *
       * const response2 = await ai.models.recontextImage({
       *  model: 'virtual-try-on-001',
       *  source: {
       *    personImage: personImage,
       *    productImages: [productImage],
       *  },
       *  config: {
       *    numberOfImages: 1,
       *  },
       * });
       * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
       * ```
       */
      async recontextImage(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = recontextImageParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}:predict", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = recontextImageResponseFromVertex(apiResponse);
            const typedResp = new RecontextImageResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          throw new Error("This method is only supported by the Vertex AI.");
        }
      }
      /**
       * Segments an image, creating a mask of a specified area.
       *
       * @param params - The parameters for segmenting an image.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.segmentImage({
       *  model: 'image-segmentation-001',
       *  source: {
       *    image: image,
       *  },
       *  config: {
       *    mode: 'foreground',
       *  },
       * });
       * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);
       * ```
       */
      async segmentImage(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = segmentImageParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}:predict", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = segmentImageResponseFromVertex(apiResponse);
            const typedResp = new SegmentImageResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          throw new Error("This method is only supported by the Vertex AI.");
        }
      }
      /**
       * Fetches information about a model by name.
       *
       * @example
       * ```ts
       * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
       * ```
       */
      async get(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = getModelParametersToVertex(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = modelFromVertex(apiResponse);
            return resp;
          });
        } else {
          const body = getModelParametersToMldev(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = modelFromMldev(apiResponse);
            return resp;
          });
        }
      }
      async listInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = listModelsParametersToVertex(this.apiClient, params);
          path5 = formatMap("{models_url}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = listModelsResponseFromVertex(apiResponse);
            const typedResp = new ListModelsResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = listModelsParametersToMldev(this.apiClient, params);
          path5 = formatMap("{models_url}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = listModelsResponseFromMldev(apiResponse);
            const typedResp = new ListModelsResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Updates a tuned model by its name.
       *
       * @param params - The parameters for updating the model.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.update({
       *   model: 'tuned-model-name',
       *   config: {
       *     displayName: 'New display name',
       *     description: 'New description',
       *   },
       * });
       * ```
       */
      async update(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = updateModelParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "PATCH",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = modelFromVertex(apiResponse);
            return resp;
          });
        } else {
          const body = updateModelParametersToMldev(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "PATCH",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = modelFromMldev(apiResponse);
            return resp;
          });
        }
      }
      /**
       * Deletes a tuned model by its name.
       *
       * @param params - The parameters for deleting the model.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.delete({model: 'tuned-model-name'});
       * ```
       */
      async delete(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = deleteModelParametersToVertex(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "DELETE",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = deleteModelResponseFromVertex(apiResponse);
            const typedResp = new DeleteModelResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = deleteModelParametersToMldev(this.apiClient, params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "DELETE",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = deleteModelResponseFromMldev(apiResponse);
            const typedResp = new DeleteModelResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Counts the number of tokens in the given contents. Multimodal input is
       * supported for Gemini models.
       *
       * @param params - The parameters for counting tokens.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.countTokens({
       *  model: 'gemini-2.0-flash',
       *  contents: 'The quick brown fox jumps over the lazy dog.'
       * });
       * console.log(response);
       * ```
       */
      async countTokens(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = countTokensParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}:countTokens", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = countTokensResponseFromVertex(apiResponse);
            const typedResp = new CountTokensResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = countTokensParametersToMldev(this.apiClient, params);
          path5 = formatMap("{model}:countTokens", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = countTokensResponseFromMldev(apiResponse);
            const typedResp = new CountTokensResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Given a list of contents, returns a corresponding TokensInfo containing
       * the list of tokens and list of token ids.
       *
       * This method is not supported by the Gemini Developer API.
       *
       * @param params - The parameters for computing tokens.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.computeTokens({
       *  model: 'gemini-2.0-flash',
       *  contents: 'What is your name?'
       * });
       * console.log(response);
       * ```
       */
      async computeTokens(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = computeTokensParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}:computeTokens", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = computeTokensResponseFromVertex(apiResponse);
            const typedResp = new ComputeTokensResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          throw new Error("This method is only supported by the Vertex AI.");
        }
      }
      /**
       * Private method for generating videos.
       */
      async generateVideosInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = generateVideosParametersToVertex(this.apiClient, params);
          path5 = formatMap("{model}:predictLongRunning", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = generateVideosOperationFromVertex(apiResponse);
            const typedResp = new GenerateVideosOperation();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = generateVideosParametersToMldev(this.apiClient, params);
          path5 = formatMap("{model}:predictLongRunning", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = generateVideosOperationFromMldev(apiResponse);
            const typedResp = new GenerateVideosOperation();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
    };
    Operations = class extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
      }
      /**
       * Gets the status of a long-running operation.
       *
       * @param parameters The parameters for the get operation request.
       * @return The updated Operation object, with the latest status or result.
       */
      async getVideosOperation(parameters) {
        const operation = parameters.operation;
        const config = parameters.config;
        if (operation.name === void 0 || operation.name === "") {
          throw new Error("Operation name is required.");
        }
        if (this.apiClient.isVertexAI()) {
          const resourceName2 = operation.name.split("/operations/")[0];
          let httpOptions = void 0;
          if (config && "httpOptions" in config) {
            httpOptions = config.httpOptions;
          }
          const rawOperation = await this.fetchPredictVideosOperationInternal({
            operationName: operation.name,
            resourceName: resourceName2,
            config: { httpOptions }
          });
          return operation._fromAPIResponse({
            apiResponse: rawOperation,
            _isVertexAI: true
          });
        } else {
          const rawOperation = await this.getVideosOperationInternal({
            operationName: operation.name,
            config
          });
          return operation._fromAPIResponse({
            apiResponse: rawOperation,
            _isVertexAI: false
          });
        }
      }
      /**
       * Gets the status of a long-running operation.
       *
       * @param parameters The parameters for the get operation request.
       * @return The updated Operation object, with the latest status or result.
       */
      async get(parameters) {
        const operation = parameters.operation;
        const config = parameters.config;
        if (operation.name === void 0 || operation.name === "") {
          throw new Error("Operation name is required.");
        }
        if (this.apiClient.isVertexAI()) {
          const resourceName2 = operation.name.split("/operations/")[0];
          let httpOptions = void 0;
          if (config && "httpOptions" in config) {
            httpOptions = config.httpOptions;
          }
          const rawOperation = await this.fetchPredictVideosOperationInternal({
            operationName: operation.name,
            resourceName: resourceName2,
            config: { httpOptions }
          });
          return operation._fromAPIResponse({
            apiResponse: rawOperation,
            _isVertexAI: true
          });
        } else {
          const rawOperation = await this.getVideosOperationInternal({
            operationName: operation.name,
            config
          });
          return operation._fromAPIResponse({
            apiResponse: rawOperation,
            _isVertexAI: false
          });
        }
      }
      async getVideosOperationInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = getOperationParametersToVertex(params);
          path5 = formatMap("{operationName}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response;
        } else {
          const body = getOperationParametersToMldev(params);
          path5 = formatMap("{operationName}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response;
        }
      }
      async fetchPredictVideosOperationInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = fetchPredictOperationParametersToVertex(params);
          path5 = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response;
        } else {
          throw new Error("This method is only supported by the Vertex AI.");
        }
      }
    };
    Tokens = class extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
      }
      /**
       * Creates an ephemeral auth token resource.
       *
       * @experimental
       *
       * @remarks
       * Ephemeral auth tokens is only supported in the Gemini Developer API.
       * It can be used for the session connection to the Live constrained API.
       * Support in v1alpha only.
       *
       * @param params - The parameters for the create request.
       * @return The created auth token.
       *
       * @example
       * ```ts
       * const ai = new GoogleGenAI({
       *     apiKey: token.name,
       *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
       * });
       *
       * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
       * // when using the token in Live API sessions. Each session connection can
       * // use a different configuration.
       * const config: CreateAuthTokenConfig = {
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       * }
       * const token = await ai.tokens.create(config);
       *
       * // Case 2: If LiveEphemeralParameters is set, lock all fields in
       * // LiveConnectConfig when using the token in Live API sessions. For
       * // example, changing `outputAudioTranscription` in the Live API
       * // connection will be ignored by the API.
       * const config: CreateAuthTokenConfig =
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       *     LiveEphemeralParameters: {
       *        model: 'gemini-2.0-flash-001',
       *        config: {
       *           'responseModalities': ['AUDIO'],
       *           'systemInstruction': 'Always answer in English.',
       *        }
       *     }
       * }
       * const token = await ai.tokens.create(config);
       *
       * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
       * // set, lock LiveConnectConfig with set and additional fields (e.g.
       * // responseModalities, systemInstruction, temperature in this example) when
       * // using the token in Live API sessions.
       * const config: CreateAuthTokenConfig =
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       *     LiveEphemeralParameters: {
       *        model: 'gemini-2.0-flash-001',
       *        config: {
       *           'responseModalities': ['AUDIO'],
       *           'systemInstruction': 'Always answer in English.',
       *        }
       *     },
       *     lockAdditionalFields: ['temperature'],
       * }
       * const token = await ai.tokens.create(config);
       *
       * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
       * // empty array, lock LiveConnectConfig with set fields (e.g.
       * // responseModalities, systemInstruction in this example) when using the
       * // token in Live API sessions.
       * const config: CreateAuthTokenConfig =
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       *     LiveEphemeralParameters: {
       *        model: 'gemini-2.0-flash-001',
       *        config: {
       *           'responseModalities': ['AUDIO'],
       *           'systemInstruction': 'Always answer in English.',
       *        }
       *     },
       *     lockAdditionalFields: [],
       * }
       * const token = await ai.tokens.create(config);
       * ```
       */
      async create(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
        } else {
          const body = createAuthTokenParametersToMldev(this.apiClient, params);
          path5 = formatMap("auth_tokens", body["_url"]);
          queryParams = body["_query"];
          delete body["config"];
          delete body["_url"];
          delete body["_query"];
          const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(transformedBody),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        }
      }
    };
    Documents = class extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = async (params) => {
          return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x) => this.listInternal({ parent: params.parent, config: x.config }), await this.listInternal(params), params);
        };
      }
      /**
       * Gets a Document.
       *
       * @param params - The parameters for getting a document.
       * @return Document.
       */
      async get(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = getDocumentParametersToMldev(params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        }
      }
      /**
       * Deletes a Document.
       *
       * @param params - The parameters for deleting a document.
       */
      async delete(params) {
        var _a2, _b;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = deleteDocumentParametersToMldev(params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          await this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "DELETE",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          });
        }
      }
      async listInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = listDocumentsParametersToMldev(params);
          path5 = formatMap("{parent}/documents", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = listDocumentsResponseFromMldev(apiResponse);
            const typedResp = new ListDocumentsResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
    };
    FileSearchStores = class extends BaseModule {
      constructor(apiClient, documents = new Documents(apiClient)) {
        super();
        this.apiClient = apiClient;
        this.documents = documents;
        this.list = async (params = {}) => {
          return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x) => this.listInternal(x), await this.listInternal(params), params);
        };
      }
      /**
       * Uploads a file asynchronously to a given File Search Store.
       * This method is not available in Vertex AI.
       * Supported upload sources:
       * - Node.js: File path (string) or Blob object.
       * - Browser: Blob object (e.g., File).
       *
       * @remarks
       * The `mimeType` can be specified in the `config` parameter. If omitted:
       *  - For file path (string) inputs, the `mimeType` will be inferred from the
       *     file extension.
       *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
       *     property.
       *
       * This section can contain multiple paragraphs and code examples.
       *
       * @param params - Optional parameters specified in the
       *        `types.UploadToFileSearchStoreParameters` interface.
       *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional
       *         config in the parameters.
       * @return A promise that resolves to a long running operation.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       * the `mimeType` can be provided in the `params.config` parameter.
       * @throws An error occurs if a suitable upload location cannot be established.
       *
       * @example
       * The following code uploads a file to a given file search store.
       *
       * ```ts
       * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {
       *   mimeType: 'text/plain',
       * }});
       * console.log(operation.name);
       * ```
       */
      async uploadToFileSearchStore(params) {
        if (this.apiClient.isVertexAI()) {
          throw new Error("Vertex AI does not support uploading files to a file search store.");
        }
        return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);
      }
      /**
       * Creates a File Search Store.
       *
       * @param params - The parameters for creating a File Search Store.
       * @return FileSearchStore.
       */
      async create(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = createFileSearchStoreParametersToMldev(params);
          path5 = formatMap("fileSearchStores", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        }
      }
      /**
       * Gets a File Search Store.
       *
       * @param params - The parameters for getting a File Search Store.
       * @return FileSearchStore.
       */
      async get(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = getFileSearchStoreParametersToMldev(params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((resp) => {
            return resp;
          });
        }
      }
      /**
       * Deletes a File Search Store.
       *
       * @param params - The parameters for deleting a File Search Store.
       */
      async delete(params) {
        var _a2, _b;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = deleteFileSearchStoreParametersToMldev(params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          await this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "DELETE",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          });
        }
      }
      async listInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = listFileSearchStoresParametersToMldev(params);
          path5 = formatMap("fileSearchStores", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = listFileSearchStoresResponseFromMldev(apiResponse);
            const typedResp = new ListFileSearchStoresResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      async uploadToFileSearchStoreInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = uploadToFileSearchStoreParametersToMldev(params);
          path5 = formatMap("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);
            const typedResp = new UploadToFileSearchStoreResumableResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Imports a File from File Service to a FileSearchStore.
       *
       * This is a long-running operation, see aip.dev/151
       *
       * @param params - The parameters for importing a file to a file search store.
       * @return ImportFileOperation.
       */
      async importFile(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = importFileParametersToMldev(params);
          path5 = formatMap("{file_search_store_name}:importFile", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json();
          });
          return response.then((apiResponse) => {
            const resp = importFileOperationFromMldev(apiResponse);
            const typedResp = new ImportFileOperation();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
    };
    uuid4Internal = function() {
      const { crypto: crypto2 } = globalThis;
      if (crypto2 === null || crypto2 === void 0 ? void 0 : crypto2.randomUUID) {
        uuid4Internal = crypto2.randomUUID.bind(crypto2);
        return crypto2.randomUUID();
      }
      const u8 = new Uint8Array(1);
      const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
      return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
    };
    uuid4 = () => uuid4Internal();
    castToError = (err) => {
      if (err instanceof Error)
        return err;
      if (typeof err === "object" && err !== null) {
        try {
          if (Object.prototype.toString.call(err) === "[object Error]") {
            const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
            if (err.stack)
              error.stack = err.stack;
            if (err.cause && !error.cause)
              error.cause = err.cause;
            if (err.name)
              error.name = err.name;
            return error;
          }
        } catch (_a2) {
        }
        try {
          return new Error(JSON.stringify(err));
        } catch (_b) {
        }
      }
      return new Error(err);
    };
    GeminiNextGenAPIClientError = class extends Error {
    };
    APIError = class _APIError extends GeminiNextGenAPIClientError {
      constructor(status, error, message, headers) {
        super(`${_APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        this.error = error;
      }
      static makeMessage(status, error, message) {
        const msg = (error === null || error === void 0 ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
        if (status && msg) {
          return `${status} ${msg}`;
        }
        if (status) {
          return `${status} status code (no body)`;
        }
        if (msg) {
          return msg;
        }
        return "(no status code or body)";
      }
      static generate(status, errorResponse, message, headers) {
        if (!status || !headers) {
          return new APIConnectionError({ message, cause: castToError(errorResponse) });
        }
        const error = errorResponse;
        if (status === 400) {
          return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
          return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
          return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
          return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
          return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
          return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
          return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
          return new InternalServerError(status, error, message, headers);
        }
        return new _APIError(status, error, message, headers);
      }
    };
    APIUserAbortError = class extends APIError {
      constructor({ message } = {}) {
        super(void 0, void 0, message || "Request was aborted.", void 0);
      }
    };
    APIConnectionError = class extends APIError {
      constructor({ message, cause }) {
        super(void 0, void 0, message || "Connection error.", void 0);
        if (cause)
          this.cause = cause;
      }
    };
    APIConnectionTimeoutError = class extends APIConnectionError {
      constructor({ message } = {}) {
        super({ message: message !== null && message !== void 0 ? message : "Request timed out." });
      }
    };
    BadRequestError = class extends APIError {
    };
    AuthenticationError = class extends APIError {
    };
    PermissionDeniedError = class extends APIError {
    };
    NotFoundError = class extends APIError {
    };
    ConflictError = class extends APIError {
    };
    UnprocessableEntityError = class extends APIError {
    };
    RateLimitError = class extends APIError {
    };
    InternalServerError = class extends APIError {
    };
    startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
    isAbsoluteURL = (url) => {
      return startsWithSchemeRegexp.test(url);
    };
    isArrayInternal = (val) => (isArrayInternal = Array.isArray, isArrayInternal(val));
    isArray = isArrayInternal;
    isReadonlyArrayInternal = isArray;
    isReadonlyArray = isReadonlyArrayInternal;
    validatePositiveInteger = (name, n) => {
      if (typeof n !== "number" || !Number.isInteger(n)) {
        throw new GeminiNextGenAPIClientError(`${name} must be an integer`);
      }
      if (n < 0) {
        throw new GeminiNextGenAPIClientError(`${name} must be a positive integer`);
      }
      return n;
    };
    safeJSON = (text) => {
      try {
        return JSON.parse(text);
      } catch (err) {
        return void 0;
      }
    };
    sleep$1 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    VERSION = "0.0.1";
    getPlatformProperties = () => {
      var _a2, _b, _c, _d, _e;
      const detectedPlatform = getDetectedPlatform();
      if (detectedPlatform === "deno") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(Deno.build.os),
          "X-Stainless-Arch": normalizeArch(Deno.build.arch),
          "X-Stainless-Runtime": "deno",
          "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a2 = Deno.version) === null || _a2 === void 0 ? void 0 : _a2.deno) !== null && _b !== void 0 ? _b : "unknown"
        };
      }
      if (typeof EdgeRuntime !== "undefined") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": `other:${EdgeRuntime}`,
          "X-Stainless-Runtime": "edge",
          "X-Stainless-Runtime-Version": globalThis.process.version
        };
      }
      if (detectedPlatform === "node") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform((_c = globalThis.process.platform) !== null && _c !== void 0 ? _c : "unknown"),
          "X-Stainless-Arch": normalizeArch((_d = globalThis.process.arch) !== null && _d !== void 0 ? _d : "unknown"),
          "X-Stainless-Runtime": "node",
          "X-Stainless-Runtime-Version": (_e = globalThis.process.version) !== null && _e !== void 0 ? _e : "unknown"
        };
      }
      const browserInfo = getBrowserInfo();
      if (browserInfo) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
          "X-Stainless-Runtime-Version": browserInfo.version
        };
      }
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": "unknown",
        "X-Stainless-Runtime-Version": "unknown"
      };
    };
    normalizeArch = (arch) => {
      if (arch === "x32")
        return "x32";
      if (arch === "x86_64" || arch === "x64")
        return "x64";
      if (arch === "arm")
        return "arm";
      if (arch === "aarch64" || arch === "arm64")
        return "arm64";
      if (arch)
        return `other:${arch}`;
      return "unknown";
    };
    normalizePlatform = (platform) => {
      platform = platform.toLowerCase();
      if (platform.includes("ios"))
        return "iOS";
      if (platform === "android")
        return "Android";
      if (platform === "darwin")
        return "MacOS";
      if (platform === "win32")
        return "Windows";
      if (platform === "freebsd")
        return "FreeBSD";
      if (platform === "openbsd")
        return "OpenBSD";
      if (platform === "linux")
        return "Linux";
      if (platform)
        return `Other:${platform}`;
      return "Unknown";
    };
    getPlatformHeaders = () => {
      return _platformHeaders !== null && _platformHeaders !== void 0 ? _platformHeaders : _platformHeaders = getPlatformProperties();
    };
    FallbackEncoder = ({ headers, body }) => {
      return {
        bodyHeaders: {
          "content-type": "application/json"
        },
        body: JSON.stringify(body)
      };
    };
    checkFileSupport = () => {
      var _a2;
      if (typeof File === "undefined") {
        const { process } = globalThis;
        const isOldNode = typeof ((_a2 = process === null || process === void 0 ? void 0 : process.versions) === null || _a2 === void 0 ? void 0 : _a2.node) === "string" && parseInt(process.versions.node.split(".")) < 20;
        throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
      }
    };
    isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
    isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
    isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
    isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
    APIResource = class {
      constructor(client) {
        this._client = client;
      }
    };
    APIResource._key = [];
    EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
    createPathTagFunction = (pathEncoder = encodeURIPath) => function path5(statics, ...params) {
      if (statics.length === 1)
        return statics[0];
      let postPath = false;
      const invalidSegments = [];
      const path6 = statics.reduce((previousValue, currentValue, index) => {
        var _a2, _b, _c;
        if (/[?#]/.test(currentValue)) {
          postPath = true;
        }
        const value = params[index];
        let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
        if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
        value.toString === ((_c = Object.getPrototypeOf((_b = Object.getPrototypeOf((_a2 = value.hasOwnProperty) !== null && _a2 !== void 0 ? _a2 : EMPTY)) !== null && _b !== void 0 ? _b : EMPTY)) === null || _c === void 0 ? void 0 : _c.toString))) {
          encoded = value + "";
          invalidSegments.push({
            start: previousValue.length + currentValue.length,
            length: encoded.length,
            error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
          });
        }
        return previousValue + currentValue + (index === params.length ? "" : encoded);
      }, "");
      const pathOnly = path6.split(/[?#]/, 1)[0];
      const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
      let match;
      while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
        invalidSegments.push({
          start: match.index,
          length: match[0].length,
          error: `Value "${match[0]}" can't be safely passed as a path parameter`
        });
      }
      invalidSegments.sort((a, b) => a.start - b.start);
      if (invalidSegments.length > 0) {
        let lastEnd = 0;
        const underline = invalidSegments.reduce((acc, segment) => {
          const spaces = " ".repeat(segment.start - lastEnd);
          const arrows = "^".repeat(segment.length);
          lastEnd = segment.start + segment.length;
          return acc + spaces + arrows;
        }, "");
        throw new GeminiNextGenAPIClientError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path6}
${underline}`);
      }
      return path6;
    };
    path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);
    BaseInteractions = class extends APIResource {
      create(params, options) {
        var _a2;
        const { api_version = this._client.apiVersion } = params, body = __rest(params, ["api_version"]);
        if ("model" in body && "agent_config" in body) {
          throw new GeminiNextGenAPIClientError(`Invalid request: specified \`model\` and \`agent_config\`. If specifying \`model\`, use \`generation_config\`.`);
        }
        if ("agent" in body && "generation_config" in body) {
          throw new GeminiNextGenAPIClientError(`Invalid request: specified \`agent\` and \`generation_config\`. If specifying \`agent\`, use \`agent_config\`.`);
        }
        return this._client.post(path`/${api_version}/interactions`, Object.assign(Object.assign({ body }, options), { stream: (_a2 = params.stream) !== null && _a2 !== void 0 ? _a2 : false }));
      }
      /**
       * Deletes the interaction by id.
       *
       * @example
       * ```ts
       * const interaction = await client.interactions.delete('id', {
       *   api_version: 'api_version',
       * });
       * ```
       */
      delete(id, params = {}, options) {
        const { api_version = this._client.apiVersion } = params !== null && params !== void 0 ? params : {};
        return this._client.delete(path`/${api_version}/interactions/${id}`, options);
      }
      /**
       * Cancels an interaction by id. This only applies to background interactions that are still running.
       *
       * @example
       * ```ts
       * const interaction = await client.interactions.cancel('id', {
       *   api_version: 'api_version',
       * });
       * ```
       */
      cancel(id, params = {}, options) {
        const { api_version = this._client.apiVersion } = params !== null && params !== void 0 ? params : {};
        return this._client.post(path`/${api_version}/interactions/${id}/cancel`, options);
      }
      get(id, params = {}, options) {
        var _a2;
        const _b = params !== null && params !== void 0 ? params : {}, { api_version = this._client.apiVersion } = _b, query = __rest(_b, ["api_version"]);
        return this._client.get(path`/${api_version}/interactions/${id}`, Object.assign(Object.assign({ query }, options), { stream: (_a2 = params === null || params === void 0 ? void 0 : params.stream) !== null && _a2 !== void 0 ? _a2 : false }));
      }
    };
    BaseInteractions._key = Object.freeze(["interactions"]);
    Interactions = class extends BaseInteractions {
    };
    LineDecoder = class {
      constructor() {
        this.buffer = new Uint8Array();
        this.carriageReturnIndex = null;
      }
      decode(chunk) {
        if (chunk == null) {
          return [];
        }
        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
        this.buffer = concatBytes([this.buffer, binaryChunk]);
        const lines = [];
        let patternIndex;
        while ((patternIndex = findNewlineIndex(this.buffer, this.carriageReturnIndex)) != null) {
          if (patternIndex.carriage && this.carriageReturnIndex == null) {
            this.carriageReturnIndex = patternIndex.index;
            continue;
          }
          if (this.carriageReturnIndex != null && (patternIndex.index !== this.carriageReturnIndex + 1 || patternIndex.carriage)) {
            lines.push(decodeUTF8(this.buffer.subarray(0, this.carriageReturnIndex - 1)));
            this.buffer = this.buffer.subarray(this.carriageReturnIndex);
            this.carriageReturnIndex = null;
            continue;
          }
          const endIndex = this.carriageReturnIndex !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
          const line = decodeUTF8(this.buffer.subarray(0, endIndex));
          lines.push(line);
          this.buffer = this.buffer.subarray(patternIndex.index);
          this.carriageReturnIndex = null;
        }
        return lines;
      }
      flush() {
        if (!this.buffer.length) {
          return [];
        }
        return this.decode("\n");
      }
    };
    LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
    LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
    levelNumbers = {
      off: 0,
      error: 200,
      warn: 300,
      info: 400,
      debug: 500
    };
    parseLogLevel = (maybeLevel, sourceName, client) => {
      if (!maybeLevel) {
        return void 0;
      }
      if (hasOwn(levelNumbers, maybeLevel)) {
        return maybeLevel;
      }
      loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
      return void 0;
    };
    noopLogger = {
      error: noop,
      warn: noop,
      info: noop,
      debug: noop
    };
    cachedLoggers = /* @__PURE__ */ new WeakMap();
    formatRequestDetails = (details) => {
      if (details.options) {
        details.options = Object.assign({}, details.options);
        delete details.options["headers"];
      }
      if (details.headers) {
        details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
          name,
          name.toLowerCase() === "x-goog-api-key" || name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
        ]));
      }
      if ("retryOfRequestLogID" in details) {
        if (details.retryOfRequestLogID) {
          details.retryOf = details.retryOfRequestLogID;
        }
        delete details.retryOfRequestLogID;
      }
      return details;
    };
    Stream = class _Stream {
      constructor(iterator, controller, client) {
        this.iterator = iterator;
        this.controller = controller;
        this.client = client;
      }
      static fromSSEResponse(response, controller, client) {
        let consumed = false;
        const logger = client ? loggerFor(client) : console;
        function iterator() {
          return __asyncGenerator(this, arguments, function* iterator_1() {
            var _a2, e_1, _b, _c;
            if (consumed) {
              throw new GeminiNextGenAPIClientError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
            }
            consumed = true;
            let done = false;
            try {
              try {
                for (var _d = true, _e = __asyncValues(_iterSSEMessages(response, controller)), _f; _f = yield __await(_e.next()), _a2 = _f.done, !_a2; _d = true) {
                  _c = _f.value;
                  _d = false;
                  const sse = _c;
                  if (done)
                    continue;
                  if (sse.data.startsWith("[DONE]")) {
                    done = true;
                    continue;
                  } else {
                    try {
                      yield yield __await(JSON.parse(sse.data));
                    } catch (e) {
                      logger.error(`Could not parse message into JSON:`, sse.data);
                      logger.error(`From chunk:`, sse.raw);
                      throw e;
                    }
                  }
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (!_d && !_a2 && (_b = _e.return))
                    yield __await(_b.call(_e));
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
              done = true;
            } catch (e) {
              if (isAbortError(e))
                return yield __await(void 0);
              throw e;
            } finally {
              if (!done)
                controller.abort();
            }
          });
        }
        return new _Stream(iterator, controller, client);
      }
      /**
       * Generates a Stream from a newline-separated ReadableStream
       * where each item is a JSON value.
       */
      static fromReadableStream(readableStream, controller, client) {
        let consumed = false;
        function iterLines() {
          return __asyncGenerator(this, arguments, function* iterLines_1() {
            var _a2, e_2, _b, _c;
            const lineDecoder = new LineDecoder();
            const iter = ReadableStreamToAsyncIterable(readableStream);
            try {
              for (var _d = true, iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield __await(iter_1.next()), _a2 = iter_1_1.done, !_a2; _d = true) {
                _c = iter_1_1.value;
                _d = false;
                const chunk = _c;
                for (const line of lineDecoder.decode(chunk)) {
                  yield yield __await(line);
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (!_d && !_a2 && (_b = iter_1.return))
                  yield __await(_b.call(iter_1));
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
            for (const line of lineDecoder.flush()) {
              yield yield __await(line);
            }
          });
        }
        function iterator() {
          return __asyncGenerator(this, arguments, function* iterator_2() {
            var _a2, e_3, _b, _c;
            if (consumed) {
              throw new GeminiNextGenAPIClientError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
            }
            consumed = true;
            let done = false;
            try {
              try {
                for (var _d = true, _e = __asyncValues(iterLines()), _f; _f = yield __await(_e.next()), _a2 = _f.done, !_a2; _d = true) {
                  _c = _f.value;
                  _d = false;
                  const line = _c;
                  if (done)
                    continue;
                  if (line)
                    yield yield __await(JSON.parse(line));
                }
              } catch (e_3_1) {
                e_3 = { error: e_3_1 };
              } finally {
                try {
                  if (!_d && !_a2 && (_b = _e.return))
                    yield __await(_b.call(_e));
                } finally {
                  if (e_3)
                    throw e_3.error;
                }
              }
              done = true;
            } catch (e) {
              if (isAbortError(e))
                return yield __await(void 0);
              throw e;
            } finally {
              if (!done)
                controller.abort();
            }
          });
        }
        return new _Stream(iterator, controller, client);
      }
      [Symbol.asyncIterator]() {
        return this.iterator();
      }
      /**
       * Splits the stream into two streams which can be
       * independently read from at different speeds.
       */
      tee() {
        const left = [];
        const right = [];
        const iterator = this.iterator();
        const teeIterator = (queue) => {
          return {
            next: () => {
              if (queue.length === 0) {
                const result = iterator.next();
                left.push(result);
                right.push(result);
              }
              return queue.shift();
            }
          };
        };
        return [
          new _Stream(() => teeIterator(left), this.controller, this.client),
          new _Stream(() => teeIterator(right), this.controller, this.client)
        ];
      }
      /**
       * Converts this stream to a newline-separated ReadableStream of
       * JSON stringified values in the stream
       * which can be turned back into a Stream with `Stream.fromReadableStream()`.
       */
      toReadableStream() {
        const self = this;
        let iter;
        return makeReadableStream({
          async start() {
            iter = self[Symbol.asyncIterator]();
          },
          async pull(ctrl) {
            try {
              const { value, done } = await iter.next();
              if (done)
                return ctrl.close();
              const bytes = encodeUTF8(JSON.stringify(value) + "\n");
              ctrl.enqueue(bytes);
            } catch (err) {
              ctrl.error(err);
            }
          },
          async cancel() {
            var _a2;
            await ((_a2 = iter.return) === null || _a2 === void 0 ? void 0 : _a2.call(iter));
          }
        });
      }
    };
    SSEDecoder = class {
      constructor() {
        this.event = null;
        this.data = [];
        this.chunks = [];
      }
      decode(line) {
        if (line.endsWith("\r")) {
          line = line.substring(0, line.length - 1);
        }
        if (!line) {
          if (!this.event && !this.data.length)
            return null;
          const sse = {
            event: this.event,
            data: this.data.join("\n"),
            raw: this.chunks
          };
          this.event = null;
          this.data = [];
          this.chunks = [];
          return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(":")) {
          return null;
        }
        let [fieldname, _, value] = partition(line, ":");
        if (value.startsWith(" ")) {
          value = value.substring(1);
        }
        if (fieldname === "event") {
          this.event = value;
        } else if (fieldname === "data") {
          this.data.push(value);
        }
        return null;
      }
    };
    APIPromise = class _APIPromise extends Promise {
      constructor(client, responsePromise, parseResponse = defaultParseResponse) {
        super((resolve) => {
          resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
        this.client = client;
      }
      _thenUnwrap(transform) {
        return new _APIPromise(this.client, this.responsePromise, async (client, props) => transform(await this.parseResponse(client, props), props));
      }
      /**
       * Gets the raw `Response` instance instead of parsing the response
       * data.
       *
       * If you want to parse the response body but still get the `Response`
       * instance, you can use {@link withResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
       * to your `tsconfig.json`.
       */
      asResponse() {
        return this.responsePromise.then((p) => p.response);
      }
      /**
       * Gets the parsed response data and the raw `Response` instance.
       *
       * If you just want to get the raw `Response` instance without parsing it,
       * you can use {@link asResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
       * to your `tsconfig.json`.
       */
      async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response };
      }
      parse() {
        if (!this.parsedPromise) {
          this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(this.client, data));
        }
        return this.parsedPromise;
      }
      then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.parse().catch(onrejected);
      }
      finally(onfinally) {
        return this.parse().finally(onfinally);
      }
    };
    brand_privateNullableHeaders = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
    buildHeaders = (newHeaders) => {
      const targetHeaders = new Headers();
      const nullHeaders = /* @__PURE__ */ new Set();
      for (const headers of newHeaders) {
        const seenHeaders = /* @__PURE__ */ new Set();
        for (const [name, value] of iterateHeaders(headers)) {
          const lowerName = name.toLowerCase();
          if (!seenHeaders.has(lowerName)) {
            targetHeaders.delete(name);
            seenHeaders.add(lowerName);
          }
          if (value === null) {
            targetHeaders.delete(name);
            nullHeaders.add(lowerName);
          } else {
            targetHeaders.append(name, value);
            nullHeaders.delete(lowerName);
          }
        }
      }
      return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
    };
    readEnv = (env) => {
      var _a2, _b, _c, _d, _e, _f;
      if (typeof globalThis.process !== "undefined") {
        return (_c = (_b = (_a2 = globalThis.process.env) === null || _a2 === void 0 ? void 0 : _a2[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : void 0;
      }
      if (typeof globalThis.Deno !== "undefined") {
        return (_f = (_e = (_d = globalThis.Deno.env) === null || _d === void 0 ? void 0 : _d.get) === null || _e === void 0 ? void 0 : _e.call(_d, env)) === null || _f === void 0 ? void 0 : _f.trim();
      }
      return void 0;
    };
    BaseGeminiNextGenAPIClient = class _BaseGeminiNextGenAPIClient {
      /**
       * API Client for interfacing with the Gemini Next Gen API API.
       *
       * @param {string | null | undefined} [opts.apiKey=process.env['GEMINI_API_KEY'] ?? null]
       * @param {string | undefined} [opts.apiVersion=v1beta]
       * @param {string} [opts.baseURL=process.env['GEMINI_NEXT_GEN_API_BASE_URL'] ?? https://generativelanguage.googleapis.com] - Override the default base URL for the API.
       * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
       * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
       */
      constructor(_b) {
        var _c, _d, _e, _f, _g, _h, _j;
        var { baseURL = readEnv("GEMINI_NEXT_GEN_API_BASE_URL"), apiKey = (_c = readEnv("GEMINI_API_KEY")) !== null && _c !== void 0 ? _c : null, apiVersion = "v1beta" } = _b, opts = __rest(_b, ["baseURL", "apiKey", "apiVersion"]);
        const options = Object.assign(Object.assign({
          apiKey,
          apiVersion
        }, opts), { baseURL: baseURL || `https://generativelanguage.googleapis.com` });
        this.baseURL = options.baseURL;
        this.timeout = (_d = options.timeout) !== null && _d !== void 0 ? _d : _BaseGeminiNextGenAPIClient.DEFAULT_TIMEOUT;
        this.logger = (_e = options.logger) !== null && _e !== void 0 ? _e : console;
        const defaultLogLevel = "warn";
        this.logLevel = defaultLogLevel;
        this.logLevel = (_g = (_f = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this)) !== null && _f !== void 0 ? _f : parseLogLevel(readEnv("GEMINI_NEXT_GEN_API_LOG"), "process.env['GEMINI_NEXT_GEN_API_LOG']", this)) !== null && _g !== void 0 ? _g : defaultLogLevel;
        this.fetchOptions = options.fetchOptions;
        this.maxRetries = (_h = options.maxRetries) !== null && _h !== void 0 ? _h : 2;
        this.fetch = (_j = options.fetch) !== null && _j !== void 0 ? _j : getDefaultFetch();
        this.encoder = FallbackEncoder;
        this._options = options;
        this.apiKey = apiKey;
        this.apiVersion = apiVersion;
        this.clientAdapter = options.clientAdapter;
      }
      /**
       * Create a new client instance re-using the same options given to the current client with optional overriding.
       */
      withOptions(options) {
        const client = new this.constructor(Object.assign(Object.assign(Object.assign({}, this._options), { baseURL: this.baseURL, maxRetries: this.maxRetries, timeout: this.timeout, logger: this.logger, logLevel: this.logLevel, fetch: this.fetch, fetchOptions: this.fetchOptions, apiKey: this.apiKey, apiVersion: this.apiVersion }), options));
        return client;
      }
      /**
       * Check whether the base URL is set to its default.
       */
      baseURLOverridden() {
        return this.baseURL !== "https://generativelanguage.googleapis.com";
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      validateHeaders({ values, nulls }) {
        if (values.has("authorization") || values.has("x-goog-api-key")) {
          return;
        }
        if (this.apiKey && values.get("x-goog-api-key")) {
          return;
        }
        if (nulls.has("x-goog-api-key")) {
          return;
        }
        throw new Error('Could not resolve authentication method. Expected the apiKey to be set. Or for the "x-goog-api-key" headers to be explicitly omitted');
      }
      async authHeaders(opts) {
        const existingHeaders = buildHeaders([opts.headers]);
        if (existingHeaders.values.has("authorization") || existingHeaders.values.has("x-goog-api-key")) {
          return void 0;
        }
        if (this.apiKey) {
          return buildHeaders([{ "x-goog-api-key": this.apiKey }]);
        }
        if (this.clientAdapter.isVertexAI()) {
          return buildHeaders([await this.clientAdapter.getAuthHeaders()]);
        }
        return void 0;
      }
      /**
       * Basic re-implementation of `qs.stringify` for primitive types.
       */
      stringifyQuery(query) {
        return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
          }
          if (value === null) {
            return `${encodeURIComponent(key)}=`;
          }
          throw new GeminiNextGenAPIClientError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
        }).join("&");
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${VERSION}`;
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
      }
      makeStatusError(status, error, message, headers) {
        return APIError.generate(status, error, message, headers);
      }
      buildURL(path5, query, defaultBaseURL) {
        const baseURL = !this.baseURLOverridden() && defaultBaseURL || this.baseURL;
        const url = isAbsoluteURL(path5) ? new URL(path5) : new URL(baseURL + (baseURL.endsWith("/") && path5.startsWith("/") ? path5.slice(1) : path5));
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
          query = Object.assign(Object.assign({}, defaultQuery), query);
        }
        if (typeof query === "object" && query && !Array.isArray(query)) {
          url.search = this.stringifyQuery(query);
        }
        return url.toString();
      }
      /**
         * Used as a callback for mutating the given `FinalRequestOptions` object.
      
         */
      async prepareOptions(options) {
        if (this.clientAdapter && this.clientAdapter.isVertexAI() && !options.path.startsWith(`/${this.apiVersion}/projects/`)) {
          const oldPath = options.path.slice(this.apiVersion.length + 1);
          options.path = `/${this.apiVersion}/projects/${this.clientAdapter.getProject()}/locations/${this.clientAdapter.getLocation()}${oldPath}`;
        }
      }
      /**
       * Used as a callback for mutating the given `RequestInit` object.
       *
       * This is useful for cases where you want to add certain headers based off of
       * the request properties, e.g. `method` or `url`.
       */
      async prepareRequest(request, { url, options }) {
      }
      get(path5, opts) {
        return this.methodRequest("get", path5, opts);
      }
      post(path5, opts) {
        return this.methodRequest("post", path5, opts);
      }
      patch(path5, opts) {
        return this.methodRequest("patch", path5, opts);
      }
      put(path5, opts) {
        return this.methodRequest("put", path5, opts);
      }
      delete(path5, opts) {
        return this.methodRequest("delete", path5, opts);
      }
      methodRequest(method, path5, opts) {
        return this.request(Promise.resolve(opts).then((opts2) => {
          return Object.assign({ method, path: path5 }, opts2);
        }));
      }
      request(options, remainingRetries = null) {
        return new APIPromise(this, this.makeRequest(options, remainingRetries, void 0));
      }
      async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
        var _b, _c, _d;
        const options = await optionsInput;
        const maxRetries = (_b = options.maxRetries) !== null && _b !== void 0 ? _b : this.maxRetries;
        if (retriesRemaining == null) {
          retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url, timeout } = await this.buildRequest(options, {
          retryCount: maxRetries - retriesRemaining
        });
        await this.prepareRequest(req, { url, options });
        const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
        const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
        const startTime = Date.now();
        loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
          retryOfRequestLogID,
          method: options.method,
          url,
          options,
          headers: req.headers
        }));
        if ((_c = options.signal) === null || _c === void 0 ? void 0 : _c.aborted) {
          throw new APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
        const headersTime = Date.now();
        if (response instanceof globalThis.Error) {
          const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
          if ((_d = options.signal) === null || _d === void 0 ? void 0 : _d.aborted) {
            throw new APIUserAbortError();
          }
          const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
          if (retriesRemaining) {
            loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
            loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
              retryOfRequestLogID,
              url,
              durationMs: headersTime - startTime,
              message: response.message
            }));
            return this.retryRequest(options, retriesRemaining, retryOfRequestLogID !== null && retryOfRequestLogID !== void 0 ? retryOfRequestLogID : requestLogID);
          }
          loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
          loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
            retryOfRequestLogID,
            url,
            durationMs: headersTime - startTime,
            message: response.message
          }));
          if (isTimeout) {
            throw new APIConnectionTimeoutError();
          }
          throw new APIConnectionError({ cause: response });
        }
        const responseInfo = `[${requestLogID}${retryLogStr}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
        if (!response.ok) {
          const shouldRetry = await this.shouldRetry(response);
          if (retriesRemaining && shouldRetry) {
            const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
            await CancelReadableStream(response.body);
            loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
            loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
              retryOfRequestLogID,
              url: response.url,
              status: response.status,
              headers: response.headers,
              durationMs: headersTime - startTime
            }));
            return this.retryRequest(options, retriesRemaining, retryOfRequestLogID !== null && retryOfRequestLogID !== void 0 ? retryOfRequestLogID : requestLogID, response.headers);
          }
          const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
          loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
          const errText = await response.text().catch((err2) => castToError(err2).message);
          const errJSON = safeJSON(errText);
          const errMessage = errJSON ? void 0 : errText;
          loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
            retryOfRequestLogID,
            url: response.url,
            status: response.status,
            headers: response.headers,
            message: errMessage,
            durationMs: Date.now() - startTime
          }));
          const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
          throw err;
        }
        loggerFor(this).info(responseInfo);
        loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
      }
      async fetchWithTimeout(url, init, ms, controller) {
        const _b = init || {}, { signal, method } = _b, options = __rest(_b, ["signal", "method"]);
        if (signal)
          signal.addEventListener("abort", () => controller.abort());
        const timeout = setTimeout(() => controller.abort(), ms);
        const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
        const fetchOptions = Object.assign(Object.assign(Object.assign({ signal: controller.signal }, isReadableBody ? { duplex: "half" } : {}), { method: "GET" }), options);
        if (method) {
          fetchOptions.method = method.toUpperCase();
        }
        try {
          return await this.fetch.call(void 0, url, fetchOptions);
        } finally {
          clearTimeout(timeout);
        }
      }
      async shouldRetry(response) {
        const shouldRetryHeader = response.headers.get("x-should-retry");
        if (shouldRetryHeader === "true")
          return true;
        if (shouldRetryHeader === "false")
          return false;
        if (response.status === 408)
          return true;
        if (response.status === 409)
          return true;
        if (response.status === 429)
          return true;
        if (response.status >= 500)
          return true;
        return false;
      }
      async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
        var _b;
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders.get("retry-after-ms");
        if (retryAfterMillisHeader) {
          const timeoutMs = parseFloat(retryAfterMillisHeader);
          if (!Number.isNaN(timeoutMs)) {
            timeoutMillis = timeoutMs;
          }
        }
        const retryAfterHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders.get("retry-after");
        if (retryAfterHeader && !timeoutMillis) {
          const timeoutSeconds = parseFloat(retryAfterHeader);
          if (!Number.isNaN(timeoutSeconds)) {
            timeoutMillis = timeoutSeconds * 1e3;
          } else {
            timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
          }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
          const maxRetries = (_b = options.maxRetries) !== null && _b !== void 0 ? _b : this.maxRetries;
          timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await sleep$1(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1, requestLogID);
      }
      calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1e3;
      }
      async buildRequest(inputOptions, { retryCount = 0 } = {}) {
        var _b, _c, _d;
        const options = Object.assign({}, inputOptions);
        const { method, path: path5, query, defaultBaseURL } = options;
        const url = this.buildURL(path5, query, defaultBaseURL);
        if ("timeout" in options)
          validatePositiveInteger("timeout", options.timeout);
        options.timeout = (_b = options.timeout) !== null && _b !== void 0 ? _b : this.timeout;
        const { bodyHeaders, body } = this.buildBody({ options });
        const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
        const req = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ method, headers: reqHeaders }, options.signal && { signal: options.signal }), globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" }), body && { body }), (_c = this.fetchOptions) !== null && _c !== void 0 ? _c : {}), (_d = options.fetchOptions) !== null && _d !== void 0 ? _d : {});
        return { req, url, timeout: options.timeout };
      }
      async buildHeaders({ options, method, bodyHeaders, retryCount }) {
        let idempotencyHeaders = {};
        if (this.idempotencyHeader && method !== "get") {
          if (!options.idempotencyKey)
            options.idempotencyKey = this.defaultIdempotencyKey();
          idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
        }
        const authHeaders = await this.authHeaders(options);
        let headers = buildHeaders([
          idempotencyHeaders,
          Object.assign(Object.assign({ Accept: "application/json", "User-Agent": this.getUserAgent(), "X-Stainless-Retry-Count": String(retryCount) }, options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {}), getPlatformHeaders()),
          this._options.defaultHeaders,
          bodyHeaders,
          options.headers,
          authHeaders
        ]);
        this.validateHeaders(headers);
        return headers.values;
      }
      buildBody({ options: { body, headers: rawHeaders } }) {
        if (!body) {
          return { bodyHeaders: void 0, body: void 0 };
        }
        const headers = buildHeaders([rawHeaders]);
        if (
          // Pass raw type verbatim
          ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
          headers.values.has("content-type") || // `Blob` is superset of `File`
          globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
          body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
          body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
          globalThis.ReadableStream && body instanceof globalThis.ReadableStream
        ) {
          return { bodyHeaders: void 0, body };
        } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
          return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
        } else {
          return this.encoder({ body, headers });
        }
      }
    };
    BaseGeminiNextGenAPIClient.DEFAULT_TIMEOUT = 6e4;
    GeminiNextGenAPIClient = class extends BaseGeminiNextGenAPIClient {
      constructor() {
        super(...arguments);
        this.interactions = new Interactions(this);
      }
    };
    _a = GeminiNextGenAPIClient;
    GeminiNextGenAPIClient.GeminiNextGenAPIClient = _a;
    GeminiNextGenAPIClient.GeminiNextGenAPIClientError = GeminiNextGenAPIClientError;
    GeminiNextGenAPIClient.APIError = APIError;
    GeminiNextGenAPIClient.APIConnectionError = APIConnectionError;
    GeminiNextGenAPIClient.APIConnectionTimeoutError = APIConnectionTimeoutError;
    GeminiNextGenAPIClient.APIUserAbortError = APIUserAbortError;
    GeminiNextGenAPIClient.NotFoundError = NotFoundError;
    GeminiNextGenAPIClient.ConflictError = ConflictError;
    GeminiNextGenAPIClient.RateLimitError = RateLimitError;
    GeminiNextGenAPIClient.BadRequestError = BadRequestError;
    GeminiNextGenAPIClient.AuthenticationError = AuthenticationError;
    GeminiNextGenAPIClient.InternalServerError = InternalServerError;
    GeminiNextGenAPIClient.PermissionDeniedError = PermissionDeniedError;
    GeminiNextGenAPIClient.UnprocessableEntityError = UnprocessableEntityError;
    GeminiNextGenAPIClient.toFile = toFile;
    GeminiNextGenAPIClient.Interactions = Interactions;
    Tunings = class extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = async (params = {}) => {
          return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);
        };
        this.get = async (params) => {
          return await this.getInternal(params);
        };
        this.tune = async (params) => {
          var _a2;
          if (this.apiClient.isVertexAI()) {
            if (params.baseModel.startsWith("projects/")) {
              const preTunedModel = {
                tunedModelName: params.baseModel
              };
              if ((_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.preTunedModelCheckpointId) {
                preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;
              }
              const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel });
              paramsPrivate.baseModel = void 0;
              return await this.tuneInternal(paramsPrivate);
            } else {
              const paramsPrivate = Object.assign({}, params);
              return await this.tuneInternal(paramsPrivate);
            }
          } else {
            const paramsPrivate = Object.assign({}, params);
            const operation = await this.tuneMldevInternal(paramsPrivate);
            let tunedModelName = "";
            if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) {
              tunedModelName = operation["metadata"]["tunedModel"];
            } else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) {
              tunedModelName = operation["name"].split("/operations/")[0];
            }
            const tuningJob = {
              name: tunedModelName,
              state: JobState.JOB_STATE_QUEUED
            };
            return tuningJob;
          }
        };
      }
      async getInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = getTuningJobParametersToVertex(params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = tuningJobFromVertex(apiResponse);
            return resp;
          });
        } else {
          const body = getTuningJobParametersToMldev(params);
          path5 = formatMap("{name}", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = tuningJobFromMldev(apiResponse);
            return resp;
          });
        }
      }
      async listInternal(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = listTuningJobsParametersToVertex(params);
          path5 = formatMap("tuningJobs", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = listTuningJobsResponseFromVertex(apiResponse);
            const typedResp = new ListTuningJobsResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = listTuningJobsParametersToMldev(params);
          path5 = formatMap("tunedModels", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "GET",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = listTuningJobsResponseFromMldev(apiResponse);
            const typedResp = new ListTuningJobsResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      /**
       * Cancels a tuning job.
       *
       * @param params - The parameters for the cancel request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.
       * ```
       */
      async cancel(params) {
        var _a2, _b, _c, _d;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = cancelTuningJobParametersToVertex(params);
          path5 = formatMap("{name}:cancel", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = cancelTuningJobResponseFromVertex(apiResponse);
            const typedResp = new CancelTuningJobResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        } else {
          const body = cancelTuningJobParametersToMldev(params);
          path5 = formatMap("{name}:cancel", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
            abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = cancelTuningJobResponseFromMldev(apiResponse);
            const typedResp = new CancelTuningJobResponse();
            Object.assign(typedResp, resp);
            return typedResp;
          });
        }
      }
      async tuneInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          const body = createTuningJobParametersPrivateToVertex(params, params);
          path5 = formatMap("tuningJobs", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = tuningJobFromVertex(apiResponse);
            return resp;
          });
        } else {
          throw new Error("This method is only supported by the Vertex AI.");
        }
      }
      async tuneMldevInternal(params) {
        var _a2, _b;
        let response;
        let path5 = "";
        let queryParams = {};
        if (this.apiClient.isVertexAI()) {
          throw new Error("This method is only supported by the Gemini Developer API.");
        } else {
          const body = createTuningJobParametersPrivateToMldev(params);
          path5 = formatMap("tunedModels", body["_url"]);
          queryParams = body["_query"];
          delete body["_url"];
          delete body["_query"];
          response = this.apiClient.request({
            path: path5,
            queryParams,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions: (_a2 = params.config) === null || _a2 === void 0 ? void 0 : _a2.httpOptions,
            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
          }).then((httpResponse) => {
            return httpResponse.json().then((jsonResponse) => {
              const response2 = jsonResponse;
              response2.sdkHttpResponse = {
                headers: httpResponse.headers
              };
              return response2;
            });
          });
          return response.then((apiResponse) => {
            const resp = tuningOperationFromMldev(apiResponse);
            return resp;
          });
        }
      }
    };
    BrowserDownloader = class {
      async download(_params, _apiClient) {
        throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
      }
    };
    MAX_CHUNK_SIZE = 1024 * 1024 * 8;
    MAX_RETRY_COUNT = 3;
    INITIAL_RETRY_DELAY_MS = 1e3;
    DELAY_MULTIPLIER = 2;
    X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
    BrowserUploader = class {
      async upload(file, uploadUrl, apiClient) {
        if (typeof file === "string") {
          throw new Error("File path is not supported in browser uploader.");
        }
        return await uploadBlob(file, uploadUrl, apiClient);
      }
      async uploadToFileSearchStore(file, uploadUrl, apiClient) {
        if (typeof file === "string") {
          throw new Error("File path is not supported in browser uploader.");
        }
        return await uploadBlobToFileSearchStore(file, uploadUrl, apiClient);
      }
      async stat(file) {
        if (typeof file === "string") {
          throw new Error("File path is not supported in browser uploader.");
        } else {
          return await getBlobStat(file);
        }
      }
    };
    BrowserWebSocketFactory = class {
      create(url, headers, callbacks) {
        return new BrowserWebSocket(url, headers, callbacks);
      }
    };
    BrowserWebSocket = class {
      constructor(url, headers, callbacks) {
        this.url = url;
        this.headers = headers;
        this.callbacks = callbacks;
      }
      connect() {
        this.ws = new WebSocket(this.url);
        this.ws.onopen = this.callbacks.onopen;
        this.ws.onerror = this.callbacks.onerror;
        this.ws.onclose = this.callbacks.onclose;
        this.ws.onmessage = this.callbacks.onmessage;
      }
      send(message) {
        if (this.ws === void 0) {
          throw new Error("WebSocket is not connected");
        }
        this.ws.send(message);
      }
      close() {
        if (this.ws === void 0) {
          throw new Error("WebSocket is not connected");
        }
        this.ws.close();
      }
    };
    GOOGLE_API_KEY_HEADER = "x-goog-api-key";
    WebAuth = class {
      constructor(apiKey) {
        this.apiKey = apiKey;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async addAuthHeaders(headers, url) {
        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
          return;
        }
        if (this.apiKey.startsWith("auth_tokens/")) {
          throw new Error("Ephemeral tokens are only supported by the live API.");
        }
        if (!this.apiKey) {
          throw new Error("API key is missing. Please provide a valid API key.");
        }
        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
      }
    };
    LANGUAGE_LABEL_PREFIX = "gl-node/";
    GoogleGenAI = class {
      get interactions() {
        if (this._interactions !== void 0) {
          return this._interactions;
        }
        console.warn("GoogleGenAI.interactions: Interactions usage is experimental and may change in future versions.");
        const httpOpts = this.httpOptions;
        if (httpOpts === null || httpOpts === void 0 ? void 0 : httpOpts.extraBody) {
          console.warn("GoogleGenAI.interactions: Client level httpOptions.extraBody is not supported by the interactions client and will be ignored.");
        }
        const nextGenClient = new GeminiNextGenAPIClient({
          baseURL: this.apiClient.getBaseUrl(),
          apiKey: this.apiKey,
          apiVersion: this.apiClient.getApiVersion(),
          clientAdapter: this.apiClient,
          defaultHeaders: this.apiClient.getDefaultHeaders(),
          timeout: httpOpts === null || httpOpts === void 0 ? void 0 : httpOpts.timeout
        });
        this._interactions = nextGenClient.interactions;
        return this._interactions;
      }
      constructor(options) {
        var _a2;
        if (options.apiKey == null) {
          throw new Error("An API Key must be set when running in a browser");
        }
        if (options.project || options.location) {
          throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
        }
        this.vertexai = (_a2 = options.vertexai) !== null && _a2 !== void 0 ? _a2 : false;
        this.apiKey = options.apiKey;
        const baseUrl = getBaseUrl(
          options.httpOptions,
          options.vertexai,
          /*vertexBaseUrlFromEnv*/
          void 0,
          /*geminiBaseUrlFromEnv*/
          void 0
        );
        if (baseUrl) {
          if (options.httpOptions) {
            options.httpOptions.baseUrl = baseUrl;
          } else {
            options.httpOptions = { baseUrl };
          }
        }
        this.apiVersion = options.apiVersion;
        this.httpOptions = options.httpOptions;
        const auth = new WebAuth(this.apiKey);
        this.apiClient = new ApiClient({
          auth,
          apiVersion: this.apiVersion,
          apiKey: this.apiKey,
          vertexai: this.vertexai,
          httpOptions: this.httpOptions,
          userAgentExtra: LANGUAGE_LABEL_PREFIX + "web",
          uploader: new BrowserUploader(),
          downloader: new BrowserDownloader()
        });
        this.models = new Models(this.apiClient);
        this.live = new Live(this.apiClient, auth, new BrowserWebSocketFactory());
        this.batches = new Batches(this.apiClient);
        this.chats = new Chats(this.models, this.apiClient);
        this.caches = new Caches(this.apiClient);
        this.files = new Files(this.apiClient);
        this.operations = new Operations(this.apiClient);
        this.authTokens = new Tokens(this.apiClient);
        this.tunings = new Tunings(this.apiClient);
        this.fileSearchStores = new FileSearchStores(this.apiClient);
      }
    };
  }
});

// ../../libs/core-ts/dist/Adapters/GoogleGeminiAdapter/GoogleGeminiAdapter.js
var require_GoogleGeminiAdapter = __commonJS({
  "../../libs/core-ts/dist/Adapters/GoogleGeminiAdapter/GoogleGeminiAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoogleGeminiAdapter = void 0;
    var genai_1 = (init_web(), __toCommonJS(web_exports));
    var GEMINI_MODEL_NAME = "gemini-2.5-flash";
    var GEMINI_JSON_GENERATION_CONFIG = {
      temperature: 0.4,
      // maxOutputTokens: 10000,
      responseMimeType: "application/json"
    };
    var GEMINI_SUMMARY_GENERATION_CONFIG = {
      temperature: 0.35
    };
    var GoogleGeminiAdapter2 = class {
      constructor(apiKey) {
        this.cachedGeminiClient = null;
        this.apiKey = apiKey.trim();
      }
      /**
       * Requests content enrichment based on a prompt, expecting a structured response with body and frontmatter.
       *
       * @param params - The parameters for the LLM request, including the prompt.
       * @returns A promise that resolves to an `LlmResponse` object containing the generated body and frontmatter, or `null` if the request fails or parsing errors occur.
       */
      async requestEnrichment(params) {
        const { prompt } = params;
        console.log("Prompt:", prompt);
        const rawText = await this.generate(prompt, GEMINI_JSON_GENERATION_CONFIG, "completar la plantilla autom\xE1ticamente");
        if (!rawText)
          return null;
        const cleanText = this.cleanResponse(rawText);
        let parsed;
        try {
          parsed = JSON.parse(cleanText);
        } catch (parseError) {
          console.error("Gemini response could not be parsed as JSON", cleanText, parseError);
          return null;
        }
        if (!parsed || typeof parsed !== "object") {
          return null;
        }
        const parsedRecord = parsed;
        const body = typeof parsedRecord.body === "string" ? parsedRecord.body.trim() : void 0;
        const frontmatterValue = parsedRecord.frontmatter;
        const frontmatter = frontmatterValue && typeof frontmatterValue === "object" && !Array.isArray(frontmatterValue) ? frontmatterValue : void 0;
        return {
          body,
          frontmatter
        };
      }
      /**
       * Sends a general request to the LLM and returns the response as a string.
       *
       * @param params - The parameters for the LLM request, including the prompt.
       * @returns A promise that resolves to the generated text content, or `null` if the request fails.
       */
      async request(params) {
        const { prompt } = params;
        return this.generate(prompt, GEMINI_SUMMARY_GENERATION_CONFIG);
      }
      /**
       * Sends a request to the LLM expecting a JSON response.
       *
       * @param params - The parameters for the LLM request, including the prompt.
       * @returns A promise that resolves to the parsed JSON object, or `null` if the request fails or parsing errors occur.
       */
      async requestJson(params) {
        const { prompt } = params;
        const rawText = await this.generate(prompt, GEMINI_JSON_GENERATION_CONFIG);
        if (!rawText)
          return null;
        const cleanText = this.cleanResponse(rawText);
        try {
          return JSON.parse(cleanText);
        } catch (parseError) {
          console.error("Gemini response could not be parsed as JSON", cleanText, parseError);
          return null;
        }
      }
      /**
       * Requests a brief summary of a streaming session.
       *
       * @param params - The parameters for the LLM request, including the prompt.
       * @returns A promise that resolves to the generated summary text, or `null` if the request fails.
       */
      async requestStreamBrief(params) {
        const { prompt } = params;
        return this.generate(prompt, GEMINI_SUMMARY_GENERATION_CONFIG, "resumir el streaming");
      }
      /**
       * Internal method to handle the common logic for generating content from the Gemini API.
       *
       * @param prompt - The input prompt for the model.
       * @param config - The configuration object for the generation (e.g., temperature, mimeType).
       * @param errorContext - Optional context description for error messages (used to customize the API key missing message).
       * @returns A promise that resolves to the generated text, or `null` if the request fails.
       */
      async generate(prompt, config, errorContext) {
        if (!this.apiKey) {
          const msg = errorContext ? `Configura tu clave de la API de Gemini en los ajustes para ${errorContext}.` : "Configura tu clave de la API de Gemini en los ajustes.";
          console.warn("[GoogleGeminiAdapter] Missing API Key:", msg);
          return null;
        }
        try {
          const client = this.getGeminiClient();
          const response = await client.models.generateContent({
            model: GEMINI_MODEL_NAME,
            contents: [
              {
                role: "user",
                parts: [
                  {
                    text: prompt
                  }
                ]
              }
            ],
            config
          });
          console.log("[GoogleGeminiAdapter] Response received from Gemini.");
          const rawText = this.extractText(response).trim();
          return rawText || null;
        } catch (error) {
          console.error("Failed to request Gemini", error);
          console.error("Gemini error details:", error);
          return null;
        }
      }
      /**
       * Lazily initializes and retrieves the Gemini client instance.
       *
       * @returns The initialized `GoogleGenAI` client.
       */
      getGeminiClient() {
        if (this.cachedGeminiClient) {
          return this.cachedGeminiClient;
        }
        this.cachedGeminiClient = new genai_1.GoogleGenAI({ apiKey: this.apiKey });
        return this.cachedGeminiClient;
      }
      /**
       * Extracts the text content from the Gemini API response.
       *
       * @param response - The response object from the Gemini API.
       * @returns The extracted text content, or an empty string if no content is found.
       */
      extractText(response) {
        var _a2, _b;
        const viaGetter = typeof response.text === "string" ? response.text.trim() : "";
        if (viaGetter) {
          return viaGetter;
        }
        const candidates = response.candidates;
        if (!Array.isArray(candidates) || candidates.length === 0) {
          return "";
        }
        const parts = (_b = (_a2 = candidates[0]) == null ? void 0 : _a2.content) == null ? void 0 : _b.parts;
        if (!Array.isArray(parts)) {
          return "";
        }
        return parts.map((part) => typeof part.text === "string" ? part.text : "").join("").trim();
      }
      /**
       * Cleans the response text by removing Markdown code fences or extracting logic from JSON-like structures.
       *
       * @param text - The raw text response from the LLM.
       * @returns The cleaned text content.
       */
      cleanResponse(text) {
        const fenceMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
        if (fenceMatch) {
          return fenceMatch[1].trim();
        }
        const firstBrace = text.indexOf("{");
        const lastBrace = text.lastIndexOf("}");
        const firstBracket = text.indexOf("[");
        const lastBracket = text.lastIndexOf("]");
        let start = -1;
        let end = -1;
        if (firstBrace !== -1 && (firstBracket === -1 || firstBrace < firstBracket)) {
          start = firstBrace;
          end = lastBrace;
        } else if (firstBracket !== -1) {
          start = firstBracket;
          end = lastBracket;
        }
        if (start !== -1 && end !== -1 && end > start) {
          return text.substring(start, end + 1);
        }
        return text;
      }
    };
    exports.GoogleGeminiAdapter = GoogleGeminiAdapter2;
  }
});

// ../../libs/core-ts/dist/Adapters/GoogleGeminiAdapter/GoogleGeminiImagesAdapter.js
var require_GoogleGeminiImagesAdapter = __commonJS({
  "../../libs/core-ts/dist/Adapters/GoogleGeminiAdapter/GoogleGeminiImagesAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoogleGeminiImagesAdapter = void 0;
    var genai_1 = (init_web(), __toCommonJS(web_exports));
    var GEMINI_MODEL_NAME = "gemini-2.0-flash-exp";
    var GoogleGeminiImagesAdapter2 = class {
      constructor(apiKey) {
        this.client = null;
        this.apiKey = apiKey.trim();
      }
      getClient() {
        if (!this.client) {
          this.client = new genai_1.GoogleGenAI({ apiKey: this.apiKey });
        }
        return this.client;
      }
      async generateContentFromImages(images, additionalPrompt = "") {
        if (!this.apiKey) {
          console.warn("[GoogleGeminiImagesAdapter] Configura tu clave de API de Gemini.");
          return null;
        }
        try {
          const client = this.getClient();
          const prompt = `
        Analiza las siguientes im\xE1genes que corresponden a lecciones de libros de texto.
        ${additionalPrompt}
        
        Instrucciones:
        1. Primero transcribe el texto literalmente de todas las im\xE1genes en orden.
        2. Luego analiza el contenido en profundidad.
        
        Sigue estrictamente el esquema JSON proporcionado.
      `;
          const responseSchema = {
            type: "OBJECT",
            properties: {
              literal_transcription: {
                type: "STRING",
                description: "Transcripci\xF3n literal y completa del texto visible en las im\xE1genes en formato markdown que refleje la jerarquiza de titulos y subtitulos lo mas fiel posible al original, utilizando las marcas '#', '##', '###', .... hasta el subnivel que sea necesario. Si salen imagenes de objetos sueltos en alg\xFAn ejercicio, pon el nombre de lo que reconozcas entre []."
              },
              analysis: {
                type: "STRING",
                description: "An\xE1lisis detallado, resumen y explicaci\xF3n de los conceptos clave presentados en el texto."
              }
            },
            required: ["literal_transcription", "analysis"]
          };
          const contents = [
            {
              role: "user",
              parts: [
                { text: prompt },
                ...images.map((img) => ({
                  inlineData: {
                    data: img.data,
                    mimeType: img.mimeType
                  }
                }))
              ]
            }
          ];
          const response = await client.models.generateContent({
            model: GEMINI_MODEL_NAME,
            contents,
            config: {
              responseMimeType: "application/json",
              responseSchema
            }
          });
          const text = response.text;
          if (!text)
            return null;
          const result = JSON.parse(text);
          return result;
        } catch (error) {
          console.error("Error calling Gemini Vision:", error);
          return null;
        }
      }
      async generateEnrichmentFromImages(images, promptTemplate) {
        if (!this.apiKey) {
          console.warn("[GoogleGeminiImagesAdapter] Configura tu clave de API de Gemini.");
          return null;
        }
        try {
          const client = this.getClient();
          const prompt = `
        ${promptTemplate}
        
        Analiza las im\xE1genes proporcionadas y utiliza su contenido para cumplir con la solicitud.
        Genera una respuesta en formato JSON con los siguientes campos opcionales:
        - "body": El contenido principal de la nota (texto markdown).
        - "frontmatter": Un objeto con metadatos para la nota.
        
        Responde SOLAMENTE con el JSON v\xE1lido.
      `;
          const responseSchema = {
            type: "OBJECT",
            properties: {
              body: {
                type: "STRING",
                description: "Contenido principal de la nota en Markdown."
              },
              frontmatter: {
                type: "OBJECT",
                description: "Metadatos Key-Value para el frontmatter.",
                nullable: true
              }
            },
            required: ["body"]
            // Require at least body, frontmatter optional
          };
          const contents = [
            {
              role: "user",
              parts: [
                { text: prompt },
                ...images.map((img) => ({
                  inlineData: {
                    data: img.data,
                    mimeType: img.mimeType
                  }
                }))
              ]
            }
          ];
          const response = await client.models.generateContent({
            model: GEMINI_MODEL_NAME,
            contents,
            config: {
              responseMimeType: "application/json",
              responseSchema
            }
          });
          const text = response.text;
          if (!text)
            return null;
          return JSON.parse(text);
        } catch (error) {
          console.error("Error calling Gemini Vision Enrichment:", error);
          return null;
        }
      }
    };
    exports.GoogleGeminiImagesAdapter = GoogleGeminiImagesAdapter2;
  }
});

// ../../libs/core-ts/dist/Adapters/GoogleGeminiLiveAdapter/GoogleGeminiChatAdapter.js
var require_GoogleGeminiChatAdapter = __commonJS({
  "../../libs/core-ts/dist/Adapters/GoogleGeminiLiveAdapter/GoogleGeminiChatAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoogleGeminiChatAdapter = void 0;
    var genai_1 = (init_web(), __toCommonJS(web_exports));
    var GoogleGeminiChatAdapter2 = class {
      constructor(apiKey, onTextReceived, onScoreReceived, onUserTextReceived) {
        this.history = [];
        this.systemInstruction = "";
        this.modelName = "gemini-2.0-flash-exp";
        this.config = {};
        this.apiKey = apiKey;
        this.onTextReceived = onTextReceived || (() => {
        });
        this.onScoreReceived = onScoreReceived || (() => {
        });
        this.onUserTextReceived = onUserTextReceived || (() => {
        });
        this.client = new genai_1.GoogleGenAI({ apiKey: this.apiKey });
      }
      async connect(systemInstruction, enableScoreTracking, voice, temperature, topP) {
        if (!this.apiKey) {
          console.error("Falta la API Key de Gemini");
          return false;
        }
        this.history = [];
        this.config = {
          temperature,
          topP
        };
        this.tools = [];
        if (enableScoreTracking) {
          this.tools.push({
            functionDeclarations: [
              {
                name: "report_score",
                description: "Report the score of the user's answer effectiveness.",
                parameters: {
                  type: "OBJECT",
                  properties: {
                    score: {
                      type: "INTEGER",
                      description: "The score of the answer from 0 to 10."
                    }
                  },
                  required: ["score"]
                }
              }
            ]
          });
        }
        this.systemInstruction = systemInstruction;
        if (enableScoreTracking) {
          this.systemInstruction += `

IMPORTANT: You are configured to track the user's answer quality. When the user answers, you MUST evaluate it and call the "report_score" function with a score from 0 to 10.`;
        }
        console.log("Gemini Chat (Text) Connected");
        return true;
      }
      disconnect() {
        this.history = [];
      }
      async sendText(text) {
        try {
          this.history.push({ role: "user", parts: [{ text }] });
          await this.generateResponse();
        } catch (e) {
          console.error("Error sending text to Gemini Chat", e);
          console.error("Error al enviar mensaje (Chat)");
        }
      }
      async generateResponse() {
        var _a2;
        console.log("Gemini Chat: generateResponse started. History length:", this.history.length);
        try {
          const req = {
            model: this.modelName,
            contents: this.history,
            config: {
              ...this.config,
              systemInstruction: { parts: [{ text: this.systemInstruction }] }
            }
          };
          if (this.tools && this.tools.length > 0) {
            req.config.tools = this.tools;
          }
          const stream = await this.client.models.generateContentStream(req);
          let fullText = "";
          let functionCalls = [];
          for await (const chunk of stream) {
            const candidates = chunk.candidates;
            if (!candidates || candidates.length === 0)
              continue;
            const parts = (_a2 = candidates[0].content) == null ? void 0 : _a2.parts;
            if (!parts)
              continue;
            for (const part of parts) {
              if (part.text) {
                const text = part.text;
                this.onTextReceived(text);
                fullText += text;
              }
              if (part.functionCall) {
                functionCalls.push(part.functionCall);
                const call = part.functionCall;
                if (call.name === "report_score") {
                  const args = call.args;
                  console.log("Gemini Chat: report_score called", args);
                  if (args && args.score !== void 0) {
                    let score = args.score;
                    if (typeof score === "string")
                      score = parseInt(score, 10);
                    if (!isNaN(score)) {
                      this.onScoreReceived(score);
                    }
                  }
                }
              }
            }
          }
          const modelParts = [];
          if (fullText) {
            modelParts.push({ text: fullText });
          }
          if (functionCalls.length > 0) {
            functionCalls.forEach((call) => modelParts.push({ functionCall: call }));
          }
          if (modelParts.length > 0) {
            this.history.push({ role: "model", parts: modelParts });
          }
          if (functionCalls.length > 0) {
            console.log(`Gemini Chat: Found ${functionCalls.length} function calls. Processing...`);
            for (const call of functionCalls) {
              console.log(`Gemini Chat: Sending response for ${call.name}`);
              await this.sendFunctionResponse(call.name, call.id, { result: "ok" });
            }
          } else {
            console.log("Gemini Chat: No function calls found in this turn.");
          }
        } catch (e) {
          console.error("Error generating response", e);
          console.error(`Gemini Chat Error: ${e}`);
        }
      }
      sendContextUpdate(fileName, content) {
        const updateMsg = `SYSTEM UPDATE from ${fileName}:
${content}`;
        this.sendText(updateMsg);
      }
      async sendFunctionResponse(name, id, response) {
        this.history.push({
          role: "function",
          parts: [{
            functionResponse: {
              name,
              response
            }
          }]
        });
        await this.generateResponse();
      }
      // Audio methods - No-op
      async resumeAudio() {
      }
    };
    exports.GoogleGeminiChatAdapter = GoogleGeminiChatAdapter2;
  }
});

// ../../libs/core-ts/dist/Adapters/GoogleGeminiLiveAdapter/IGeminiSessionAdapter.js
var require_IGeminiSessionAdapter = __commonJS({
  "../../libs/core-ts/dist/Adapters/GoogleGeminiLiveAdapter/IGeminiSessionAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/ContextProviderPort.js
var require_ContextProviderPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/ContextProviderPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/GeocodingPort.js
var require_GeocodingPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/GeocodingPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/HeaderDataPort.js
var require_HeaderDataPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/HeaderDataPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/ImageSearchPort.js
var require_ImageSearchPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/ImageSearchPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/LlmPort.js
var require_LlmPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/LlmPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/MetadataPort.js
var require_MetadataPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/MetadataPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/MusicProviderPort.js
var require_MusicProviderPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/MusicProviderPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/NoteManagerPort.js
var require_NoteManagerPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/NoteManagerPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/RoleRepositoryPort.js
var require_RoleRepositoryPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/RoleRepositoryPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/SettingsPort.js
var require_SettingsPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/SettingsPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/TranscriptionPort.js
var require_TranscriptionPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/TranscriptionPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Ports/YouTubeTranscriptPort.js
var require_YouTubeTranscriptPort = __commonJS({
  "../../libs/core-ts/dist/Domain/Ports/YouTubeTranscriptPort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Constants/CommandIds.js
var require_CommandIds = __commonJS({
  "../../libs/core-ts/dist/Domain/Constants/CommandIds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommandEnum = void 0;
    var CommandEnum4;
    (function(CommandEnum5) {
      CommandEnum5["ApplyTemplate"] = "ApplyTemplateCommand";
      CommandEnum5["ApplyTemplateWithUrl"] = "ApplyTemplateWithUrlCommand";
      CommandEnum5["ApplyStreamBrief"] = "ApplyStreamBriefCommand";
      CommandEnum5["EnhanceByAi"] = "EnhanceByAiCommand";
      CommandEnum5["AddImages"] = "AddImagesCommand";
      CommandEnum5["CreateNoteFromImages"] = "CreateNoteFromImagesCommand";
      CommandEnum5["ApplyTemplateFromImage"] = "ApplyTemplateFromImageCommand";
      CommandEnum5["GenerateHeaderMetadata"] = "generate-header-metadata";
      CommandEnum5["RelocateNoteByLinkField"] = "RelocateNoteByLinkFieldCommand";
      CommandEnum5["GenerateMissingNotesFromLinks"] = "GenerateMissingNotesFromLinksCommand";
      CommandEnum5["CreateReciprocityLinksNotes"] = "CreateReciprocityLinksNotesCommand";
      CommandEnum5["AnalyzeAndLinkEntities"] = "AnalyzeAndLinkEntitiesCommand";
      CommandEnum5["GenerateMissingNotesFromListField"] = "GenerateMissingNotesFromListFieldCommand";
      CommandEnum5["EnrichPlace"] = "EnrichPlaceCommand";
      CommandEnum5["RelocatePlaceNote"] = "RelocatePlaceNoteCommand";
      CommandEnum5["AddPlaceIdFromUrl"] = "AddPlaceIdFromUrlCommand";
      CommandEnum5["SearchSpotifyTrack"] = "SearchSpotifyTrack";
      CommandEnum5["ImportPlaylistTracks"] = "ImportPlaylistTracks";
      CommandEnum5["SearchSpotifyArtist"] = "SearchSpotifyArtistCommand";
      CommandEnum5["InsertLinkToSelectedPhoto"] = "InsertLinkToSelectedPhotoCommand";
      CommandEnum5["OpenLinkedPhoto"] = "OpenLinkedPhotoCommand";
      CommandEnum5["EnrichWithPromptUrl"] = "EnrichWithPromptUrlCommand";
      CommandEnum5["SyncContacts"] = "SyncContactsCommand";
      CommandEnum5["ToggleHideEmptyProperties"] = "ToggleHideEmptyProperties";
      CommandEnum5["TokenizeAndCreateDictionaryNotes"] = "TokenizeAndCreateDictionaryNotesCommand";
    })(CommandEnum4 || (exports.CommandEnum = CommandEnum4 = {}));
  }
});

// ../../libs/core-ts/dist/Domain/Constants/FrontmatterRegistry.js
var require_FrontmatterRegistry = __commonJS({
  "../../libs/core-ts/dist/Domain/Constants/FrontmatterRegistry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FrontmatterRegistry = exports.FrontmatterKeys = void 0;
    var CommandIds_1 = require_CommandIds();
    exports.FrontmatterKeys = {
      EloCommands: "!!commands",
      EloPrompt: "!!prompt",
      EloPromptUrl: "!!promptUrl",
      EloImages: "!!images",
      EloAppleContactId: "!!appleContactId",
      Municipio: "Municipio",
      Provincia: "Provincia",
      LugarId: "Lugar Id",
      Region: "Regi\xF3n",
      Pais: "Pa\xEDs",
      Paises: "Pa\xEDses",
      Lugares: "Lugares",
      Lugar: "Lugar",
      SedePrincipal: "Sede principal",
      Latitud: "Latitud",
      Longitud: "Longitud",
      Url: "Url",
      SpotifyUri: "Spotify uri",
      Capital: "Capital",
      Tags: "tags",
      Conocidos: "Conocidos",
      Hijos: "Hijos",
      Padres: "Padres",
      Pareja: "Pareja",
      Exparejas: "Exparejas",
      Hermanos: "Hermanos",
      Familiares: "Familiares",
      CompanerosTrabajo: "Compa\xF1eros de trabajo",
      Jefes: "Jefes",
      Empleados: "Empleados",
      EstilosMusicales: "Estilos musicales",
      SpotifyPopularity: "Spotify popularidad",
      Telefono: "Tel\xE9fono",
      Email: "Email",
      Cumpleanos: "Cumplea\xF1os",
      Apodo: "Apodo",
      Puesto: "Puesto de trabajo",
      Empresa: "Empresa",
      Direcciones: "Direcciones",
      Urls: "Urls",
      Eventos: "Eventos",
      Relaciones: "Relaciones",
      Genero: "G\xE9nero",
      Ocupaciones: "Ocupaciones",
      Intereses: "Intereses",
      Habilidades: "Habilidades",
      Residencias: "Residencias"
    };
    exports.FrontmatterRegistry = {
      // Internal fields:
      [exports.FrontmatterKeys.EloCommands]: {
        key: exports.FrontmatterKeys.EloCommands,
        description: "Comandos adicionales para la IA",
        type: "array"
      },
      [exports.FrontmatterKeys.EloPrompt]: {
        key: exports.FrontmatterKeys.EloPrompt,
        description: "Prompt personalizado para la IA",
        type: "string"
      },
      [exports.FrontmatterKeys.EloPromptUrl]: {
        key: exports.FrontmatterKeys.EloPromptUrl,
        description: "URL de contexto para el prompt",
        type: "string"
      },
      // User fields:
      [exports.FrontmatterKeys.Municipio]: {
        key: exports.FrontmatterKeys.Municipio,
        description: "Nombre del municipio, ciudad o pueblo",
        type: "string",
        asLink: true
      },
      [exports.FrontmatterKeys.Provincia]: {
        key: exports.FrontmatterKeys.Provincia,
        description: "Nombre de la provincia administrativa",
        type: "string",
        asLink: true
      },
      [exports.FrontmatterKeys.Region]: {
        key: exports.FrontmatterKeys.Region,
        description: "Comunidad aut\xF3noma o regi\xF3n",
        type: "string",
        asLink: true
      },
      [exports.FrontmatterKeys.Pais]: {
        key: exports.FrontmatterKeys.Pais,
        description: "Pa\xEDs",
        type: "string",
        isRelocateField: true,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.RelocateNoteByLinkField]
      },
      [exports.FrontmatterKeys.Paises]: {
        key: exports.FrontmatterKeys.Paises,
        description: "Pa\xEDses",
        type: "array",
        isRelocateField: true,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.RelocateNoteByLinkField]
      },
      [exports.FrontmatterKeys.LugarId]: {
        key: exports.FrontmatterKeys.LugarId,
        description: "Identificador \xFAnico del lugar (ej. Google Place ID)",
        type: "string",
        commands: [CommandIds_1.CommandEnum.RelocateNoteByLinkField]
      },
      [exports.FrontmatterKeys.Lugar]: {
        key: exports.FrontmatterKeys.Lugar,
        description: "Lugar relacionado",
        type: "string",
        isRelocateField: true,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.RelocateNoteByLinkField]
      },
      [exports.FrontmatterKeys.Lugares]: {
        key: exports.FrontmatterKeys.Lugares,
        description: "Lugares relacionados",
        type: "array",
        isRelocateField: true,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.RelocateNoteByLinkField]
      },
      [exports.FrontmatterKeys.SedePrincipal]: {
        key: exports.FrontmatterKeys.SedePrincipal,
        description: "Sede principal",
        isRelocateField: true,
        type: "string",
        asLink: true
      },
      [exports.FrontmatterKeys.Latitud]: {
        key: exports.FrontmatterKeys.Latitud,
        description: "Coordenada de latitud geogr\xE1fica",
        type: "number"
      },
      [exports.FrontmatterKeys.Longitud]: {
        key: exports.FrontmatterKeys.Longitud,
        description: "Coordenada de longitud geogr\xE1fica",
        type: "number"
      },
      [exports.FrontmatterKeys.Url]: {
        key: exports.FrontmatterKeys.Url,
        description: "URL de la web, video, streaming, ...",
        type: "string"
      },
      [exports.FrontmatterKeys.SpotifyUri]: {
        key: exports.FrontmatterKeys.SpotifyUri,
        description: "URI de Spotify",
        type: "string"
      },
      [exports.FrontmatterKeys.Capital]: {
        key: exports.FrontmatterKeys.Capital,
        description: "Capital del pa\xEDs (si aplica)",
        type: "string",
        asLink: true
      },
      [exports.FrontmatterKeys.Tags]: {
        key: exports.FrontmatterKeys.Tags,
        description: "Etiquetas",
        type: "array"
      },
      [exports.FrontmatterKeys.Conocidos]: {
        key: exports.FrontmatterKeys.Conocidos,
        description: "Lista de conocidos",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.Conocidos,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.Hijos]: {
        key: exports.FrontmatterKeys.Hijos,
        description: "Hijos de la persona",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.Padres,
        amongField: exports.FrontmatterKeys.Hermanos,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.Padres]: {
        key: exports.FrontmatterKeys.Padres,
        description: "Padres de la persona",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.Hijos,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.Pareja]: {
        key: exports.FrontmatterKeys.Pareja,
        description: "Pareja actual",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.Pareja,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.Exparejas]: {
        key: exports.FrontmatterKeys.Exparejas,
        description: "Exparejas",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.Exparejas,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.Hermanos]: {
        key: exports.FrontmatterKeys.Hermanos,
        description: "Hermanos",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.Hermanos,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.Familiares]: {
        key: exports.FrontmatterKeys.Familiares,
        description: "Otros familiares",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.Familiares,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.CompanerosTrabajo]: {
        key: exports.FrontmatterKeys.CompanerosTrabajo,
        description: "Compa\xF1eros de trabajo",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.CompanerosTrabajo,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.Jefes]: {
        key: exports.FrontmatterKeys.Jefes,
        description: "Jefes directos",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.Empleados,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.Empleados]: {
        key: exports.FrontmatterKeys.Empleados,
        description: "Empleados a cargo",
        type: "array",
        reciprocityField: exports.FrontmatterKeys.Jefes,
        asLink: true,
        commands: [CommandIds_1.CommandEnum.CreateReciprocityLinksNotes]
      },
      [exports.FrontmatterKeys.EstilosMusicales]: {
        key: exports.FrontmatterKeys.EstilosMusicales,
        description: "Estilos musicales del artista",
        type: "array"
      },
      [exports.FrontmatterKeys.SpotifyPopularity]: {
        key: exports.FrontmatterKeys.SpotifyPopularity,
        description: "Popularidad del artista en Spotify (0-100)",
        type: "number"
      },
      [exports.FrontmatterKeys.EloImages]: {
        key: exports.FrontmatterKeys.EloImages,
        description: "Lista de fotos enlazadas (elo-bridge)",
        type: "array"
      },
      [exports.FrontmatterKeys.Telefono]: {
        key: exports.FrontmatterKeys.Telefono,
        description: "Tel\xE9fono de contacto",
        type: "string"
      },
      [exports.FrontmatterKeys.Email]: {
        key: exports.FrontmatterKeys.Email,
        description: "Email de contacto",
        type: "string"
      },
      [exports.FrontmatterKeys.Cumpleanos]: {
        key: exports.FrontmatterKeys.Cumpleanos,
        description: "Cumplea\xF1os (YYYY-MM-DD)",
        type: "date"
      },
      [exports.FrontmatterKeys.EloAppleContactId]: {
        key: exports.FrontmatterKeys.EloAppleContactId,
        description: "ID de contacto en Apple (elo-bridge)",
        type: "string"
      },
      [exports.FrontmatterKeys.Apodo]: {
        key: exports.FrontmatterKeys.Apodo,
        description: "Apodo o nombre corto",
        type: "string"
      },
      [exports.FrontmatterKeys.Puesto]: {
        key: exports.FrontmatterKeys.Puesto,
        description: "Puesto de trabajo o cargo",
        type: "string"
      },
      [exports.FrontmatterKeys.Empresa]: {
        key: exports.FrontmatterKeys.Empresa,
        description: "Empresa u organizaci\xF3n",
        type: "string"
      },
      [exports.FrontmatterKeys.Direcciones]: {
        key: exports.FrontmatterKeys.Direcciones,
        description: "Direcciones postales",
        type: "array"
      },
      [exports.FrontmatterKeys.Urls]: {
        key: exports.FrontmatterKeys.Urls,
        description: "Sitios web y enlaces",
        type: "array"
      },
      [exports.FrontmatterKeys.Eventos]: {
        key: exports.FrontmatterKeys.Eventos,
        description: "Eventos o fechas importantes",
        type: "array"
      },
      [exports.FrontmatterKeys.Relaciones]: {
        key: exports.FrontmatterKeys.Relaciones,
        description: "Relaciones con otras personas",
        type: "array"
      },
      [exports.FrontmatterKeys.Genero]: {
        key: exports.FrontmatterKeys.Genero,
        description: "G\xE9nero",
        type: "string"
      },
      [exports.FrontmatterKeys.Ocupaciones]: {
        key: exports.FrontmatterKeys.Ocupaciones,
        description: "Ocupaciones (adicionales al puesto)",
        type: "array"
      },
      [exports.FrontmatterKeys.Intereses]: {
        key: exports.FrontmatterKeys.Intereses,
        description: "Intereses",
        type: "array"
      },
      [exports.FrontmatterKeys.Habilidades]: {
        key: exports.FrontmatterKeys.Habilidades,
        description: "Habilidades",
        type: "array"
      },
      [exports.FrontmatterKeys.Residencias]: {
        key: exports.FrontmatterKeys.Residencias,
        description: "Residencias o lugares de vivienda",
        type: "array"
      }
    };
  }
});

// ../../libs/core-ts/dist/Domain/Constants/HeaderMetadataRegistry.js
var require_HeaderMetadataRegistry = __commonJS({
  "../../libs/core-ts/dist/Domain/Constants/HeaderMetadataRegistry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeaderMetadataRegistry = exports.HeaderMetadataKeys = void 0;
    exports.HeaderMetadataKeys = {
      Score: "score",
      Difficulty: "difficulty",
      Importance: "importance",
      Attempts: "attempts"
    };
    exports.HeaderMetadataRegistry = {
      [exports.HeaderMetadataKeys.Score]: {
        key: exports.HeaderMetadataKeys.Score,
        description: "Puntuaci\xF3n asociada al contenido",
        type: "number",
        defaultValue: 0
      },
      [exports.HeaderMetadataKeys.Difficulty]: {
        key: exports.HeaderMetadataKeys.Difficulty,
        description: "Nivel de dificultad",
        type: "number",
        defaultValue: 0
      },
      [exports.HeaderMetadataKeys.Importance]: {
        key: exports.HeaderMetadataKeys.Importance,
        description: "Nivel de importancia",
        type: "number",
        defaultValue: 0
      },
      [exports.HeaderMetadataKeys.Attempts]: {
        key: exports.HeaderMetadataKeys.Attempts,
        description: "N\xFAmero de intentos",
        type: "number",
        defaultValue: 0
      }
    };
  }
});

// ../../libs/core-ts/dist/Domain/Constants/PlaceTypes.js
var require_PlaceTypes = __commonJS({
  "../../libs/core-ts/dist/Domain/Constants/PlaceTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlaceTypeRegistry = exports.PlaceTypes = void 0;
    exports.PlaceTypes = [
      "Lugares/Restaurantes",
      "Lugares/Monumentos",
      "Lugares/Paisajes",
      "Lugares/Playas",
      "Lugares/Monta\xF1as",
      "Lugares/Parques",
      "Lugares/Cafeter\xEDas",
      "Lugares/Bares",
      "Lugares/Museos-Artes",
      "Lugares/Museos-Ciencia",
      "Lugares/Hoteles",
      "Lugares/Tiendas",
      "Lugares/Estadios",
      "Lugares/Auditorios",
      "Lugares/Bibliotecas",
      "Lugares/Capitales",
      "Lugares/Municipios",
      "Lugares/Provincias",
      "Lugares/Regiones",
      "Lugares/Pa\xEDses",
      "Lugares/Ciudades",
      "Lugares/Continentes",
      "Lugares/Barrios",
      "Lugares/Pueblos",
      "Lugares/Grandes-almacenes",
      "Lugares/Parques-naturales",
      "Lugares/Casas",
      "Lugares/Oficinas",
      "Lugares/Pisos",
      "Lugares/Calles",
      "Lugares/Islas",
      "Lugares/Tiendas-de-ropa",
      "Lugares/Hospitales",
      "Eventos/Festivales-de-cine",
      "Eventos/Festivales-de-musica"
    ];
    exports.PlaceTypeRegistry = {
      "Lugares/Provincias": { geocodingSuffix: "Provincia" },
      "Lugares/Regiones": { geocodingSuffix: "Region" },
      "Lugares/Pa\xEDses": { geocodingSuffix: "Pais" },
      "Lugares/Municipios": { geocodingSuffix: "Municipio" },
      "Lugares/Ciudades": { geocodingSuffix: "Ciudad" }
    };
  }
});

// ../../libs/core-ts/dist/Domain/Constants/TagFolderMappingRegistry.js
var require_TagFolderMappingRegistry = __commonJS({
  "../../libs/core-ts/dist/Domain/Constants/TagFolderMappingRegistry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TagFolderMappingRegistry = void 0;
    exports.TagFolderMappingRegistry = {
      "Personas/Conocidos-mios": "(Conocidos)",
      "Personas/Compa\xF1eros-de-trabajo": "(Conocidos)",
      "Personas/Vecinos": "(Conocidos)",
      "Personas/Familia": "(Familia)",
      "Personas/P\xFAblicas": "(Personajes)",
      "Personas/Hist\xF3ricas": "(Hist\xF3ricos)",
      "Obras/Pel\xEDculas": "(Audiovisuales)",
      "Obras/Videojuegos": "(Audiovisuales)",
      "Obras/Canciones": "(M\xFAsica)",
      "Obras/Libros": "(Libros)",
      "Obras/Bebidas": "(Gastronom\xEDa)",
      "Obras/Comidas": "(Gastronom\xEDa)",
      "Obras/Canales-Stream": "(Medios)",
      "Obras/Series-TV": "(Audiovisuales)",
      "Orgs/Multinacionales": "(Empresas)",
      "Orgs/Empresas": "(Empresas)",
      "Orgs/Colegios": "(Colegios)",
      "Lugares/Restaurantes": "(Restaurantes)",
      "Lugares/Bares": "(Bares)",
      "Lugares/Cafeter\xEDas": "(Bares)",
      "Lugares/Negocios": "(Negocios)",
      "Lugares/Tiendas": "(Tiendas)",
      "Eventos/Fiestas": "(Eventos)",
      "Eventos/Festivales-de-cine": "(Eventos)",
      "Eventos/Festivales-de-m\xFAsica": "(Eventos)",
      "Eventos/Festivales-de-teatro": "(Eventos)"
    };
  }
});

// ../../libs/core-ts/dist/Domain/Types/PlaceMetadata.js
var require_PlaceMetadata = __commonJS({
  "../../libs/core-ts/dist/Domain/Types/PlaceMetadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Types/Role.js
var require_Role = __commonJS({
  "../../libs/core-ts/dist/Domain/Types/Role.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../libs/core-ts/dist/Domain/Utils/ScoreUtils.js
var require_ScoreUtils = __commonJS({
  "../../libs/core-ts/dist/Domain/Utils/ScoreUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeImportance = normalizeImportance2;
    exports.normalizeDifficulty = normalizeDifficulty2;
    exports.difficultyToColor = difficultyToColor2;
    function normalizeImportance2(importance) {
      if (importance <= 1)
        return 1;
      if (importance >= 5)
        return 5;
      return Math.round(importance);
    }
    function normalizeDifficulty2(difficulty) {
      if (difficulty <= 1)
        return 1;
      if (difficulty >= 3)
        return 3;
      return Math.round(difficulty);
    }
    function difficultyToColor2(difficulty) {
      const normalized = normalizeDifficulty2(difficulty);
      if (normalized === 1)
        return "#50fa7b";
      if (normalized === 2)
        return "#ffb86c";
      return "#ff5555";
    }
  }
});

// ../../libs/core-ts/dist/index.js
var require_dist = __commonJS({
  "../../libs/core-ts/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_GoogleGeminiAdapter(), exports);
    __exportStar(require_GoogleGeminiImagesAdapter(), exports);
    __exportStar(require_GoogleGeminiChatAdapter(), exports);
    __exportStar(require_IGeminiSessionAdapter(), exports);
    __exportStar(require_ContextProviderPort(), exports);
    __exportStar(require_GeocodingPort(), exports);
    __exportStar(require_HeaderDataPort(), exports);
    __exportStar(require_ImageSearchPort(), exports);
    __exportStar(require_LlmPort(), exports);
    __exportStar(require_MetadataPort(), exports);
    __exportStar(require_MusicProviderPort(), exports);
    __exportStar(require_NoteManagerPort(), exports);
    __exportStar(require_RoleRepositoryPort(), exports);
    __exportStar(require_SettingsPort(), exports);
    __exportStar(require_TranscriptionPort(), exports);
    __exportStar(require_YouTubeTranscriptPort(), exports);
    __exportStar(require_CommandIds(), exports);
    __exportStar(require_FrontmatterRegistry(), exports);
    __exportStar(require_HeaderMetadataRegistry(), exports);
    __exportStar(require_PlaceTypes(), exports);
    __exportStar(require_TagFolderMappingRegistry(), exports);
    __exportStar(require_PlaceMetadata(), exports);
    __exportStar(require_Role(), exports);
    __exportStar(require_ScoreUtils(), exports);
  }
});

// src/Infrastructure/Obsidian/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianExtension
});
module.exports = __toCommonJS(main_exports);
var import_obsidian58 = require("obsidian");

// src/Infrastructure/Obsidian/settings.ts
var DEFAULT_SETTINGS = {
  locationStrategy: "same-folder",
  targetFolder: "",
  missingNotesTemplatePath: "# {{title}}\n",
  geminiApiKey: "",
  geminiRolesFolder: "",
  googleGeocodingAPIKey: "",
  googleMapsEmbedAPIKey: "",
  spotifyClientId: "",
  spotifyAccessToken: "",
  spotifyRedirectUri: "http://localhost:8080",
  spotifyPkceVerifier: "",
  spotifyRefreshToken: "",
  spotifyTokenExpirationTime: 0,
  googleCustomSearchApiKey: "",
  googleCustomSearchEngineId: "",
  geminiLiveMode: "gemini_live_voice_text",
  geminiLiveUserMode: "voice_text",
  geminiLiveRole: "",
  // Default to empty string
  geminiLiveLocalVoice: "",
  autoStartBridge: false,
  // Default to false as requested by user ("more control")
  photosBridgePath: "/Users/joshua/my-docs/code/elo-mac-bridge/EloMacBridge.app/Contents/MacOS/elo-mac-bridge",
  googleClientId: "",
  googleClientSecret: "",
  googleRefreshToken: "",
  googleAccessToken: "",
  googleTokenExpirationTime: 0,
  hideEmptyProperties: false,
  userLanguage: "es",
  toLearnLanguage: "en",
  openSubtitlesApiKey: "",
  openSubtitlesUsername: "",
  openSubtitlesPassword: ""
};

// src/Infrastructure/Obsidian/Commands/Images/AddImagesCommand/AddImagesCommand.ts
var import_core = __toESM(require_dist());

// src/Infrastructure/Obsidian/Utils/Messages.ts
var import_obsidian = require("obsidian");
function showMessage(message) {
  console.log("Msg:", message);
  new import_obsidian.Notice(message, 5e3);
}

// src/Infrastructure/Obsidian/Utils/Frontmatter.ts
var import_obsidian2 = require("obsidian");
function splitFrontmatter(content) {
  const match = content.match(/^---\s*\n([\s\S]*?)\n---\s*(?:\n|$)/);
  if (!match || match.index !== 0) {
    return {
      frontmatterText: null,
      body: content
    };
  }
  const [block, text] = match;
  const body = content.slice(block.length);
  return {
    frontmatterText: text,
    body
  };
}
function parseFrontmatter(frontmatter) {
  if (!frontmatter) {
    return null;
  }
  try {
    const parsed = (0, import_obsidian2.parseYaml)(frontmatter);
    if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
      return parsed;
    }
  } catch (error) {
    console.error("Failed to parse frontmatter", error);
  }
  return null;
}
function buildMergedFrontmatter(templateFrontmatter, currentFrontmatter) {
  const templateData = parseFrontmatter(templateFrontmatter);
  const currentData = parseFrontmatter(currentFrontmatter);
  const mergedEntries = [];
  const keyPositions = /* @__PURE__ */ new Map();
  if (templateData) {
    for (const key of Object.keys(templateData)) {
      const templateValue = templateData[key];
      const currentValue = currentData ? currentData[key] : void 0;
      const valueToUse = hasMeaningfulValue(currentValue) ? currentValue : templateValue;
      upsertEntry(mergedEntries, keyPositions, key, valueToUse);
    }
  }
  if (currentData) {
    for (const key of Object.keys(currentData)) {
      const currentValue = currentData[key];
      if (!hasMeaningfulValue(currentValue)) {
        continue;
      }
      upsertEntry(mergedEntries, keyPositions, key, currentValue);
    }
  }
  if (mergedEntries.length === 0) {
    return null;
  }
  const merged = {};
  for (const [key, value] of mergedEntries) {
    merged[key] = value;
  }
  return merged;
}
function formatFrontmatterBlock(data) {
  const yaml = (0, import_obsidian2.stringifyYaml)(data).replace(/\s+$/, "");
  return `---
${yaml}
---`;
}
function stripLeadingFrontmatter(text) {
  const match = text.match(/^---\s*\n([\s\S]*?)\n---\s*(?:\n|$)/);
  if (!match || match.index !== 0) {
    return text;
  }
  return text.slice(match[0].length).replace(/^[\n\r]+/, "");
}
function mergeFrontmatterSuggestions(current, suggestions) {
  if (!suggestions || Object.keys(suggestions).length === 0) {
    return current;
  }
  const base = current ? { ...current } : {};
  let changed = false;
  for (const [key, value] of Object.entries(suggestions)) {
    if (!hasMeaningfulValue(base[key]) && hasMeaningfulValue(value)) {
      base[key] = value;
      changed = true;
    }
  }
  if (!changed && current) {
    return current;
  }
  return changed ? base : null;
}
function applyFrontmatterUpdates(current, updates) {
  if (!updates || Object.keys(updates).length === 0) {
    return current;
  }
  const base = current ? { ...current } : {};
  let changed = false;
  for (const [key, value] of Object.entries(updates)) {
    if (hasMeaningfulValue(value)) {
      if (JSON.stringify(base[key]) !== JSON.stringify(value)) {
        base[key] = value;
        changed = true;
      }
    }
  }
  if (!changed && current) {
    return current;
  }
  return changed ? base : null;
}
function hasMeaningfulValue(value) {
  if (value === null || value === void 0) {
    return false;
  }
  if (typeof value === "string") {
    return value.trim().length > 0;
  }
  if (Array.isArray(value)) {
    return value.length > 0;
  }
  if (typeof value === "object") {
    return Object.keys(value).length > 0;
  }
  return true;
}
function upsertEntry(entries, positions, key, value) {
  if (positions.has(key)) {
    const index = positions.get(key);
    entries[index][1] = value;
    return;
  }
  positions.set(key, entries.length);
  entries.push([key, value]);
}

// src/Infrastructure/Obsidian/Utils/ViewMode.ts
var import_obsidian3 = require("obsidian");
function getActiveMarkdownView(app, targetFile) {
  if (targetFile) {
    const leaves = app.workspace.getLeavesOfType("markdown");
    const matchingLeaf = leaves.find((leaf) => leaf.view.file === targetFile);
    return matchingLeaf ? matchingLeaf.view : null;
  }
  let view = app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
  if (!view) {
    const activeFile = app.workspace.getActiveFile();
    if (activeFile && activeFile.extension === "md") {
      const leaves = app.workspace.getLeavesOfType("markdown");
      const matchingLeaf = leaves.find((leaf) => leaf.view.file === activeFile);
      if (matchingLeaf) {
        view = matchingLeaf.view;
      }
    }
  }
  return view;
}
async function executeInEditMode(view, action) {
  const originalMode = view.getMode();
  if (originalMode !== "source") {
    await view.setState({ ...view.getState(), mode: "source" }, { history: false });
  }
  try {
    await action();
  } finally {
    if (originalMode !== "source" && view.getMode() !== "preview") {
      await view.setState({ ...view.getState(), mode: "preview" }, { history: false });
    }
  }
}

// src/Infrastructure/Obsidian/Commands/Images/AddImagesCommand/AddImagesCommand.ts
var AddImagesCommand = class {
  constructor(app, imageEnricher) {
    this.app = app;
    this.imageEnricher = imageEnricher;
  }
  async execute(targetFile) {
    console.log("[AddImagesCommand] Start");
    const view = getActiveMarkdownView(this.app, targetFile);
    if (!(view == null ? void 0 : view.file)) {
      showMessage("Open a markdown note to add images.");
      console.log("[AddImagesCommand] End (No active view)");
      return;
    }
    const file = view.file;
    await executeInEditMode(view, async () => {
      const currentContent = await this.app.vault.read(file);
      const split = splitFrontmatter(currentContent);
      const frontmatter = parseFrontmatter(split.frontmatterText) || {};
      const existingImages = frontmatter[import_core.FrontmatterKeys.EloImages];
      if (Array.isArray(existingImages) && existingImages.length > 0) {
        showMessage("La nota ya tiene im\xE1genes.");
        return;
      }
      const images = await this.imageEnricher.searchImages(file.basename, 3);
      if (images.length === 0) {
        return;
      }
      try {
        const updatedFrontmatter = {
          ...frontmatter,
          [import_core.FrontmatterKeys.EloImages]: images
        };
        const newFrontmatterBlock = formatFrontmatterBlock(updatedFrontmatter);
        const newContent = newFrontmatterBlock + "\n" + split.body;
        await this.app.vault.modify(file, newContent);
        showMessage(`Se a\xF1adieron ${images.length} im\xE1genes.`);
      } catch (error) {
        console.error(error);
        showMessage("Error al guardar im\xE1genes.");
      }
    });
    console.log("[AddImagesCommand] End");
  }
};

// src/Infrastructure/Obsidian/Commands/Place/EnrichPlaceCommand/EnrichPlaceCommand.ts
var import_obsidian6 = require("obsidian");

// src/Application/Services/PlaceEnrichmentService.ts
var import_core2 = __toESM(require_dist());
var import_core3 = __toESM(require_dist());

// src/Infrastructure/Obsidian/Utils/Strings.ts
function capitalize(str) {
  if (!str)
    return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function levenshtein(a, b) {
  const matrix = [];
  for (let i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) == a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          // substitution
          Math.min(
            matrix[i][j - 1] + 1,
            // insertion
            matrix[i - 1][j] + 1
            // deletion
          )
        );
      }
    }
  }
  return matrix[b.length][a.length];
}
function similarity(a, b) {
  const longer = a.length > b.length ? a : b;
  const shorter = a.length > b.length ? b : a;
  const longerLength = longer.length;
  if (longerLength === 0) {
    return 1;
  }
  return (longerLength - levenshtein(longer, shorter)) / parseFloat(longerLength.toString());
}

// src/Application/Services/PlaceEnrichmentService.ts
var PlaceEnrichmentService = class {
  constructor(geocoder, llm) {
    this.geocoder = geocoder;
    this.llm = llm;
  }
  async enrichPlace(placeName, promptPlaceDetails, placeId, placeType, excludeTags = false) {
    let placeDetails = promptPlaceDetails;
    if (!placeDetails) {
      const searchName = placeType ? `${placeName.trim()} ${placeType}` : placeName.trim();
      placeDetails = await this.geocoder.requestPlaceDetails({
        placeName: searchName,
        placeId
      });
    }
    if (!placeDetails) {
      return null;
    }
    return this.getEnrichedData(placeName.trim(), placeDetails, placeType, excludeTags);
  }
  async getEnrichedData(placeName, rawDetails, placeType, excludeTags = false) {
    const tagsRules = excludeTags ? "" : `
        Rules for tags:
        1. Choose 0 or more tags that is this place from the following list: ${JSON.stringify(import_core3.PlaceTypes)}.
        2. ONLY use tags from this list.
        `;
    const tagsField = excludeTags ? "" : `"tags": ["Lugares/..."]`;
    const prompt = `
        I have a place named "${placeName}"${placeType ? ` (Type: ${placeType})` : ""}.
        Raw Geocoding Data: ${JSON.stringify(rawDetails)}.

        Please refine this data and provide metadata.
        
        Rules for refinement:
        1. Correct any misclassifications. For example, "Inglaterra" might be returned as a province, but it should be a Region, and Country should be "Reino Unido".
        2. HIERARCHY RULE: If the place being geocoded IS ITSELF a higher level entity, clear all lower level fields.
           - If it is a Country -> region="", provincia="", municipio=""
           - If it is a Region -> provincia="", municipio=""
           - If it is a Province -> municipio=""
        3. 'pais' must be the sovereign country (e.g. "Reino Unido" for England).
        4. If the place is a Country, provide its Capital City in the 'capital' field of refinedDetails, and add the 'continent' field of refinedDetails.
    
        Rules for metadata:
        1. Continent (in Spanish).
        2. isRegionFamous (boolean).

        Rules for summary:
        1. Write a SINGLE paragraph (approx 50-80 words) summarizing the most relevant aspects of this place (history, significance, tourism).
        2. In Spanish.

        ${tagsRules}

        Return ONLY a JSON object:
        {
            "refinedDetails": {
                "municipio": "...",
                "provincia": "...",
                "region": "...",
                "pais": "...",
                "capital": "...", // Only if it is a country
                "continent": "...", // Only if it is a country
                "googlePlaceId": "...",
                "lat": 0.0,
                "lng": 0.0
            },
            "metadata": {
                "continent": "Name",
                "isRegionFamous": true/false
            },
            "summary": "...",
            ${tagsField}
        }
        `;
    const response = await this.llm.requestJson({ prompt });
    if (!response)
      return null;
    try {
      return response;
    } catch (e) {
      console.error("Failed to parse LLM response for enriched data", e);
      return null;
    }
  }
  mergeFrontmatter(current, details, tags) {
    var _a2;
    const base = current ? { ...current } : {};
    const mapping = {
      "municipio": import_core2.FrontmatterKeys.Municipio,
      "provincia": import_core2.FrontmatterKeys.Provincia,
      "region": import_core2.FrontmatterKeys.Region,
      "pais": import_core2.FrontmatterKeys.Pais,
      "capital": import_core2.FrontmatterKeys.Capital
    };
    for (const [prop, key] of Object.entries(mapping)) {
      const value = details[prop];
      if (typeof base[key] === "string") {
        base[key] = capitalize(base[key]);
      }
      const currentValue = base[key];
      const hasMeaningfulValue2 = currentValue !== void 0 && currentValue !== null && !(typeof currentValue === "string" && currentValue.trim().length === 0);
      if (!hasMeaningfulValue2) {
        const cleanValue = typeof value === "string" ? value.trim() : value;
        if (cleanValue === "" || cleanValue === null || cleanValue === void 0) {
          delete base[key];
        } else {
          let finalValue = typeof cleanValue === "string" ? capitalize(cleanValue) : cleanValue;
          base[key] = finalValue;
        }
      }
      const finalVal = base[key];
      if (typeof finalVal === "string" && ((_a2 = import_core2.FrontmatterRegistry[key]) == null ? void 0 : _a2.asLink)) {
        if (!finalVal.startsWith("[[") || !finalVal.endsWith("]]")) {
          base[key] = `[[${finalVal}]]`;
        }
      }
    }
    if (details.googlePlaceId) {
      base[import_core2.FrontmatterKeys.LugarId] = "google-maps-id:" + details.googlePlaceId;
    }
    if (details.lat) {
      base[import_core2.FrontmatterKeys.Latitud] = details.lat;
    }
    if (details.lng) {
      base[import_core2.FrontmatterKeys.Longitud] = details.lng;
    }
    if (tags && tags.length > 0) {
      const currentTags = base[import_core2.FrontmatterKeys.Tags] || [];
      const normalizedCurrentTags = Array.isArray(currentTags) ? currentTags : [currentTags];
      const newTags = /* @__PURE__ */ new Set([...normalizedCurrentTags, ...tags]);
      base[import_core2.FrontmatterKeys.Tags] = Array.from(newTags);
    }
    return base;
  }
  async classifyPlace(placeName) {
    const prompt = `
        I have a place named "${placeName}".
        Function: Classify this place into one of the following categories:
        ${import_core3.PlaceTypes.map((t) => `- "${t}"`).join("\n")}

        Return a JSON object:
        {
            "suggestedTag": "Lugares/..." or null if none match,
            "isConfident": boolean // set to true ONLY if you are very sure (e.g. "McDonalds" is a Restaurant). If ambiguous, false.
        }
        `;
    const response = await this.llm.requestJson({ prompt });
    return response;
  }
};

// src/Infrastructure/Obsidian/Commands/Place/EnrichPlaceCommand/EnrichPlaceCommand.ts
var import_core5 = __toESM(require_dist());
var import_core6 = __toESM(require_dist());

// src/Infrastructure/Obsidian/Utils/LocationPathBuilder.ts
var import_obsidian4 = require("obsidian");
var import_core4 = __toESM(require_dist());
var LocationPathBuilder = class {
  constructor(app) {
    this.app = app;
  }
  buildPath(placeName, details, metadata) {
    var _a2, _b, _c, _d;
    const municipio = (_a2 = details.municipio) == null ? void 0 : _a2.trim();
    const provincia = (_b = details.provincia) == null ? void 0 : _b.trim();
    const region = (_c = details.region) == null ? void 0 : _c.trim();
    const pais = (_d = details.pais) == null ? void 0 : _d.trim();
    const placeNameTrimmed = placeName.trim();
    const { continent, isRegionFamous } = metadata;
    const parts = ["Lugares", continent, pais];
    if (region)
      parts.push(region);
    if (provincia)
      parts.push(provincia);
    if (municipio) {
      let municipioFolder = municipio;
      const isCitySameAsProvince = provincia && municipio.localeCompare(provincia, void 0, { sensitivity: "base" }) === 0;
      if (isCitySameAsProvince && provincia) {
        municipioFolder = `${provincia} (Ciudad)`;
      }
      parts.push(municipioFolder);
    }
    let fileName = `${placeNameTrimmed}.md`;
    if (municipio) {
      const isSameName = placeNameTrimmed.localeCompare(municipio, void 0, { sensitivity: "base" }) === 0;
      if (isSameName) {
        let cleanName = municipio;
        if (provincia && municipio.localeCompare(provincia, void 0, { sensitivity: "base" }) === 0) {
          cleanName = `${provincia} (Ciudad)`;
        }
        fileName = `${cleanName}.md`;
      }
    }
    const cleanParts = parts.filter((p) => !!p && p.length > 0);
    const lastFolder = cleanParts.length > 0 ? cleanParts[cleanParts.length - 1] : "";
    const targetFolderName = fileName.replace(/\.md$/, "");
    if (lastFolder !== targetFolderName) {
      cleanParts.push(targetFolderName);
    }
    return (0, import_obsidian4.normalizePath)([...cleanParts, fileName].join("/"));
  }
  folderExists(path5) {
    const normalized = (0, import_obsidian4.normalizePath)(path5);
    const file = this.app.vault.getAbstractFileByPath(normalized);
    return !!file;
  }
};

// src/Infrastructure/Obsidian/Utils/Vault.ts
var import_obsidian5 = require("obsidian");
async function ensureFolderExists(app, filePath) {
  const folderPath = filePath.split("/").slice(0, -1).join("/");
  if (!folderPath) {
    return;
  }
  const normalized = (0, import_obsidian5.normalizePath)(folderPath);
  const folder = app.vault.getAbstractFileByPath(normalized);
  if (!folder) {
    await createFolderRecursively(app, normalized);
  }
}
async function pathExists(app, path5) {
  const file = app.vault.getAbstractFileByPath(path5);
  if (file) {
    return true;
  }
  return app.vault.adapter.exists(path5);
}
function getTemplatesFolder(app) {
  var _a2, _b, _c, _d;
  const internalPlugins = app.internalPlugins;
  const templatesPlugin = (_a2 = internalPlugins == null ? void 0 : internalPlugins.getPluginById) == null ? void 0 : _a2.call(internalPlugins, "templates");
  if (!templatesPlugin) {
    return null;
  }
  const options = (_d = (_c = (_b = templatesPlugin.instance) == null ? void 0 : _b.options) != null ? _c : templatesPlugin.options) != null ? _d : null;
  if (!options) {
    return null;
  }
  const candidates = [
    options.folder,
    options.templatesFolder,
    options.templateFolder,
    options.dir
  ];
  for (const candidate of candidates) {
    if (typeof candidate === "string" && candidate.trim()) {
      return candidate.trim();
    }
  }
  return null;
}
async function createFolderRecursively(app, folderPath) {
  var _a2;
  const parts = folderPath.split("/");
  let current = "";
  console.log(`[GenerateMissingNotes] Ensuring folder structure: ${folderPath}`);
  for (const part of parts) {
    current = current ? `${current}/${part}` : part;
    const existsOnDisk = await app.vault.adapter.exists(current);
    if (existsOnDisk) {
      const stat = await app.vault.adapter.stat(current);
      if ((stat == null ? void 0 : stat.type) === "file") {
        console.error(`[GenerateMissingNotes] Error: Path "${current}" exists as a file, cannot create folder.`);
        throw new Error(`Cannot create folder "${current}" because a file already exists with that name.`);
      }
      continue;
    }
    try {
      console.log(`[GenerateMissingNotes] Creating folder: ${current}`);
      await app.vault.createFolder(current);
    } catch (e) {
      if (((_a2 = e == null ? void 0 : e.message) == null ? void 0 : _a2.includes("Folder already exists")) || (e == null ? void 0 : e.code) === "EEXIST") {
        continue;
      }
      console.error(`[GenerateMissingNotes] Failed to create folder "${current}":`, e);
      throw e;
    }
  }
}
async function moveFile(app, file, targetPath) {
  const currentPath = file.path;
  if (currentPath === targetPath) {
    return;
  }
  await ensureFolderExists(app, targetPath);
  const existingFile = app.vault.getAbstractFileByPath(targetPath);
  if (existingFile && existingFile instanceof import_obsidian5.TFile) {
    throw new Error(`Target file already exists: ${targetPath}`);
  }
  await app.fileManager.renameFile(file, targetPath);
}
async function ensureFolderNotes(app, filePath) {
  const normalized = (0, import_obsidian5.normalizePath)(filePath);
  const parts = normalized.split("/");
  if (parts.length <= 1)
    return;
  let currentPath = "";
  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i];
    currentPath = currentPath ? `${currentPath}/${part}` : part;
    const folderNotePath = `${currentPath}/${part}.md`;
    const exists = await pathExists(app, folderNotePath);
    if (!exists) {
      try {
        await app.vault.create(folderNotePath, "");
      } catch (e) {
        console.error(`Failed to create folder note at ${folderNotePath}`, e);
      }
    }
  }
}

// src/Infrastructure/Obsidian/Commands/Place/EnrichPlaceCommand/EnrichPlaceCommand.ts
var EnrichPlaceCommand = class {
  constructor(geocoder, llm, app) {
    this.geocoder = geocoder;
    this.llm = llm;
    this.app = app;
    this.enrichmentService = new PlaceEnrichmentService(geocoder, llm);
  }
  async execute(file) {
    console.log("[EnrichPlaceCommand] Start");
    const view = getActiveMarkdownView(this.app, file);
    if (!(view == null ? void 0 : view.file)) {
      showMessage("Abre una nota de markdown para enriquecer el lugar.");
      console.log("[EnrichPlaceCommand] End (No active view)");
      return;
    }
    await executeInEditMode(view, async () => {
      var _a2;
      const file2 = view.file;
      if (!file2)
        return;
      const content = await this.app.vault.read(file2);
      const split = splitFrontmatter(content);
      const currentFrontmatter = parseFrontmatter(split.frontmatterText);
      const existingIdRaw = currentFrontmatter == null ? void 0 : currentFrontmatter[import_core6.FrontmatterKeys.LugarId];
      let placeId;
      let searchName = file2.basename;
      if (typeof existingIdRaw === "string" && existingIdRaw.startsWith("google-maps-id:")) {
        placeId = existingIdRaw.replace("google-maps-id:", "");
        showMessage(`ID existente encontrado: ${placeId}. Verificando detalles...`);
        const details = await this.geocoder.requestPlaceDetails({ placeName: searchName, placeId });
        if (details == null ? void 0 : details.lugar) {
          searchName = details.lugar;
        }
      } else {
        const components = [file2.basename];
        const keysToCheck = [
          import_core6.FrontmatterKeys.Municipio,
          import_core6.FrontmatterKeys.Provincia,
          import_core6.FrontmatterKeys.Region,
          import_core6.FrontmatterKeys.Pais
        ];
        for (const key of keysToCheck) {
          const val = currentFrontmatter == null ? void 0 : currentFrontmatter[key];
          if (val && typeof val === "string" && val.trim().length > 0) {
            const cleanVal = val.replace(/^\[\[|\]\]$/g, "");
            components.push(cleanVal);
          }
        }
        searchName = components.join(", ");
        showMessage(`Buscando: "${searchName}"...`);
      }
      let selectedTag = null;
      if (currentFrontmatter && currentFrontmatter[import_core6.FrontmatterKeys.Tags]) {
        const rawTags = currentFrontmatter[import_core6.FrontmatterKeys.Tags];
        const tags2 = Array.isArray(rawTags) ? rawTags : [rawTags];
        const found = tags2.find((t) => import_core5.PlaceTypes.includes(t));
        if (found) {
          selectedTag = found;
          showMessage(`Tipo detectado en frontmatter: ${selectedTag}`);
        }
      }
      if (!selectedTag) {
        const classification = await this.enrichmentService.classifyPlace(searchName);
        selectedTag = (_a2 = classification == null ? void 0 : classification.suggestedTag) != null ? _a2 : null;
        if (!(classification == null ? void 0 : classification.isConfident) || !selectedTag || selectedTag === "Other") {
          selectedTag = await this.askUserForTag();
        } else {
          showMessage(`Tipo detectado por IA: ${selectedTag}`);
        }
      }
      if (!selectedTag) {
        showMessage("No se seleccion\xF3 tipo de lugar. Abortando operaci\xF3n.");
        return;
      }
      let placeTypeSuffix;
      if (selectedTag) {
        const config = import_core5.PlaceTypeRegistry[selectedTag];
        placeTypeSuffix = config == null ? void 0 : config.geocodingSuffix;
      }
      showMessage(`Obteniendo detalles completos y datos extendidos...${placeTypeSuffix ? ` (Tipo: ${placeTypeSuffix})` : ""}`);
      const existingTags = currentFrontmatter == null ? void 0 : currentFrontmatter[import_core6.FrontmatterKeys.Tags];
      const hasTags = Array.isArray(existingTags) ? existingTags.length > 0 : !!existingTags;
      const enriched = await this.enrichmentService.enrichPlace(searchName, void 0, placeId, placeTypeSuffix, hasTags);
      if (!enriched) {
        showMessage("No se pudieron obtener datos enriquecidos.");
        return;
      }
      const { refinedDetails, summary, tags } = enriched;
      const finalTags = tags || [];
      if (!finalTags.includes(selectedTag)) {
        finalTags.push(selectedTag);
      }
      const updatedFrontmatter = this.enrichmentService.mergeFrontmatter(currentFrontmatter, refinedDetails, finalTags);
      const frontmatterBlock = formatFrontmatterBlock(updatedFrontmatter);
      const normalizedBody = split.body.replace(/^[\n\r]+/, "");
      const segments = [];
      if (frontmatterBlock)
        segments.push(frontmatterBlock);
      if (summary)
        segments.push(summary);
      if (normalizedBody)
        segments.push(normalizedBody);
      const finalContent = segments.join("\n\n");
      if (finalContent !== content) {
        await this.app.vault.modify(file2, finalContent);
        showMessage("Nota enriquecida correctamente.");
        showMessage('Sugerencia: Usa "Organizar nota de Lugar" para moverla a su carpeta.');
      } else {
        showMessage("No hubo cambios en la nota.");
      }
    });
    console.log("[EnrichPlaceCommand] End");
  }
  async askUserForTag() {
    return new Promise((resolve) => {
      const modal = new PlaceTypeSuggestModal(this.app, (result) => {
        resolve(result);
      });
      modal.open();
    });
  }
};
var PlaceTypeSuggestModal = class extends import_obsidian6.SuggestModal {
  constructor(app, onChoose) {
    super(app);
    this.onChoose = onChoose;
  }
  getSuggestions(query) {
    return import_core5.PlaceTypes.filter((t) => t.toLowerCase().includes(query.toLowerCase()));
  }
  renderSuggestion(value, el) {
    el.createEl("div", { text: value });
  }
  onChooseSuggestion(item, evt) {
    this.onChoose(item);
  }
};

// src/Infrastructure/Obsidian/Commands/Place/RelocatePlaceNoteCommand/RelocatePlaceNoteCommand.ts
var import_obsidian7 = require("obsidian");
var import_core7 = __toESM(require_dist());
var RelocatePlaceNoteCommand = class {
  constructor(app) {
    this.app = app;
    this.pathBuilder = new LocationPathBuilder(app);
  }
  async execute(file) {
    console.log("[RelocatePlaceNoteCommand] Start");
    const view = getActiveMarkdownView(this.app, file);
    if (!(view == null ? void 0 : view.file)) {
      showMessage("Abre una nota para organizar.");
      console.log("[RelocatePlaceNoteCommand] End (No active view)");
      return;
    }
    await executeInEditMode(view, async () => {
      const file2 = view.file;
      if (!file2)
        return;
      const content = await this.app.vault.read(file2);
      const split = splitFrontmatter(content);
      const frontmatter = parseFrontmatter(split.frontmatterText);
      if (!frontmatter) {
        showMessage("La nota no tiene frontmatter para organizar.");
        return;
      }
      const rawTags = frontmatter[import_core7.FrontmatterKeys.Tags];
      const tags = Array.isArray(rawTags) ? rawTags : typeof rawTags === "string" ? rawTags.split(",").map((t) => t.trim()) : [];
      const hasLugaresTag = tags.some((tag) => tag.startsWith("Lugares/"));
      if (!hasLugaresTag) {
        showMessage('Este comando solo se aplica a notas que tengan un tag que empiece por "Lugares/".');
        console.log('[RelocatePlaceNoteCommand] End (No "Lugares/" tag)');
        return;
      }
      const getString = (key) => {
        const val = frontmatter[key];
        if (val === void 0 || val === null)
          return "";
        const str = typeof val === "string" ? val : String(val);
        return str.replace(/\[\[(?:[^|\]]*\|)?([^\]]+)\]\]/g, "$1").trim();
      };
      const details = {
        municipio: getString(import_core7.FrontmatterKeys.Municipio),
        provincia: getString(import_core7.FrontmatterKeys.Provincia),
        region: getString(import_core7.FrontmatterKeys.Region),
        pais: getString(import_core7.FrontmatterKeys.Pais)
      };
      let continent = "";
      let paisRaw = frontmatter[import_core7.FrontmatterKeys.Pais];
      if (Array.isArray(paisRaw)) {
        paisRaw = paisRaw.length > 0 ? paisRaw[0] : "";
      }
      const findContinentForCountry = (country) => {
        const lugaresFolder = this.app.vault.getAbstractFileByPath("Lugares");
        if (!lugaresFolder || !(lugaresFolder instanceof import_obsidian7.TFolder))
          return null;
        for (const potentialContinent of lugaresFolder.children) {
          if (potentialContinent instanceof import_obsidian7.TFolder) {
            const countryFolder = this.app.vault.getAbstractFileByPath(`${potentialContinent.path}/${country}`);
            if (countryFolder && countryFolder instanceof import_obsidian7.TFolder) {
              return potentialContinent.name;
            }
          }
        }
        return null;
      };
      if (typeof paisRaw === "string") {
        const countryName = paisRaw.replace(/\[\[(?:[^|\]]*\|)?([^\]]+)\]\]/g, "$1").trim();
        const foundContinent = findContinentForCountry(countryName);
        if (foundContinent) {
          continent = foundContinent;
        } else {
          const continentMatch = paisRaw.match(/\[\[Lugares\/([^\/]+)\//);
          if (continentMatch && continentMatch[1]) {
            continent = continentMatch[1];
          }
        }
      }
      const mockMetadata = {
        tags: frontmatter[import_core7.FrontmatterKeys.Tags] || [],
        continent
      };
      showMessage("Calculando ubicaci\xF3n basada en metadatos actuales...");
      try {
        const newPath = this.pathBuilder.buildPath(file2.basename, details, mockMetadata);
        if (newPath !== file2.path) {
          await moveFile(this.app, file2, newPath);
          showMessage(`Nota movida a ${newPath}`);
        } else {
          showMessage("La nota ya est\xE1 en la ubicaci\xF3n correcta.");
        }
        await ensureFolderNotes(this.app, newPath);
      } catch (err) {
        console.error(err);
        showMessage(`Error al organizar la nota: ${err}`);
      }
    });
    console.log("[RelocatePlaceNoteCommand] End");
  }
};

// src/Infrastructure/Adapters/YouTubeTranscriptAdapter/YouTubeTranscriptRobustAdapter.ts
var import_obsidian8 = require("obsidian");

// src/Infrastructure/Obsidian/Commands/AI/ApplyStreamBriefCommand/ApplyStreamBriefCommand.ts
var import_core8 = __toESM(require_dist());

// src/Infrastructure/Obsidian/Commands/ApplyTemplateCommand/ApplyTemplateCommand.ts
var import_obsidian13 = require("obsidian");
var import_core10 = __toESM(require_dist());

// src/Infrastructure/Obsidian/Utils/TemplateConfig.ts
var import_obsidian9 = require("obsidian");
function extractConfigFromTemplate(content) {
  const { frontmatterText, body } = splitFrontmatter(content);
  let config = {};
  let cleanedContent = content;
  const parsedFrontmatter = parseFrontmatter(frontmatterText);
  if (parsedFrontmatter) {
    const cleanFm = { ...parsedFrontmatter };
    let modified = false;
    for (const key of Object.keys(parsedFrontmatter)) {
      if (key.startsWith("!!")) {
        const configKey = key.substring(2);
        config[configKey] = parsedFrontmatter[key];
        delete cleanFm[key];
        modified = true;
      }
    }
    if (modified) {
      config.hasFrontmatter = Object.keys(cleanFm).length > 0;
      const newFmBlock = Object.keys(cleanFm).length > 0 ? formatFrontmatterBlock(cleanFm) : "";
      cleanedContent = newFmBlock ? `${newFmBlock}
${body}`.trimStart() : body.trimStart();
      if (newFmBlock && body) {
        cleanedContent = `${newFmBlock}
${body}`;
      } else if (newFmBlock) {
        cleanedContent = newFmBlock;
      } else {
        cleanedContent = body;
      }
    } else {
      config.hasFrontmatter = Object.keys(cleanFm).length > 0;
    }
  }
  const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/g;
  let match;
  while ((match = jsonBlockRegex.exec(cleanedContent)) !== null) {
    try {
      let jsonContent;
      try {
        jsonContent = JSON.parse(match[1]);
      } catch (e) {
        try {
          jsonContent = new Function("return " + match[1])();
        } catch (e2) {
          throw e;
        }
      }
      if (jsonContent && (jsonContent.commands || jsonContent.prompt)) {
        config = {
          ...config,
          ...jsonContent
        };
        cleanedContent = cleanedContent.replace(match[0], "").trim();
        jsonBlockRegex.lastIndex = 0;
      }
    } catch (e) {
      console.warn("Failed to parse JSON block in template", e);
    }
  }
  return { config, cleanedContent };
}
async function getAllTemplateConfigs(app) {
  const templatesFolder = getTemplatesFolder(app);
  if (!templatesFolder) {
    return [];
  }
  const matches = [];
  const templateFiles = [];
  const collectFiles = (folderPath) => {
    const folder = app.vault.getAbstractFileByPath(folderPath);
    if (folder && "children" in folder) {
      for (const child of folder.children) {
        if (child instanceof import_obsidian9.TFile && child.extension === "md") {
          templateFiles.push(child);
        } else if ("children" in child) {
          collectFiles(child.path);
        }
      }
    }
  };
  collectFiles(templatesFolder);
  for (const templateFile of templateFiles) {
    const templateContent = await app.vault.read(templateFile);
    const { config, cleanedContent } = extractConfigFromTemplate(templateContent);
    matches.push({ config, cleanedContent, templateFile });
  }
  return matches;
}

// src/Infrastructure/Obsidian/Utils/Notes.ts
function mergeNotes(noteB, noteA, useTemplateBody = true) {
  const templateSplit = splitFrontmatter(noteB);
  const currentSplit = splitFrontmatter(noteA);
  const mergedFrontmatter = buildMergedFrontmatter(
    templateSplit.frontmatterText,
    currentSplit.frontmatterText
  );
  const mergedFrontmatterBlock = mergedFrontmatter ? formatFrontmatterBlock(mergedFrontmatter) : "";
  const mergedBody = useTemplateBody ? mergeBodyContent(templateSplit.body, currentSplit.body) : currentSplit.body;
  const normalizedBody = mergedBody.replace(/^[\n\r]+/, "");
  const segments = [];
  if (mergedFrontmatterBlock) {
    segments.push(mergedFrontmatterBlock);
  }
  if (normalizedBody) {
    segments.push(normalizedBody);
  }
  return segments.join("\n\n");
}
function mergeBodyContent(templateBody, currentBody) {
  const cleanTemplate = stripLeadingFrontmatter(templateBody);
  const cleanCurrent = stripLeadingFrontmatter(currentBody);
  const normalizedTemplate = cleanTemplate.replace(/\s+$/, "");
  const normalizedCurrent = cleanCurrent.replace(/^\s+/, "");
  if (!normalizedTemplate) {
    return normalizedCurrent;
  }
  if (!normalizedCurrent) {
    return normalizedTemplate;
  }
  return `${normalizedTemplate}

${normalizedCurrent}`;
}

// src/Application/Services/PersonasNoteOrganizer.ts
var PersonasNoteOrganizer = class {
  constructor(noteManager) {
    this.noteManager = noteManager;
  }
  async organize(file, frontmatter) {
    const pathParts = file.path.split("/");
    const personasIndex = pathParts.findIndex((p) => p.toLowerCase() === "personas");
    if (personasIndex === -1) {
      return;
    }
    const paises = frontmatter["Paises"];
    const regiones = frontmatter["Regiones"];
    const pais = this.getFirstValue(paises);
    const region = this.getFirstValue(regiones);
    const lugares = frontmatter["Lugares"];
    const lugar = this.getFirstValue(lugares);
    if (!pais) {
      return;
    }
    const basePath = pathParts.slice(0, personasIndex + 1).join("/");
    let newPathParts = [basePath, pais];
    if (region) {
      newPathParts.push(region);
    }
    if (lugar) {
      newPathParts.push(lugar);
    }
    newPathParts.push("(Personas)");
    newPathParts.push(file.name);
    const newPath = this.noteManager.normalizePath(newPathParts.join("/"));
    if (newPath === file.path) {
      return;
    }
    try {
      await this.noteManager.ensureFolderExists(newPath);
      await this.noteManager.renameFile(file, newPath);
      showMessage(`Nota movida a: ${newPath}`);
    } catch (error) {
      console.error("Error moving persona note:", error);
      showMessage(`Error al mover la nota: ${error.message}`);
    }
  }
  getFirstValue(value) {
    let result = null;
    if (typeof value === "string") {
      result = value;
    } else if (Array.isArray(value) && value.length > 0) {
      const first = value[0];
      if (typeof first === "string") {
        result = first;
      }
    }
    if (result) {
      return result.replace(/\[\[/g, "").replace(/\]\]/g, "").trim();
    }
    return null;
  }
};

// src/Infrastructure/Obsidian/Views/Modals/GenericFuzzySuggestModal.ts
var import_obsidian10 = require("obsidian");
var GenericFuzzySuggestModal = class extends import_obsidian10.FuzzySuggestModal {
  constructor(app, items, getItemTextCallback, onChooseItemCallback, resolve, placeholder) {
    super(app);
    this.items = items;
    this.getItemTextCallback = getItemTextCallback;
    this.onChooseItemCallback = onChooseItemCallback;
    this.resolve = resolve;
    this.isSelected = false;
    if (placeholder) {
      this.setPlaceholder(placeholder);
    }
  }
  getItems() {
    return this.items;
  }
  getItemText(item) {
    return this.getItemTextCallback(item);
  }
  selectSuggestion(value, evt) {
    this.isSelected = true;
    super.selectSuggestion(value, evt);
  }
  onChooseItem(item, evt) {
    this.isSelected = true;
    this.onChooseItemCallback(item);
    this.resolve(item);
  }
  onClose() {
    if (!this.isSelected) {
      this.resolve(null);
    }
  }
};

// src/Infrastructure/Adapters/ObsidianNoteManager.ts
var import_obsidian12 = require("obsidian");

// src/Infrastructure/Services/MetadataService.ts
var import_obsidian11 = require("obsidian");
var import_core9 = __toESM(require_dist());
var MetadataService = class {
  constructor(app) {
    this.app = app;
  }
  async updateBlockMetadata(fileOrPath, blockId, metadata) {
    let file = null;
    if (typeof fileOrPath === "string") {
      const abstractFile = this.app.vault.getAbstractFileByPath(fileOrPath);
      if (abstractFile instanceof import_obsidian11.TFile)
        file = abstractFile;
    } else {
      file = fileOrPath;
    }
    if (!file)
      return;
    const jsonPath = file.path.replace(/\.md$/, ".json");
    let currentData = {};
    if (await this.app.vault.adapter.exists(jsonPath)) {
      try {
        const content = await this.app.vault.adapter.read(jsonPath);
        currentData = JSON.parse(content);
      } catch (e) {
        console.warn(`[MetadataService] Failed to parse existing JSON at ${jsonPath}`, e);
      }
    }
    if (!currentData[blockId]) {
      currentData[blockId] = {};
    }
    currentData[blockId] = {
      ...currentData[blockId],
      ...metadata
    };
    await this.app.vault.adapter.write(jsonPath, JSON.stringify(currentData, null, 2));
  }
  async getFileMetadata(fileOrPath) {
    const path5 = typeof fileOrPath === "string" ? fileOrPath : fileOrPath.path;
    const jsonPath = path5.replace(/\.md$/, ".json");
    if (await this.app.vault.adapter.exists(jsonPath)) {
      try {
        const content = await this.app.vault.adapter.read(jsonPath);
        const parsed = JSON.parse(content);
        if (typeof parsed === "object" && parsed !== null) {
          return parsed;
        }
      } catch (e) {
        console.warn(`[MetadataService] Failed to parse JSON at ${jsonPath}`, e);
      }
    }
    return {};
  }
  /**
   * Ensures a block ID exists for the given header.
   * Returns the block ID (existing or newly generated).
   */
  ensureBlockId(header) {
    const blockIdMatch = header.heading.match(/\^([a-zA-Z0-9-]+)$/);
    if (blockIdMatch) {
      return blockIdMatch[1];
    }
    return this.generateShortId();
  }
  generateShortId() {
    return Math.random().toString(36).substring(2, 8);
  }
  /**
   * Syncs metadata for all block IDs in the file to the sidecar JSON.
   */
  async syncMetadata(file, blockIds) {
    const jsonPath = file.path.replace(/\.md$/, ".json");
    let currentData = {};
    if (await this.app.vault.adapter.exists(jsonPath)) {
      try {
        const content = await this.app.vault.adapter.read(jsonPath);
        const parsed = JSON.parse(content);
        if (typeof parsed === "object" && parsed !== null) {
          currentData = parsed;
        }
      } catch (e) {
        console.warn(`[MetadataService] Failed to parse existing JSON at ${jsonPath}`, e);
        currentData = {};
      }
    }
    let hasChanges = false;
    const defaultMetadata = {};
    Object.values(import_core9.HeaderMetadataRegistry).forEach((field) => {
      defaultMetadata[field.key] = field.defaultValue;
    });
    for (const id of blockIds) {
      if (!currentData[id]) {
        currentData[id] = { ...defaultMetadata };
        hasChanges = true;
      } else {
        let entryChanged = false;
        Object.keys(defaultMetadata).forEach((key) => {
          if (currentData[id][key] === void 0) {
            currentData[id][key] = defaultMetadata[key];
            entryChanged = true;
          }
        });
        if (entryChanged)
          hasChanges = true;
      }
    }
    if (hasChanges) {
      await this.app.vault.adapter.write(jsonPath, JSON.stringify(currentData, null, 2));
    }
  }
  async handleRename(file, oldPath) {
    if (file.extension !== "md")
      return;
    const oldJsonPath = oldPath.replace(/\.md$/, ".json");
    const newJsonPath = file.path.replace(/\.md$/, ".json");
    if (await this.app.vault.adapter.exists(oldJsonPath)) {
      try {
        await this.app.vault.adapter.rename(oldJsonPath, newJsonPath);
      } catch (e) {
        console.warn(`[MetadataService] Failed to rename sidecar JSON from ${oldJsonPath} to ${newJsonPath}`, e);
      }
    }
  }
};

// src/Infrastructure/Adapters/ObsidianNoteManager.ts
var ObsidianNoteManager = class {
  constructor(app) {
    this.app = app;
  }
  getActiveNote() {
    const file = this.app.workspace.getActiveFile();
    if (!file)
      return null;
    return this.mapToNoteItem(file);
  }
  async getActiveNoteContent() {
    const file = this.app.workspace.getActiveFile();
    if (!file)
      return null;
    return await this.app.vault.read(file);
  }
  async readNote(path5) {
    const file = this.app.vault.getAbstractFileByPath(path5);
    if (file instanceof import_obsidian12.TFile) {
      return await this.app.vault.read(file);
    }
    throw new Error(`File not found: ${path5}`);
  }
  async getNoteMetadata(path5) {
    const file = this.app.vault.getAbstractFileByPath(path5);
    if (file instanceof import_obsidian12.TFile) {
      const metaService = new MetadataService(this.app);
      return await metaService.getFileMetadata(file);
    }
    return {};
  }
  async renameFile(fileItem, newPath) {
    const file = this.app.vault.getAbstractFileByPath(fileItem.path);
    if (file instanceof import_obsidian12.TFile) {
      await this.app.fileManager.renameFile(file, newPath);
    } else {
      throw new Error(`File not found to rename: ${fileItem.path}`);
    }
  }
  async ensureFolderExists(path5) {
    const folders = path5.split("/").slice(0, -1);
    if (folders.length === 0)
      return;
    let currentPath = "";
    for (const folder of folders) {
      currentPath = currentPath === "" ? folder : `${currentPath}/${folder}`;
      const normalized = (0, import_obsidian12.normalizePath)(currentPath);
      const exists = this.app.vault.getAbstractFileByPath(normalized);
      if (!exists) {
        await this.app.vault.createFolder(normalized);
      }
    }
  }
  normalizePath(path5) {
    return (0, import_obsidian12.normalizePath)(path5);
  }
  async getNoteHeadings(path5) {
    const file = this.app.vault.getAbstractFileByPath(path5);
    if (file instanceof import_obsidian12.TFile) {
      const cache = this.app.metadataCache.getFileCache(file);
      return (cache == null ? void 0 : cache.headings) || [];
    }
    return [];
  }
  async updateBlockMetadata(path5, blockId, metadata) {
    const file = this.app.vault.getAbstractFileByPath(path5);
    if (file instanceof import_obsidian12.TFile) {
      const metaService = new MetadataService(this.app);
      await metaService.updateBlockMetadata(file, blockId, metadata);
    }
  }
  mapToNoteItem(file) {
    return {
      path: file.path,
      name: file.name,
      extension: file.extension,
      basename: file.basename
    };
  }
};

// src/Infrastructure/Obsidian/Utils/TemplateContext.ts
var TemplateContext = class {
  static get activeConfig() {
    return this._activeConfig;
  }
  static set activeConfig(config) {
    this._activeConfig = config;
  }
};
TemplateContext._activeConfig = null;

// src/Infrastructure/Obsidian/Commands/ApplyTemplateCommand/ApplyTemplateCommand.ts
var ApplyTemplateCommand = class {
  constructor(llm, imageEnricher, obsidian, settings) {
    this.llm = llm;
    this.imageEnricher = imageEnricher;
    this.obsidian = obsidian;
    this.settings = settings;
  }
  async execute(targetFile, promptUrl) {
    console.log("[ApplyTemplateCommand] Start");
    const view = getActiveMarkdownView(this.obsidian, targetFile);
    const file = targetFile != null ? targetFile : view == null ? void 0 : view.file;
    if (!file) {
      showMessage("Open a markdown note to apply a template.");
      return;
    }
    const matches = await getAllTemplateConfigs(this.obsidian);
    if (matches.length === 0) {
      showMessage(`No templates found.`);
      return;
    }
    let templateResult = null;
    if (matches.length === 1) {
      templateResult = matches[0];
    } else {
      templateResult = await new Promise((resolve) => {
        new GenericFuzzySuggestModal(
          this.obsidian,
          matches,
          (item) => item.templateFile.basename,
          () => {
          },
          resolve
        ).open();
      });
    }
    if (!templateResult) {
      showMessage("No template selected.");
      return;
    }
    await this.applyTemplate(file, templateResult, promptUrl);
  }
  async applyTemplate(file, templateResult, predefinedPromptUrl) {
    var _a2, _b;
    console.log(`[ApplyTemplateCommand] applying template ${templateResult.templateFile.basename} to ${file.path}`);
    const { config, cleanedContent, templateFile } = templateResult;
    showMessage(`Applying template ${templateFile.basename}...`);
    const currentContent = await this.obsidian.vault.read(file);
    const mergedContent = mergeNotes(cleanedContent, currentContent, false);
    const mergedSplit = splitFrontmatter(mergedContent);
    let mergedFrontmatter = parseFrontmatter(mergedSplit.frontmatterText);
    const recomposedSegments = [];
    let finalFrontmatter = mergedFrontmatter;
    if (mergedFrontmatter) {
      recomposedSegments.push(formatFrontmatterBlock(mergedFrontmatter));
    }
    const normalizedBody = mergedSplit.body;
    if (normalizedBody) {
      recomposedSegments.push(normalizedBody);
    }
    let finalContent = recomposedSegments.join("\n\n");
    const promptUrl = config.promptUrl || mergedFrontmatter && mergedFrontmatter["!!promptUrl"] || predefinedPromptUrl;
    if (config.prompt) {
      let urlContext = "";
      if (promptUrl) {
        try {
          console.log(`[ApplyTemplateCommand] Fetching content from ${promptUrl}`);
          const response = await (0, import_obsidian13.requestUrl)(promptUrl);
          urlContext = response.text;
          console.log(`[ApplyTemplateCommand] Fetched ${urlContext.length} chars from ${promptUrl}`);
        } catch (e) {
          console.error(`[ApplyTemplateCommand] Failed to fetch promptUrl: ${promptUrl}`, e);
          showMessage(`Failed to fetch content from ${promptUrl}`);
        }
      }
      const prompt = this.buildPrompt(file.basename, mergedFrontmatter, config.prompt, normalizedBody, urlContext);
      console.log("[ApplyTemplateCommand] Requesting enrichment with prompt:", prompt);
      console.time("[ApplyTemplateCommand] AI Enrichment Time");
      const enrichment = await this.llm.requestEnrichment({
        prompt
      });
      console.timeEnd("[ApplyTemplateCommand] AI Enrichment Time");
      console.log("[ApplyTemplateCommand] Enrichment received:", enrichment);
      if (enrichment) {
        if (enrichment.frontmatter) {
          delete enrichment.frontmatter.tags;
          delete enrichment.frontmatter.tag;
        }
        let updatedFrontmatter = mergeFrontmatterSuggestions(
          mergedFrontmatter,
          enrichment.frontmatter
        );
        if (updatedFrontmatter && Array.isArray(updatedFrontmatter[import_core10.FrontmatterKeys.EloImages]) && updatedFrontmatter[import_core10.FrontmatterKeys.EloImages].length === 0) {
          const images = await this.imageEnricher.searchImages(file.basename, 3);
          if (images.length > 0) {
            updatedFrontmatter = {
              ...updatedFrontmatter,
              [import_core10.FrontmatterKeys.EloImages]: images
            };
          }
        }
        if (updatedFrontmatter) {
          finalFrontmatter = updatedFrontmatter;
        }
        const frontmatterBlock = updatedFrontmatter ? formatFrontmatterBlock(updatedFrontmatter) : "";
        const bodyFromGemini = enrichment.body !== void 0 && enrichment.body !== null ? enrichment.body.trim() : normalizedBody || "";
        const segments = [];
        if (frontmatterBlock) {
          segments.push(frontmatterBlock);
        }
        if (bodyFromGemini) {
          segments.push(bodyFromGemini);
        }
        finalContent = segments.join("\n\n");
      }
    }
    console.log("[ApplyTemplateCommand] Setting file content to:", finalContent);
    await this.obsidian.vault.modify(file, finalContent);
    console.log("[ApplyTemplateCommand] File content updated.");
    if (finalFrontmatter) {
      const noteManager = new ObsidianNoteManager(this.obsidian);
      const organizer = new PersonasNoteOrganizer(noteManager);
      await organizer.organize(file, finalFrontmatter);
    }
    if (config.path) {
      try {
        const targetPath = config.path.endsWith(".md") ? (0, import_obsidian13.normalizePath)(config.path) : (0, import_obsidian13.normalizePath)(`${config.path}/${file.name}`);
        await ensureFolderExists(this.obsidian, targetPath);
        const existing = this.obsidian.vault.getAbstractFileByPath(targetPath);
        if (!existing || existing === file) {
          await this.obsidian.fileManager.renameFile(file, targetPath);
        } else {
          showMessage(`File already exists at ${targetPath}. Cannot move.`);
        }
      } catch (e) {
        console.error("Error moving file based on template config:", e);
        showMessage(`Error moving file: ${e.message}`);
      }
    }
    if (config.commands && Array.isArray(config.commands)) {
      console.log("[ApplyTemplateCommand] Starting execution of !!commands (post-AI, post-Edit)");
      let leaf = this.obsidian.workspace.getLeavesOfType("markdown").find((leaf2) => leaf2.view.file === file);
      if (!leaf) {
        console.log(`[ApplyTemplateCommand] Opening file ${file.path} to execute commands.`);
        leaf = this.obsidian.workspace.getLeaf(true);
        await leaf.openFile(file);
      }
      if (leaf) {
        this.obsidian.workspace.setActiveLeaf(leaf, { focus: true });
      }
      TemplateContext.activeConfig = config;
      try {
        for (const commandId of config.commands) {
          let command = (_a2 = this.obsidian.commands) == null ? void 0 : _a2.findCommand(commandId);
          let finalCommandId = commandId;
          if (!command) {
            finalCommandId = `elocuency:${commandId}`;
            command = (_b = this.obsidian.commands) == null ? void 0 : _b.findCommand(finalCommandId);
          }
          if (command) {
            try {
              console.log(`[ApplyTemplateCommand] Executing ${finalCommandId}`);
              if (command.callback) {
                await command.callback();
              } else if (command.editorCallback) {
                const activeView = leaf == null ? void 0 : leaf.view;
                if (activeView && activeView.file === file) {
                  await command.editorCallback(activeView.editor, activeView);
                } else {
                  console.warn(`[ApplyTemplateCommand] skipping editor command ${finalCommandId} because view is not active for file.`);
                }
              } else if (command.checkCallback) {
                await command.checkCallback(false);
              } else {
                this.obsidian.commands.executeCommandById(finalCommandId);
              }
            } catch (e) {
              console.error(`Error executing command ${finalCommandId}:`, e);
              showMessage(`Error executing command ${finalCommandId}: ${e.message}`);
            }
          } else {
            console.warn(`Command not found: ${commandId}`);
            showMessage(`Command not found: ${commandId}`);
          }
        }
      } finally {
        TemplateContext.activeConfig = null;
      }
    }
    console.log("[ApplyTemplateCommand] End");
  }
  buildPrompt(title, currentFrontmatter, promptTemplate, currentBody = "", urlContext = "") {
    const frontmatterCopy = currentFrontmatter ? { ...currentFrontmatter } : {};
    delete frontmatterCopy.tags;
    const frontmatterJson = JSON.stringify(frontmatterCopy, null, 2);
    return `Nota de obsidian:'${title}'

Frontmatter:'${frontmatterJson}'

Contenido actual de la nota:
${currentBody}

Contexto adicional (URL):
${urlContext}

Instrucci\xF3n:
${promptTemplate}

IMPORTANTE: Tu respuesta debe ser un objeto JSON V\xC1LIDO con las siguientes claves:
- "frontmatter": Objeto con los metadatos actualizados o nuevos (Opcional).
- "body": String con el contenido del cuerpo de la nota (markdown).

NO DEVUELVAS NADA M\xC1S QUE EL JSON. En los campos 'Obras' y 'Pa\xEDses' y todos los nombres propios, devu\xE9lvelos como links the markdown estilo: [[nombre]]`;
  }
};

// src/Infrastructure/Obsidian/Views/Modals/InputModal.ts
var import_obsidian14 = require("obsidian");
var InputModal = class extends import_obsidian14.Modal {
  constructor(app, config, onSubmit) {
    super(app);
    this.config = config;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.config.title });
    new import_obsidian14.Setting(contentEl).setName(this.config.label).then((setting) => {
      if (this.config.isTextArea) {
        setting.addTextArea((text) => {
          if (this.config.placeholder)
            text.setPlaceholder(this.config.placeholder);
          text.inputEl.rows = 5;
          text.inputEl.style.width = "100%";
          text.onChange((value) => {
            this.result = value;
          });
        });
      } else {
        setting.addText((text) => {
          if (this.config.placeholder)
            text.setPlaceholder(this.config.placeholder);
          text.onChange((value) => {
            this.result = value;
          });
        });
      }
    });
    new import_obsidian14.Setting(contentEl).addButton((btn) => btn.setButtonText(this.config.submitText || "Submit").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Infrastructure/Obsidian/Commands/ApplyTemplateCommand/ApplyTemplateWithUrlCommand.ts
var ApplyTemplateWithUrlCommand = class {
  constructor(llm, imageEnricher, obsidian, settings) {
    this.llm = llm;
    this.imageEnricher = imageEnricher;
    this.obsidian = obsidian;
    this.settings = settings;
  }
  async execute(targetFile) {
    console.log("[ApplyTemplateWithUrlCommand] Start");
    const view = getActiveMarkdownView(this.obsidian, targetFile);
    const file = targetFile != null ? targetFile : view == null ? void 0 : view.file;
    if (!file) {
      showMessage("Open a markdown note to apply a template.");
      return;
    }
    new InputModal(
      this.obsidian,
      {
        title: "Apply Template with Context URL",
        label: "Enter URL (e.g. source information)",
        placeholder: "https://...",
        submitText: "Next"
      },
      async (url) => {
        if (!url) {
          showMessage("URL is required.");
          return;
        }
        const applyTemplateCommand = new ApplyTemplateCommand(
          this.llm,
          this.imageEnricher,
          this.obsidian,
          this.settings
        );
        await applyTemplateCommand.execute(file, url);
      }
    ).open();
  }
};

// src/Infrastructure/Obsidian/Commands/Images/ApplyTemplateFromImageCommand/ApplyTemplateFromImageCommand.ts
var import_obsidian16 = require("obsidian");

// src/Infrastructure/Obsidian/Views/Modals/ImageSourceModal.ts
var import_obsidian15 = require("obsidian");
var ImageSourceModal = class extends import_obsidian15.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.mode = "path";
    this.pathResult = "";
    this.filesResult = null;
    this.folderNameResult = "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Fuente de im\xE1genes" });
    new import_obsidian15.Setting(contentEl).setName("Portapapeles").setDesc("Usar imagen copiada recientemente.").addButton(
      (btn) => btn.setButtonText("Pegar del Portapapeles").setIcon("clipboard-paste").onClick(async () => {
        try {
          const clipboardItems = await navigator.clipboard.read();
          for (const item of clipboardItems) {
            if (item.types.some((t) => t.startsWith("image/"))) {
              const blob = await item.getType(item.types.find((t) => t.startsWith("image/")));
              this.close();
              this.onSubmit({
                type: "clipboard",
                blob
              });
              return;
            }
          }
          showMessage("No se encontr\xF3 ninguna imagen en el portapapeles.");
        } catch (err) {
          console.error("Error reading clipboard:", err);
          showMessage("Error al leer el portapapeles. Aseg\xFArate de dar permisos.");
        }
      })
    );
    contentEl.createEl("hr");
    let pathInputText;
    const pathSetting = new import_obsidian15.Setting(contentEl).setName("Carpeta").setDesc("Selecciona una carpeta o introduce la ruta absoluta.").addText((text) => {
      pathInputText = text;
      text.setPlaceholder("/path/to/folder").setValue(this.pathResult).onChange((value) => {
        this.mode = "path";
        this.pathResult = value;
        this.filesResult = null;
      });
    });
    const fileInput = contentEl.createEl("input", {
      type: "file",
      attr: {
        webkitdirectory: "",
        style: "display: none;"
      }
    });
    fileInput.addEventListener("change", () => {
      if (fileInput.files && fileInput.files.length > 0) {
        this.mode = "files";
        this.filesResult = fileInput.files;
        const firstFile = fileInput.files[0];
        const relPath = firstFile.webkitRelativePath;
        if (relPath) {
          this.folderNameResult = relPath.split("/")[0];
        } else {
          this.folderNameResult = "Carpeta Seleccionada";
        }
        const label = `${this.folderNameResult} (${fileInput.files.length} archivos)`;
        this.pathResult = label;
        if (pathInputText) {
          pathInputText.setValue(label);
        }
      }
    });
    pathSetting.addButton(
      (btn) => btn.setButtonText("Explorar").onClick(() => {
        fileInput.click();
      })
    );
    new import_obsidian15.Setting(contentEl).addButton((btn) => btn.setButtonText("Procesar").setCta().onClick(() => {
      this.close();
      if (this.mode === "files" && this.filesResult) {
        this.onSubmit({
          type: "files",
          files: this.filesResult,
          folderName: this.folderNameResult
        });
      } else if (this.pathResult && this.mode === "path") {
        this.onSubmit({
          type: "path",
          path: this.pathResult
        });
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Infrastructure/Obsidian/Utils/ImageProcessor.ts
var ImageProcessor = class {
  static async processImage(buffer, extension) {
    return new Promise((resolve) => {
      const blob = new Blob([buffer], { type: `image/${extension === "jpg" ? "jpeg" : extension}` });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => {
        URL.revokeObjectURL(url);
        const canvas = document.createElement("canvas");
        const MAX_SIZE = 1024;
        let width = img.width;
        let height = img.height;
        if (width > height) {
          if (width > MAX_SIZE) {
            height *= MAX_SIZE / width;
            width = MAX_SIZE;
          }
        } else {
          if (height > MAX_SIZE) {
            width *= MAX_SIZE / height;
            height = MAX_SIZE;
          }
        }
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          resolve(null);
          return;
        }
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL("image/jpeg", 0.8);
        resolve({
          data: dataUrl.split(",")[1],
          // Remove type prefix
          mimeType: "image/jpeg"
        });
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        resolve(null);
      };
      img.src = url;
    });
  }
  static async processBlob(blob) {
    const buffer = await blob.arrayBuffer();
    let extension = "jpg";
    if (blob.type === "image/png")
      extension = "png";
    if (blob.type === "image/webp")
      extension = "webp";
    return this.processImage(buffer, extension);
  }
};

// src/Infrastructure/Obsidian/Commands/Images/ApplyTemplateFromImageCommand/ApplyTemplateFromImageCommand.ts
var fs = __toESM(require("fs"));
var path2 = __toESM(require("path"));
var ApplyTemplateFromImageCommand = class {
  constructor(geminiImages, obsidian, settings) {
    this.geminiImages = geminiImages;
    this.obsidian = obsidian;
    this.settings = settings;
  }
  async execute(targetFile) {
    console.log("[ApplyTemplateFromImageCommand] Start");
    const view = getActiveMarkdownView(this.obsidian, targetFile);
    if (!(view == null ? void 0 : view.file)) {
      showMessage("Open a markdown note to apply a template.");
      console.log("[ApplyTemplateFromImageCommand] End (No active view)");
      return;
    }
    const file = view.file;
    const matches = await getAllTemplateConfigs(this.obsidian);
    if (matches.length === 0) {
      showMessage(`No templates found.`);
      return;
    }
    let templateResult = null;
    if (matches.length === 1) {
      templateResult = matches[0];
    } else {
      templateResult = await new Promise((resolve) => {
        new GenericFuzzySuggestModal(
          this.obsidian,
          matches,
          (item) => item.templateFile.basename,
          () => {
          },
          resolve
        ).open();
      });
    }
    if (!templateResult) {
      showMessage("No template selected.");
      return;
    }
    const { config, cleanedContent, templateFile } = templateResult;
    const promptTemplate = config.prompt;
    if (!promptTemplate) {
      showMessage("The selected template does not have a !!prompt configuration.");
      return;
    }
    new ImageSourceModal(this.obsidian, async (source) => {
      var _a2;
      let images = [];
      try {
        if (source.type === "clipboard") {
          const processed = await ImageProcessor.processBlob(source.blob);
          if (processed)
            images.push(processed);
        } else if (source.type === "path") {
          if (fs.existsSync(source.path)) {
            const files = await fs.promises.readdir(source.path);
            for (const f of files) {
              const ext = path2.extname(f).slice(1).toLowerCase();
              if (["jpg", "jpeg", "png", "webp"].includes(ext)) {
                const buffer = await fs.promises.readFile(path2.join(source.path, f));
                const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
                const processed = await ImageProcessor.processImage(arrayBuffer, ext);
                if (processed)
                  images.push(processed);
              }
            }
          }
        } else if (source.type === "files") {
          for (let i = 0; i < source.files.length; i++) {
            const f = source.files[i];
            const ext = ((_a2 = f.name.split(".").pop()) == null ? void 0 : _a2.toLowerCase()) || "";
            if (["jpg", "jpeg", "png", "webp"].includes(ext)) {
              const arrayBuffer = await f.arrayBuffer();
              const processed = await ImageProcessor.processImage(arrayBuffer, ext);
              if (processed)
                images.push(processed);
            }
          }
        }
      } catch (e) {
        console.error(e);
        showMessage("Error processing images.");
        return;
      }
      if (images.length === 0) {
        showMessage("No valid images selected.");
        return;
      }
      showMessage(`Applying template ${templateFile.basename} with ${images.length} images...`);
      const prompt = this.buildPrompt(file.basename, promptTemplate);
      try {
        const enrichment = await this.geminiImages.generateEnrichmentFromImages(images, prompt);
        if (enrichment) {
          await executeInEditMode(view, async () => {
            const editor = view.editor;
            const mergedContent = mergeNotes(cleanedContent, editor.getValue(), false);
            const mergedSplit = splitFrontmatter(mergedContent);
            const mergedFrontmatter = parseFrontmatter(mergedSplit.frontmatterText);
            let finalFrontmatter = mergedFrontmatter;
            if (enrichment.frontmatter) {
              finalFrontmatter = mergeFrontmatterSuggestions(mergedFrontmatter, enrichment.frontmatter);
            }
            const recomposedSegments = [];
            if (finalFrontmatter) {
              recomposedSegments.push(formatFrontmatterBlock(finalFrontmatter));
            }
            if (mergedSplit.body) {
              recomposedSegments.push(mergedSplit.body);
            }
            if (enrichment.body) {
              recomposedSegments.push(enrichment.body);
            }
            const finalContent = recomposedSegments.join("\n\n");
            editor.setValue(finalContent);
            if (finalFrontmatter) {
              const noteManager = new ObsidianNoteManager(this.obsidian);
              const organizer = new PersonasNoteOrganizer(noteManager);
              await organizer.organize(file, finalFrontmatter);
            }
            if (config.path) {
              try {
                const targetPath = config.path.endsWith(".md") ? (0, import_obsidian16.normalizePath)(config.path) : (0, import_obsidian16.normalizePath)(`${config.path}/${file.name}`);
                await ensureFolderExists(this.obsidian, targetPath);
                const existing = this.obsidian.vault.getAbstractFileByPath(targetPath);
                if (!existing || existing === file) {
                  await this.obsidian.fileManager.renameFile(file, targetPath);
                } else {
                  showMessage(`File already exists at ${targetPath}. Cannot move.`);
                }
              } catch (e) {
                console.error("Error moving file based on template config:", e);
                showMessage(`Error moving file: ${e.message}`);
              }
            }
            if (config.commands && Array.isArray(config.commands)) {
              TemplateContext.activeConfig = config;
              try {
                for (const commandId of config.commands) {
                  this.obsidian.commands.executeCommandById(commandId);
                }
              } finally {
                TemplateContext.activeConfig = null;
              }
            }
          });
          showMessage("Template applied successfully!");
        } else {
          showMessage("AI failed to generate content.");
        }
      } catch (e) {
        console.error("Error applying template from image:", e);
        showMessage("Error applying template.");
      }
    }).open();
    console.log("[ApplyTemplateFromImageCommand] End");
  }
  buildPrompt(title, promptTemplate) {
    return `Nota de obsidian:'${title}'

${promptTemplate}

`;
  }
};

// src/Infrastructure/Obsidian/Commands/Images/CreateNoteFromImagesCommand/CreateNoteFromImagesCommand.ts
var fs2 = __toESM(require("fs"));
var path3 = __toESM(require("path"));
var CreateNoteFromImagesCommand = class {
  constructor(app, adapter) {
    this.app = app;
    this.adapter = adapter;
  }
  async execute(file) {
    console.log("[CreateNoteFromImagesCommand] Start");
    new ImageSourceModal(this.app, async (source) => {
      if (source.type === "path") {
        await this.processFromPath(source.path, file);
      } else if (source.type === "files") {
        await this.processFromFiles(source.files, source.folderName, file);
      } else if (source.type === "clipboard") {
        await this.processFromBlob(source.blob, file);
      }
    }).open();
    console.log("[CreateNoteFromImagesCommand] End");
  }
  async processFromBlob(blob, targetFile) {
    const activeView = getActiveMarkdownView(this.app, targetFile);
    if (!activeView) {
      showMessage("No hay una nota activa para a\xF1adir el contenido.");
      return;
    }
    showMessage("Procesando imagen del portapapeles...");
    const imageContent = await ImageProcessor.processBlob(blob);
    if (imageContent) {
      await this.generateAndAppend([imageContent], "Clipboard", activeView);
    } else {
      showMessage("Error al procesar la imagen del portapapeles.");
    }
  }
  async processFromPath(folderPath, targetFile) {
    const activeView = getActiveMarkdownView(this.app, targetFile);
    if (!activeView) {
      showMessage("No hay una nota activa para a\xF1adir el contenido.");
      return;
    }
    showMessage(`Leyendo carpeta: ${folderPath}...`);
    if (!fs2.existsSync(folderPath)) {
      showMessage("La carpeta no existe.");
      return;
    }
    try {
      const files = await fs2.promises.readdir(folderPath);
      const folderName = path3.basename(folderPath);
      const images = files.filter((file) => this.isImage(file)).sort((a, b) => {
        return a.localeCompare(b, void 0, { numeric: true, sensitivity: "base" });
      });
      if (images.length === 0) {
        showMessage("No se encontraron im\xE1genes en la carpeta seleccionada.");
        return;
      }
      const imageContents = [];
      showMessage(`Se encontraron ${images.length} im\xE1genes. Preparando env\xEDo...`);
      for (const imageName of images) {
        const fullPath = path3.join(folderPath, imageName);
        try {
          const buffer = await fs2.promises.readFile(fullPath);
          const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
          const extension = path3.extname(imageName).slice(1);
          const processedImage = await ImageProcessor.processImage(arrayBuffer, extension);
          if (processedImage) {
            imageContents.push(processedImage);
          }
        } catch (error) {
          console.error(`Failed to process image ${imageName}`, error);
          showMessage(`Error al procesar la imagen ${imageName}`);
        }
      }
      await this.generateAndAppend(imageContents, folderName, activeView);
    } catch (error) {
      console.error("Error reading folder:", error);
      showMessage("Error al leer la carpeta.");
    }
  }
  async processFromFiles(fileList, folderName, targetFile) {
    const activeView = getActiveMarkdownView(this.app, targetFile);
    if (!activeView) {
      showMessage("No hay una nota activa para a\xF1adir el contenido.");
      return;
    }
    const files = Array.from(fileList);
    const images = files.filter((file) => this.isImage(file.name)).sort((a, b) => {
      return a.name.localeCompare(b.name, void 0, { numeric: true, sensitivity: "base" });
    });
    if (images.length === 0) {
      showMessage("No se encontraron im\xE1genes en la selecci\xF3n.");
      return;
    }
    const imageContents = [];
    showMessage(`Se encontraron ${images.length} im\xE1genes. Preparando env\xEDo...`);
    for (const file of images) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const extension = this.getExtension(file.name);
        const processedImage = await ImageProcessor.processImage(arrayBuffer, extension);
        if (processedImage) {
          imageContents.push(processedImage);
        }
      } catch (error) {
        console.error(`Failed to process image ${file.name}`, error);
        showMessage(`Error al procesar la imagen ${file.name}`);
      }
    }
    await this.generateAndAppend(imageContents, folderName, activeView);
  }
  async generateAndAppend(imageContents, folderName, activeView) {
    if (imageContents.length === 0) {
      showMessage("No se pudieron procesar las im\xE1genes.");
      return;
    }
    showMessage("Enviando a Gemini (esto puede tardar unos segundos)...");
    const result = await this.adapter.generateContentFromImages(imageContents);
    if (!result) {
      showMessage("No se obtuvo respuesta de Gemini.");
      return;
    }
    const contentToAppend = `
## Transcripci\xF3n Literal (${folderName})
${result.literal_transcription}

## An\xE1lisis (${folderName})
${result.analysis}
`.trim();
    try {
      await this.app.vault.append(activeView.file, "\n" + contentToAppend);
      showMessage("Contenido a\xF1adido a la nota activa.");
    } catch (error) {
      console.error("Error updating note:", error);
      showMessage("Error al actualizar la nota.");
    }
  }
  isImage(filename) {
    const extensions = ["png", "jpg", "jpeg", "webp"];
    return extensions.includes(this.getExtension(filename));
  }
  getExtension(filename) {
    const parts = filename.split(".");
    return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : "";
  }
};

// src/Infrastructure/Obsidian/Commands/Links/CreateReciprocityLinksNotesCommand/CreateReciprocityLinksNotesCommand.ts
var import_core11 = __toESM(require_dist());
var CreateReciprocityLinksNotesCommand = class {
  constructor(app) {
    this.app = app;
  }
  async execute(file) {
    console.log("[CreateReciprocityLinksNotesCommand] Start");
    const view = getActiveMarkdownView(this.app, file);
    if (!(view == null ? void 0 : view.file)) {
      showMessage("No active file");
      console.log("[CreateReciprocityLinksNotesCommand] End (No active file)");
      return;
    }
    await executeInEditMode(view, async () => {
      const activeFile = view.file;
      if (!activeFile)
        return;
      await this.processReciprocityFields(activeFile);
    });
    console.log("[CreateReciprocityLinksNotesCommand] End");
  }
  async processReciprocityFields(sourceFile) {
    var _a2;
    let sourceFrontmatter = (_a2 = this.app.metadataCache.getFileCache(sourceFile)) == null ? void 0 : _a2.frontmatter;
    if (!sourceFrontmatter) {
      sourceFrontmatter = {};
    }
    const registryEntries = Object.values(import_core11.FrontmatterRegistry).filter((entry) => entry.reciprocityField);
    for (const entry of registryEntries) {
      const fieldKey = entry.key;
      const reciprocityKey = entry.reciprocityField;
      const amongKey = entry.amongField;
      const rawValue = sourceFrontmatter[fieldKey];
      if (!rawValue)
        continue;
      const values = Array.isArray(rawValue) ? rawValue : [rawValue];
      const cleanNames = this.extractNames(values);
      const processedFiles = [];
      for (const name of cleanNames) {
        const processedFile = await this.handlePersonLink(sourceFile, name, reciprocityKey);
        if (processedFile) {
          processedFiles.push(processedFile);
        }
      }
      if (amongKey && processedFiles.length > 1) {
        await this.processAmongFields(processedFiles, amongKey);
      }
    }
  }
  extractNames(values) {
    return values.filter((v) => typeof v === "string").map((v) => v.replace(/\[\[|\]\]/g, "").split("|")[0].trim()).filter((v) => v.length > 0);
  }
  async handlePersonLink(sourceFile, personName, reciprocityKey) {
    let targetFile = await this.findNoteForPerson(personName);
    if (!targetFile) {
      targetFile = await this.resolvePersonNote(personName);
    }
    if (targetFile) {
      const currentLink = `[[${targetFile.basename}]]`;
      await this.updateLinkInSource(sourceFile, personName, targetFile.basename);
      await this.addReciprocityLink(targetFile, sourceFile, reciprocityKey);
      return targetFile;
    }
    return null;
  }
  async processAmongFields(files, amongKey) {
    for (const file of files) {
      const others = files.filter((f) => f.path !== file.path);
      for (const other of others) {
        await this.addReciprocityLink(file, other, amongKey);
      }
    }
  }
  async resolvePersonNote(name) {
    const preciseMatch = this.app.metadataCache.getFirstLinkpathDest(name, "");
    if (preciseMatch && this.isPersonaNote(preciseMatch)) {
      return preciseMatch;
    }
    const allFiles = this.app.vault.getMarkdownFiles();
    const candidates = allFiles.filter((file) => {
      if (file.basename.toLowerCase() === name.toLowerCase())
        return true;
      if (file.basename.toLowerCase().includes(name.toLowerCase()))
        return true;
      return false;
    }).filter((file) => this.isPersonaNote(file));
    const finalCandidates = candidates.map((file) => ({
      file,
      name: file.basename,
      description: file.path
    }));
    finalCandidates.push({
      file: null,
      name,
      description: "Create new note"
    });
    if (candidates.length === 0) {
      return this.createNewPersonNote(name);
    }
    const selected = await new Promise((resolve) => {
      new GenericFuzzySuggestModal(
        this.app,
        finalCandidates,
        (item) => `${item.name} (${item.description})`,
        () => {
        },
        resolve,
        "Select a person match or create new..."
      ).open();
    });
    if (selected) {
      if (selected.file) {
        return selected.file;
      } else {
        return this.createNewPersonNote(name);
      }
    }
    return null;
  }
  isPersonaNote(file) {
    var _a2;
    const cache = this.app.metadataCache.getFileCache(file);
    const tags = (_a2 = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a2.tags;
    if (Array.isArray(tags)) {
      return tags.includes("Personas");
    } else if (typeof tags === "string") {
      return tags === "Personas";
    }
    return false;
  }
  async createNewPersonNote(name) {
    const templatePath = "Personas/Persona";
    let templateFile = this.app.metadataCache.getFirstLinkpathDest(templatePath, "");
    if (!templateFile) {
      templateFile = this.app.metadataCache.getFirstLinkpathDest(templatePath + ".md", "");
    }
    if (!templateFile) {
      const allFiles = this.app.vault.getMarkdownFiles();
      templateFile = allFiles.find((f) => f.path.includes("Personas/Persona")) || null;
    }
    if (!templateFile) {
      showMessage(`Template '${templatePath}' not found.`);
      const newFile2 = await this.app.vault.create(`${name}.md`, "---\ntags: [Personas]\n---\n");
      return newFile2;
    }
    const templateContent = await this.app.vault.read(templateFile);
    let newFilePath = `${name}.md`;
    let counter = 1;
    while (await this.app.vault.adapter.exists(newFilePath)) {
      newFilePath = `${name} ${counter}.md`;
      counter++;
    }
    const newFile = await this.app.vault.create(newFilePath, templateContent);
    await this.app.fileManager.processFrontMatter(newFile, (fm) => {
      if (!fm.tags)
        fm.tags = [];
      if (Array.isArray(fm.tags) && !fm.tags.includes("Personas")) {
        fm.tags.push("Personas");
      } else if (typeof fm.tags === "string" && fm.tags !== "Personas") {
        fm.tags = [fm.tags, "Personas"];
      }
    });
    showMessage(`Created person note: ${newFile.basename}`);
    return newFile;
  }
  async findNoteForPerson(name) {
    return this.app.metadataCache.getFirstLinkpathDest(name, "");
  }
  async updateLinkInSource(sourceFile, oldName, newBasename) {
    if (oldName === newBasename)
      return;
    await this.app.fileManager.processFrontMatter(sourceFile, (fm) => {
      const registryEntries = Object.values(import_core11.FrontmatterRegistry).filter((entry) => entry.reciprocityField);
      for (const entry of registryEntries) {
        const key = entry.key;
        if (fm[key]) {
          if (Array.isArray(fm[key])) {
            fm[key] = fm[key].map((v) => {
              const cleanV = v.replace(/\[\[|\]\]/g, "").split("|")[0].trim();
              if (cleanV === oldName) {
                return `[[${newBasename}]]`;
              }
              return v;
            });
          } else if (typeof fm[key] === "string") {
            const cleanV = fm[key].replace(/\[\[|\]\]/g, "").split("|")[0].trim();
            if (cleanV === oldName) {
              fm[key] = `[[${newBasename}]]`;
            }
          }
        }
      }
    });
  }
  async addReciprocityLink(targetFile, sourceFile, reciprocityKey) {
    await this.app.fileManager.processFrontMatter(targetFile, (fm) => {
      const link = `[[${sourceFile.basename}]]`;
      if (!fm[reciprocityKey]) {
        fm[reciprocityKey] = [link];
      } else {
        let current = fm[reciprocityKey];
        if (!Array.isArray(current)) {
          current = [current];
        }
        const exists = current.some((v) => v.includes(sourceFile.basename));
        if (!exists) {
          current.push(link);
        }
        fm[reciprocityKey] = current;
      }
    });
    showMessage(`Updated ${reciprocityKey} in ${targetFile.basename}`);
  }
};

// src/Infrastructure/Obsidian/Commands/AI/EnhanceByAiCommand/EnhanceByAiCommand.ts
var import_core12 = __toESM(require_dist());
var EnhanceByAiCommand = class {
  constructor(app, settings, llm) {
    this.app = app;
    this.settings = settings;
    this.llm = llm;
  }
  async execute(targetFile) {
    console.log("[EnhanceByAiCommand] Start");
    const view = getActiveMarkdownView(this.app, targetFile);
    if (!(view == null ? void 0 : view.file)) {
      showMessage("Open a markdown note to enhance it.");
      console.log("[EnhanceByAiCommand] End (No active view)");
      return;
    }
    await executeInEditMode(view, async () => {
      const file = view.file;
      const editor = view.editor;
      const content = editor.getValue();
      const split = splitFrontmatter(content);
      const frontmatter = parseFrontmatter(split.frontmatterText) || {};
      const customPrompt = frontmatter[import_core12.FrontmatterKeys.EloPrompt];
      const customCommands = frontmatter[import_core12.FrontmatterKeys.EloCommands];
      let promptToUse = "";
      let includeFrontmatter = false;
      const contextConfig = TemplateContext.activeConfig;
      if (contextConfig && contextConfig.prompt) {
        promptToUse = contextConfig.prompt;
        includeFrontmatter = !!contextConfig.hasFrontmatter;
      }
      if (!promptToUse && customPrompt) {
        promptToUse = customPrompt;
        const cleanKeys = Object.keys(frontmatter).filter((k) => !k.startsWith("!!"));
        includeFrontmatter = cleanKeys.length > 0;
      }
      if (!promptToUse) {
        showMessage("No prompt configured in the template file or frontmatter (!!prompt).");
        return;
      }
      showMessage("Enhancing note with AI...");
      if (file) {
        const frontmatterForContext = { ...frontmatter };
        delete frontmatterForContext[import_core12.FrontmatterKeys.EloPrompt];
        delete frontmatterForContext[import_core12.FrontmatterKeys.EloCommands];
        const prompt = this.buildPrompt(file.basename, promptToUse, frontmatterForContext, split.body, includeFrontmatter, customCommands);
        const response = await this.llm.requestEnrichment({ prompt });
        if (response) {
          const frontmatterToProcess = response.frontmatter || {};
          const processedFrontmatter = this.processAiResponseFrontmatter(frontmatterToProcess);
          const updatedFrontmatter = applyFrontmatterUpdates(
            frontmatter,
            processedFrontmatter
          );
          const frontmatterBlock = updatedFrontmatter ? formatFrontmatterBlock(updatedFrontmatter) : "";
          const newContent = [frontmatterBlock, split.body, response.body].filter(Boolean).join("\n\n");
          editor.setValue(newContent);
          showMessage("Note enhanced!");
        } else {
          showMessage("AI enhancement failed.");
        }
      }
    });
    console.log("[EnhanceByAiCommand] End");
  }
  buildPrompt(title, settingPrompt, frontmatter, body, includeFrontmatter, customCommands) {
    const parts = [
      `Genera contenido para una nota de Obsidian: "${title}".`,
      `${settingPrompt}`
    ];
    if (customCommands) {
      if (Array.isArray(customCommands)) {
        parts.push(...customCommands);
      } else {
        parts.push(customCommands);
      }
    }
    parts.push(
      `Frontmatter actual (JSON): ${JSON.stringify(frontmatter)}`,
      `Cuerpo actual: "${body}"`,
      "Devuelve un JSON con los campos:",
      '"body": contenido para el cuerpo de la nota (no elimines informaci\xF3n del cuerpo actual, si ves informaci\xF3n incorrecta, comenta la incorrecci\xF3n explicitamente).'
    );
    if (includeFrontmatter) {
      parts.push('"frontmatter": objeto con claves y valores sugeridos para mejorar, corregir o completar el frontmatter actual. PUEDES SOBREMBSCRIBIR VALORES solo si tienes una mejor sugerencia.');
    }
    parts.push(
      "En el JSON, no envies caracteres que puedan hacer que el JSON no sea v\xE1lido."
    );
    return parts.join("\n");
  }
  processAiResponseFrontmatter(frontmatter) {
    if (!frontmatter)
      return frontmatter;
    const processed = {};
    const keyMap = /* @__PURE__ */ new Map();
    Object.keys(import_core12.FrontmatterRegistry).forEach((key) => {
      keyMap.set(key.toLowerCase(), key);
    });
    for (const [key, value] of Object.entries(frontmatter)) {
      let targetKey = key;
      const lowerKey = key.toLowerCase();
      if (keyMap.has(lowerKey)) {
        targetKey = keyMap.get(lowerKey);
      }
      const config = import_core12.FrontmatterRegistry[targetKey];
      let finalValue = value;
      if (config && config.asLink) {
        if (typeof value === "string") {
          finalValue = this.ensureBrackets(value);
        } else if (Array.isArray(value)) {
          finalValue = value.map((item) => {
            if (typeof item === "string") {
              return this.ensureBrackets(item);
            }
            return item;
          });
        }
      }
      processed[targetKey] = finalValue;
    }
    return processed;
  }
  ensureBrackets(value) {
    const trimmed = value.trim();
    if (trimmed.startsWith("[[") && trimmed.endsWith("]]")) {
      return trimmed;
    }
    return `[[${trimmed}]]`;
  }
};

// src/Infrastructure/Obsidian/Commands/GenerateHeaderMetadataCommand/GenerateHeaderMetadataCommand.ts
var GenerateHeaderMetadataCommand = class {
  constructor(app) {
    this.app = app;
    this.metadataService = new MetadataService(app);
  }
  async execute(targetFile) {
    console.log("[GenerateHeaderMetadataCommand] Start");
    const activeView = getActiveMarkdownView(this.app, targetFile);
    if (!activeView) {
      showMessage("No active markdown view");
      console.log("[GenerateHeaderMetadataCommand] End (No active view)");
      return;
    }
    const file = activeView.file;
    if (!file) {
      showMessage("No active file");
      console.log("[GenerateHeaderMetadataCommand] End (No active file)");
      return;
    }
    await this.processFile(file);
    console.log("[GenerateHeaderMetadataCommand] End");
  }
  async processFile(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache || !cache.headings) {
      showMessage("No headings found in this file.");
      return;
    }
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const blockIds = [];
    let modified = false;
    for (const heading of cache.headings) {
      const lineIndex = heading.position.start.line;
      const lineContent = lines[lineIndex];
      const existingId = this.metadataService.ensureBlockId(heading);
      const idRegex = /\^([a-zA-Z0-9-]+)$/;
      const match = lineContent.match(idRegex);
      if (match) {
        blockIds.push(match[1]);
      } else {
        const newId = this.metadataService.ensureBlockId(heading);
        lines[lineIndex] = `${lineContent} ^${newId}`;
        blockIds.push(newId);
        modified = true;
      }
    }
    if (modified) {
      await this.app.vault.modify(file, lines.join("\n"));
      showMessage("Added missing Block IDs to headers.");
    }
    await this.metadataService.syncMetadata(file, blockIds);
    showMessage("Header metadata synced to JSON.");
  }
};

// src/Infrastructure/Obsidian/Commands/Links/GenerateMissingNotesFromLinksCommand/GenerateMissingNotesFromLinksCommand.ts
var import_obsidian17 = require("obsidian");
var GenerateMissingNotesFromLinksCommand = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  async execute(file) {
    var _a2;
    console.log("[GenerateMissingNotesFromLinksCommand] Start");
    const activeFile = file != null ? file : this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian17.Notice("No active file found to generate missing notes for.");
      console.log("[GenerateMissingNotesFromLinksCommand] End (No active file)");
      return;
    }
    const unresolved = this.app.metadataCache.unresolvedLinks;
    const plannedCreations = /* @__PURE__ */ new Map();
    const unresolvedEntries = Object.entries(unresolved).filter(([sourcePath]) => {
      return sourcePath === activeFile.path;
    });
    if (unresolvedEntries.length === 0) {
      new import_obsidian17.Notice("No unresolved links found in this note.");
      console.log("[GenerateMissingNotesFromLinksCommand] End (No unresolved links)");
      return;
    }
    for (const [sourcePath, linkMap] of unresolvedEntries) {
      const folder = this.resolveFolderForSource(
        sourcePath,
        this.settings.locationStrategy,
        this.settings.targetFolder
      );
      for (const linkName of Object.keys(linkMap)) {
        const targetPath = this.buildTargetPath(linkName, folder);
        if (!targetPath)
          continue;
        if (!plannedCreations.has(targetPath)) {
          plannedCreations.set(targetPath, {
            targetPath,
            linkName,
            sources: []
          });
        }
        (_a2 = plannedCreations.get(targetPath)) == null ? void 0 : _a2.sources.push({
          file: sourcePath,
          originalLink: linkName
        });
      }
    }
    let createdPaths = [];
    let skippedPaths = [];
    let linkedPaths = [];
    for (const planning of plannedCreations.values()) {
      const { targetPath, linkName, sources } = planning;
      if (await pathExists(this.app, targetPath)) {
        skippedPaths.push(targetPath);
        continue;
      }
      const candidates = this.findSimilarFiles(linkName);
      let chosenFile = null;
      let shouldCreate = true;
      if (candidates.length > 0) {
        const decision = await this.promptUserForDecision(linkName, candidates);
        if (decision === "create") {
          shouldCreate = true;
        } else if (decision instanceof import_obsidian17.TFile) {
          shouldCreate = false;
          chosenFile = decision;
        } else {
          skippedPaths.push(linkName);
          continue;
        }
      }
      if (shouldCreate) {
        await ensureFolderExists(this.app, targetPath);
        const content = this.renderTemplate(linkName, this.settings.missingNotesTemplatePath);
        await this.app.vault.create(targetPath, content);
        createdPaths.push(targetPath);
      } else if (chosenFile) {
        await this.updateLinksToExistingFile(sources, chosenFile);
        linkedPaths.push(chosenFile.path);
      }
    }
    showMessage(this.buildNoticeNew(createdPaths.length, skippedPaths.length, linkedPaths.length));
    console.log("[GenerateMissingNotesFromLinksCommand] End");
  }
  findSimilarFiles(linkName) {
    const allFiles = this.app.vault.getMarkdownFiles();
    const cleanLink = this.sanitizeLinkName(linkName).toLowerCase();
    return allFiles.filter((file) => {
      if (file.path.includes("/!!") || file.path.startsWith("!!") || file.path.includes("/.obsidian") || file.path.startsWith(".obsidian")) {
        return false;
      }
      const score = similarity(cleanLink, file.basename.toLowerCase());
      return score > 0.6;
    }).sort((a, b) => {
      const scoreA = similarity(cleanLink, a.basename.toLowerCase());
      const scoreB = similarity(cleanLink, b.basename.toLowerCase());
      return scoreB - scoreA;
    }).slice(0, 5);
  }
  async promptUserForDecision(linkName, candidates) {
    return new Promise((resolve) => {
      const options = [
        ...candidates,
        { label: `Create new note: "${linkName}"`, action: "create" }
      ];
      const modal = new GenericFuzzySuggestModal(
        this.app,
        options,
        (item) => {
          if (item instanceof import_obsidian17.TFile)
            return `Link to: ${item.basename} (${item.path})`;
          return item.label;
        },
        (item) => {
        },
        (item) => {
          if (item === null)
            resolve(null);
          else if (item instanceof import_obsidian17.TFile)
            resolve(item);
          else
            resolve("create");
        },
        `Unresolved link: "[[${linkName}]]". Choose action:`
      );
      modal.open();
    });
  }
  async updateLinksToExistingFile(sources, targetFile) {
    for (const source of sources) {
      const file = this.app.vault.getAbstractFileByPath(source.file);
      if (!(file instanceof import_obsidian17.TFile))
        continue;
      await this.app.fileManager.processFrontMatter(file, () => {
      });
      let content = await this.app.vault.read(file);
      const escaped = source.originalLink.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const regex = new RegExp(`\\[\\[${escaped}\\]\\]`, "g");
      const newLinkBase = targetFile.basename;
      let newLinkInner = newLinkBase;
      if (source.originalLink.includes("|")) {
        const parts = source.originalLink.split("|");
        const alias = parts.slice(1).join("|");
        newLinkInner = `${newLinkBase}|${alias}`;
      }
      content = content.replace(regex, `[[${newLinkInner}]]`);
      await this.app.vault.modify(file, content);
    }
  }
  buildNoticeNew(created, skipped, linked) {
    const parts = [];
    if (created > 0)
      parts.push(`Created ${created} new notes.`);
    if (linked > 0)
      parts.push(`Linked ${linked} to existing notes.`);
    if (skipped > 0)
      parts.push(`Skipped ${skipped}.`);
    if (parts.length === 0)
      return "No unresolved links processed.";
    return parts.join(" ");
  }
  /* Old methods kept for compatibility if needed, or remove if unused */
  resolveFolderForSource(sourcePath, strategy, targetFolder) {
    if (strategy === "fixed-folder") {
      return targetFolder.trim();
    }
    const lastSlashIndex = sourcePath.lastIndexOf("/");
    if (lastSlashIndex === -1) {
      return "";
    }
    return sourcePath.slice(0, lastSlashIndex + 1);
  }
  buildTargetPath(linkName, baseFolder) {
    const sanitized = this.sanitizeLinkName(linkName);
    if (!sanitized) {
      return null;
    }
    const folder = baseFolder ? baseFolder.replace(/\/+$/, "") + "/" : "";
    const fullPath = `${folder}${sanitized}.md`;
    return (0, import_obsidian17.normalizePath)(fullPath);
  }
  sanitizeLinkName(linkName) {
    var _a2;
    const name = (_a2 = linkName.split("|")[0]) == null ? void 0 : _a2.trim();
    if (!name) {
      return "";
    }
    return name.replace(/\\/g, "/").replace(/:+/g, " -").replace(/[\n\r\t]/g, " ").replace(/\s+/g, " ").trim();
  }
  renderTemplate(linkName, template) {
    var _a2, _b, _c, _d;
    const title = (_d = (_c = (_a2 = linkName.split("|")[1]) == null ? void 0 : _a2.trim()) != null ? _c : (_b = linkName.split("|")[0]) == null ? void 0 : _b.trim()) != null ? _d : "";
    return template.replace(/{{title}}/g, title);
  }
};

// src/Infrastructure/Obsidian/Commands/RelocateNoteByLinkFieldCommand/RelocateNoteByLinkFieldCommand.ts
var import_obsidian18 = require("obsidian");
var import_core13 = __toESM(require_dist());
var import_core14 = __toESM(require_dist());
var RelocateNoteByLinkFieldCommand = class {
  constructor(app) {
    this.app = app;
  }
  async execute(targetFile) {
    console.log("[RelocateNoteByLinkFieldCommand] Start");
    const view = getActiveMarkdownView(this.app, targetFile);
    if (!(view == null ? void 0 : view.file)) {
      showMessage("No active file");
      console.log("[RelocateNoteByLinkFieldCommand] End (No active view)");
      return;
    }
    await executeInEditMode(view, async () => {
      var _a2, _b, _c, _d;
      const activeFile = view.file;
      console.log("RelocateteNoteCommand: Active file", activeFile == null ? void 0 : activeFile.path);
      if (!activeFile)
        return;
      const frontmatter = (_a2 = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a2.frontmatter;
      if (!frontmatter) {
        showMessage("No frontmatter found in active file");
        return;
      }
      const registryValues = Object.values(import_core13.FrontmatterRegistry);
      const candidateFields = registryValues.filter((entry) => entry.isRelocateField);
      if (candidateFields.length === 0) {
        showMessage("No field configured for reallocation (isRelocateField=true) in registry");
        return;
      }
      let targetFieldInfo = void 0;
      let rawValue = void 0;
      for (const candidate of candidateFields) {
        const val = frontmatter[candidate.key];
        if (val !== void 0 && val !== null && val !== "") {
          if (Array.isArray(val) && val.length === 0) {
            continue;
          }
          targetFieldInfo = candidate;
          rawValue = val;
          break;
        }
      }
      if (!targetFieldInfo || !rawValue) {
        showMessage("No valid reallocation field found in current note");
        return;
      }
      let linkText = "";
      if (Array.isArray(rawValue)) {
        if (rawValue.length > 0) {
          linkText = rawValue[0];
        }
      } else if (typeof rawValue === "string") {
        linkText = rawValue;
      }
      if (!linkText) {
        showMessage(`Value in '${targetFieldInfo.key}' is invalid`);
        return;
      }
      const linkMatch = linkText.match(/\[\[(.*?)(?:\|.*)?\]\]/);
      const pathOrName = linkMatch ? linkMatch[1] : linkText;
      const targetFile2 = this.app.metadataCache.getFirstLinkpathDest(pathOrName, activeFile.path);
      if (!targetFile2) {
        showMessage(`Could not resolve link: ${pathOrName}`);
        return;
      }
      if (!(targetFile2 instanceof import_obsidian18.TFile)) {
        showMessage(`Target is not a file: ${pathOrName}`);
        return;
      }
      let targetFolder = targetFile2.parent;
      if (!targetFolder) {
        showMessage("Target file has no parent folder (root?)");
        return;
      }
      const cache = this.app.metadataCache.getFileCache(activeFile);
      let tags = [];
      if (cache) {
        tags = (0, import_obsidian18.getAllTags)(cache) || [];
      }
      console.log("RelocateNote: Cache found:", !!cache);
      console.log("RelocateNote: getAllTags result:", tags);
      const fmTags = frontmatter["tags"] || frontmatter["Tags"] || frontmatter["tag"];
      let fmTagList = Array.isArray(fmTags) ? fmTags : fmTags ? [fmTags] : [];
      console.log("RelocateNote: Frontmatter tags (cache):", fmTagList);
      try {
        const content = view.editor.getValue();
        const match = content.match(/^---\n([\s\S]*?)\n---/);
        if (match) {
          const yamlRaw = match[1];
          const parsed = (0, import_obsidian18.parseYaml)(yamlRaw);
          if (parsed) {
            const manualTags = parsed["tags"] || parsed["Tags"] || parsed["tag"];
            const manualTagList = Array.isArray(manualTags) ? manualTags : manualTags ? [manualTags] : [];
            if (manualTagList.length > 0) {
              console.log("RelocateNote: Manual YAML parse found tags:", manualTagList);
              fmTagList = [.../* @__PURE__ */ new Set([...fmTagList, ...manualTagList])];
            }
          }
        }
      } catch (e) {
        console.error("RelocateNote: Manual YAML parsing failed", e);
      }
      const allTags = [...tags, ...fmTagList];
      console.log("RelocateNote: Combined tag list final:", allTags);
      const normalizedTags = new Set(
        allTags.filter((t) => t !== null && t !== void 0).map((t) => String(t).trim().normalize("NFC").toLowerCase().replace(/^#/, ""))
      );
      let targetFolderSuffix;
      for (const [tagKey, folderSuffix] of Object.entries(import_core14.TagFolderMappingRegistry)) {
        if (normalizedTags.has(tagKey.normalize("NFC").toLowerCase())) {
          targetFolderSuffix = folderSuffix;
          break;
        }
      }
      console.log("RelocateNote: determined suffix:", targetFolderSuffix);
      const isTargetLugar = targetFolder.path.startsWith("Lugares");
      let finalFolderPath = targetFolder.path;
      if (isTargetLugar && targetFolderSuffix) {
        finalFolderPath = `${targetFolder.path}/${targetFolderSuffix}`;
        if (finalFolderPath !== targetFolder.path) {
          const folderExists = await this.app.vault.adapter.exists(finalFolderPath);
          if (!folderExists) {
            await this.app.vault.createFolder(finalFolderPath);
          }
        }
      }
      if (((_b = activeFile.parent) == null ? void 0 : _b.name) === activeFile.basename) {
        console.log("RelocateNote: Note is in a folder with the same name (Folder Note), skipping relocation.");
        return;
      }
      console.log("RelocateteNoteCommand: From", (_c = activeFile.parent) == null ? void 0 : _c.path);
      console.log("RelocateteNoteCommand: To", finalFolderPath);
      if (((_d = activeFile.parent) == null ? void 0 : _d.path) === finalFolderPath) {
        showMessage("Note is already in the target folder");
        return;
      }
      try {
        const newPath = `${finalFolderPath}/${activeFile.name}`;
        await moveFile(this.app, activeFile, newPath);
        showMessage(`Moved note to ${finalFolderPath}`);
      } catch (error) {
        console.error(error);
        showMessage(`Failed to move note: ${error}`);
      }
    });
    console.log("[RelocateNoteByLinkFieldCommand] End");
  }
};

// src/Infrastructure/Obsidian/Commands/Music/SearchSpotifyArtistCommand/SearchSpotifyArtistCommand.ts
var import_obsidian20 = require("obsidian");

// src/Infrastructure/Obsidian/Views/Modals/SpotifyArtistSelectionModal.ts
var import_obsidian19 = require("obsidian");
var SpotifyArtistSelectionModal = class extends import_obsidian19.SuggestModal {
  constructor(app, artists, onSelected) {
    super(app);
    this.artists = artists;
    this.onSelected = onSelected;
  }
  getSuggestions(query) {
    return this.artists.filter(
      (artist) => artist.name.toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(artist, el) {
    const div = el.createDiv();
    div.createEl("b", { text: artist.name });
    div.createEl("br");
    const details = [];
    if (artist.genres && artist.genres.length > 0) {
      details.push(`Genres: ${artist.genres.slice(0, 3).join(", ")}`);
    }
    if (artist.popularity !== void 0) {
      details.push(`Popularity: ${artist.popularity}`);
    }
    div.createEl("small", { text: details.join(" | ") });
  }
  onChooseSuggestion(artist, evt) {
    this.onSelected(artist);
  }
};

// src/Infrastructure/Obsidian/Commands/Music/SearchSpotifyArtistCommand/SearchSpotifyArtistCommand.ts
var import_core15 = __toESM(require_dist());
var SearchSpotifyArtistCommand = class {
  constructor(app, spotifyAdapter, onAuthRequired) {
    this.app = app;
    this.spotifyAdapter = spotifyAdapter;
    this.onAuthRequired = onAuthRequired;
    this.id = "search-spotify-artist";
    this.name = "Search Spotify Artist";
  }
  checkCallback(checking) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian20.MarkdownView);
    if (view) {
      if (!checking) {
        this.execute(view);
      }
      return true;
    }
    return false;
  }
  async execute(view) {
    console.log("[SearchSpotifyArtistCommand] Start");
    if (!this.spotifyAdapter.isAuthenticated()) {
      this.onAuthRequired();
      console.log("[SearchSpotifyArtistCommand] End (Auth required)");
      return;
    }
    const file = view.file;
    if (!file)
      return;
    const query = file.basename;
    showMessage(`Searching for artist: ${query}...`);
    try {
      const artists = await this.spotifyAdapter.searchArtists(query);
      if (artists.length === 0) {
        showMessage("No artists found on Spotify.");
        console.log("[SearchSpotifyArtistCommand] End (No artists found)");
        return;
      }
      if (artists.length === 1) {
        this.updateFrontmatter(file, artists[0]);
        showMessage(`Spotify artist data updated for: ${artists[0].name}`);
      } else {
        new SpotifyArtistSelectionModal(view.app, artists, (selectedArtist) => {
          this.updateFrontmatter(file, selectedArtist);
          showMessage(`Spotify artist data updated for: ${selectedArtist.name}`);
        }).open();
      }
    } catch (error) {
      console.error(error);
      showMessage("Error searching Spotify actions.");
    }
    console.log("[SearchSpotifyArtistCommand] End");
  }
  async updateFrontmatter(file, artist) {
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      frontmatter[import_core15.FrontmatterKeys.SpotifyUri] = artist.uri;
      frontmatter[import_core15.FrontmatterKeys.EstilosMusicales] = artist.genres;
      frontmatter[import_core15.FrontmatterKeys.EloImages] = artist.images ? artist.images.map((img) => img.url) : [];
      frontmatter[import_core15.FrontmatterKeys.SpotifyPopularity] = artist.popularity;
    });
    if (file.basename !== artist.name) {
      const parentPath = file.parent ? file.parent.path : "";
      const newPath = (parentPath === "/" ? "" : parentPath + "/") + artist.name + ".md";
      try {
        await this.app.fileManager.renameFile(file, newPath);
        showMessage(`Renamed note to: ${artist.name}`);
      } catch (error) {
        console.error("Failed to rename file:", error);
        showMessage(`Failed to rename note to ${artist.name}. File might already exist.`);
      }
    }
  }
};

// src/Infrastructure/Obsidian/Utils/GoogleMapsUrlParser.ts
var GoogleMapsUrlParser = class {
  static extractPlaceId(url) {
    const chijRegex = /ChIJ[a-zA-Z0-9_-]{23}/;
    const chijMatch = url.match(chijRegex);
    if (chijMatch) {
      return chijMatch[0];
    }
    const hexRegex = /!1s(0x[a-fA-F0-9]+:0x[a-fA-F0-9]+)/;
    const hexMatch = url.match(hexRegex);
    if (hexMatch && hexMatch[1]) {
      return hexMatch[1];
    }
    return null;
  }
  static extractName(url) {
    try {
      const nameRegex = /\/place\/([^/]+)\//;
      const match = url.match(nameRegex);
      if (match && match[1]) {
        const decoded = decodeURIComponent(match[1].replace(/\+/g, " "));
        return decoded;
      }
    } catch (e) {
      console.error("Error extracting name from URL", e);
    }
    return null;
  }
};

// src/Infrastructure/Obsidian/Commands/Place/AddPlaceIdFromUrlCommand/AddPlaceIdFromUrlCommand.ts
var AddPlaceIdFromUrlCommand = class {
  constructor(geocoder, llm, app) {
    this.geocoder = geocoder;
    this.llm = llm;
    this.app = app;
    this.enrichmentService = new PlaceEnrichmentService(geocoder, llm);
  }
  async execute(file) {
    console.log("[AddPlaceIdFromUrlCommand] Start");
    const view = getActiveMarkdownView(this.app, file);
    if (!(view == null ? void 0 : view.file)) {
      showMessage("Abre una nota de markdown para a\xF1adir el Place ID.");
      console.log("[AddPlaceIdFromUrlCommand] End (No active view)");
      return;
    }
    const activeFile = view.file;
    new InputModal(
      this.app,
      {
        title: "A\xF1adir Place ID desde URL",
        label: "Google Maps URL",
        placeholder: "Pega la URL aqu\xED (ej: https://maps.app.goo.gl/...)",
        submitText: "Buscar ID"
      },
      async (url) => {
        if (!url)
          return;
        await this.processUrl(url, activeFile, view);
      }
    ).open();
    console.log("[AddPlaceIdFromUrlCommand] End");
  }
  async processUrl(url, file, view) {
    const placeId = GoogleMapsUrlParser.extractPlaceId(url);
    const placeName = GoogleMapsUrlParser.extractName(url);
    if (!placeId && !placeName) {
      showMessage("No se encontr\xF3 un Place ID o nombre v\xE1lido en la URL.");
      return;
    }
    if (placeId) {
      showMessage(`ID encontrado: ${placeId}. Obteniendo detalles...`);
    } else {
      showMessage(`Lugar encontrado: ${placeName}. Obteniendo detalles...`);
    }
    const details = await this.geocoder.requestPlaceDetails({
      placeName: placeName != null ? placeName : "",
      placeId: placeId != null ? placeId : void 0
    });
    if (!details) {
      showMessage("No se pudieron obtener detalles del lugar.");
      return;
    }
    if (!details.googlePlaceId) {
      showMessage("La API no devolvi\xF3 un Place ID confirmado.");
      return;
    }
    await executeInEditMode(view, async () => {
      var _a2;
      const content = await this.app.vault.read(file);
      const split = splitFrontmatter(content);
      const currentFrontmatter = (_a2 = parseFrontmatter(split.frontmatterText)) != null ? _a2 : {};
      const updatedFrontmatter = this.enrichmentService.mergeFrontmatter(currentFrontmatter, details);
      const frontmatterBlock = formatFrontmatterBlock(updatedFrontmatter);
      const normalizedBody = split.body.replace(/^[\n\r]+/, "");
      const segments = [];
      if (frontmatterBlock)
        segments.push(frontmatterBlock);
      if (normalizedBody)
        segments.push(normalizedBody);
      const finalContent = segments.join("\n\n");
      if (finalContent !== content) {
        await this.app.vault.modify(file, finalContent);
        showMessage(`Place ID actualizado: ${details.googlePlaceId}`);
      } else {
        showMessage("La nota ya estaba actualizada.");
      }
    });
  }
};

// src/Infrastructure/Obsidian/Views/Modals/EntitySelectionModal.ts
var import_obsidian21 = require("obsidian");
var EntitySelectionModal = class extends import_obsidian21.Modal {
  constructor(app, entities, onConfirm) {
    super(app);
    this.entities = entities;
    this.onConfirm = onConfirm;
    this.selectedEntities = new Set(entities.filter((e) => e.relevance === "High"));
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Review Entities to Link" });
    this.entities.forEach((entity) => {
      new import_obsidian21.Setting(contentEl).setName(`${entity.name} (${entity.type})`).setDesc(`Relevance: ${entity.relevance}`).addToggle((toggle) => toggle.setValue(entity.relevance === "High").onChange((value) => {
        if (value) {
          this.selectedEntities.add(entity);
        } else {
          this.selectedEntities.delete(entity);
        }
      }));
    });
    new import_obsidian21.Setting(contentEl).addButton((btn) => btn.setButtonText("Process Selected").setCta().onClick(() => {
      this.close();
      this.onConfirm(Array.from(this.selectedEntities));
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Infrastructure/Obsidian/Commands/Links/AnalyzeAndLinkEntitiesCommand/AnalyzeAndLinkEntitiesCommand.ts
var AnalyzeAndLinkEntitiesCommand = class {
  constructor(app, llm) {
    this.app = app;
    this.llm = llm;
  }
  async execute(targetFile) {
    console.log("[AnalyzeAndLinkEntitiesCommand] Start");
    const view = getActiveMarkdownView(this.app, targetFile);
    if (!(view == null ? void 0 : view.file)) {
      showMessage("Open a markdown note to analyze.");
      console.log("[AnalyzeAndLinkEntitiesCommand] End (No active view)");
      return;
    }
    const editor = view.editor;
    const noteContent = editor.getValue();
    const noteTitle = view.file.basename;
    showMessage("Analyzing entities with AI...");
    const prompt = this.buildPrompt(noteTitle, noteContent);
    try {
      const entities = await this.llm.requestJson({ prompt });
      if (!entities || !Array.isArray(entities)) {
        showMessage("AI response invalid or empty.");
        console.log("[AnalyzeAndLinkEntitiesCommand] End (Invalid response)");
        return;
      }
      const highRelevanceEntities = entities.filter((e) => e.relevance === "High" || e.relevance === "Medium");
      if (highRelevanceEntities.length === 0) {
        showMessage("No relevant entities found.");
        console.log("[AnalyzeAndLinkEntitiesCommand] End (No relevant entities)");
        return;
      }
      new EntitySelectionModal(this.app, highRelevanceEntities, (selectedEntities) => {
        if (selectedEntities.length > 0) {
          executeInEditMode(view, async () => {
            this.processEntities(selectedEntities, view.editor);
          });
          showMessage(`Processed ${selectedEntities.length} entities.`);
        } else {
          showMessage("No entities selected.");
        }
      }).open();
    } catch (error) {
      console.error("Error analyzing entities:", error);
      showMessage("Error analyzing entities.");
    }
    console.log("[AnalyzeAndLinkEntitiesCommand] End");
  }
  buildPrompt(title, content) {
    return `
You are an expert knowledge graph builder using Obsidian.
Analyze the following note content and identify key entities that should be linked.

Note Title: "${title}"

Content:
"${content}"

Extract:
1.  **People** (Personas): Specific individuals mentioned.
2.  **Places** (Lugares): Locations, cities, countries.
3.  **Concepts** (Conceptos): Events or things with their own name.

Return a JSON ARRAY of objects. Each object must have:
- "name": The exact string occurrence in the text (case-sensitive preference, but normalize if needed).
- "type": "Person", "Place", or "Concept".
- "relevance": "High" (is important for general knowledge), "Medium" (is medium important for general knowledge), "Low" (is not important for general knowledge).

Example Output:
[
  { "name": "Elon Musk", "type": "Person", "relevance": "High" },
  { "name": "Mars", "type": "Place", "relevance": "Medium" }
]

CRITICAL: Return ONLY the JSON Array. No markdown formatting around it.
`;
  }
  processEntities(entities, editor) {
    let content = editor.getValue();
    entities.sort((a, b) => b.name.length - a.name.length);
    const cache = this.app.metadataCache;
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
    const frontmatterMatch = content.match(frontmatterRegex);
    const frontmatterEndIndex = frontmatterMatch ? frontmatterMatch[0].length : 0;
    for (const entity of entities) {
      const name = entity.name;
      const escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const regex = new RegExp(`(?<!\\p{L})${escapedName}(?!\\p{L})`, "gu");
      content = content.replace(regex, (match, offset, string) => {
        if (this.isInsideLink(string, offset, match.length)) {
          return match;
        }
        const isInsideFrontmatter = offset < frontmatterEndIndex;
        const linkDest = cache.getFirstLinkpathDest(name, "");
        let linkText = `[[${match}]]`;
        if (linkDest && linkDest.basename !== match) {
          linkText = `[[${linkDest.basename}|${match}]]`;
        }
        if (isInsideFrontmatter) {
          const charBefore = offset > 0 ? string[offset - 1] : "";
          const charAfter = offset + match.length < string.length ? string[offset + match.length] : "";
          if (charBefore === '"' && charAfter === '"' || charBefore === "'" && charAfter === "'") {
            return linkText;
          }
          return `"${linkText}"`;
        }
        return linkText;
      });
    }
    if (content !== editor.getValue()) {
      editor.setValue(content);
    }
  }
  isInsideLink(text, offset, length) {
    const before = text.substring(0, offset);
    const after = text.substring(offset + length);
    const lastOpen = before.lastIndexOf("[[");
    const lastCloseBefore = before.lastIndexOf("]]");
    const possibleOpen = lastOpen > lastCloseBefore;
    if (possibleOpen) {
      const nextClose = after.indexOf("]]");
      const nextOpen = after.indexOf("[[");
      if (nextClose !== -1 && (nextOpen === -1 || nextClose < nextOpen)) {
        return true;
      }
    }
    return false;
  }
};

// src/Infrastructure/Obsidian/Commands/Links/GenerateMissingNotesFromListFieldCommand/GenerateMissingNotesFromListFieldCommand.ts
var import_obsidian22 = require("obsidian");
var GenerateMissingNotesFromListFieldCommand = class {
  constructor(app, settings, llm, imageEnricher) {
    this.app = app;
    this.settings = settings;
    this.llm = llm;
    this.imageEnricher = imageEnricher;
    this.applyTemplateCommand = new ApplyTemplateCommand(
      llm,
      imageEnricher,
      app,
      settings
    );
  }
  async execute(file) {
    console.log("[GenerateMissingNotesFromListFieldCommand] Start");
    const activeFile = file != null ? file : this.app.workspace.getActiveFile();
    if (!activeFile) {
      showMessage("No active file found.");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const split = splitFrontmatter(content);
    const frontmatter = parseFrontmatter(split.frontmatterText);
    if (!frontmatter) {
      showMessage("No frontmatter found.");
      return;
    }
    const listFields = [];
    for (const [key, value] of Object.entries(frontmatter)) {
      if (Array.isArray(value)) {
        listFields.push(key);
      }
    }
    if (listFields.length === 0) {
      showMessage("No list fields found in the frontmatter.");
      return;
    }
    let selectedField = null;
    selectedField = await new Promise((resolve) => {
      new GenericFuzzySuggestModal(
        this.app,
        listFields,
        (item) => item,
        () => {
        },
        resolve
      ).open();
    });
    if (!selectedField) {
      return;
    }
    let links = [];
    const fieldData = frontmatter[selectedField];
    if (Array.isArray(fieldData)) {
      links = fieldData.map((link) => this.extractLinkText(link)).filter((l) => l !== null);
    }
    if (links.length === 0) {
      showMessage(`No links found in "${selectedField}".`);
      return;
    }
    const missingNotes = [];
    for (const link of links) {
      if (!this.linkExists(link)) {
        missingNotes.push(link);
      }
    }
    if (missingNotes.length === 0) {
      showMessage(`All notes in "${selectedField}" already exist.`);
      return;
    }
    showMessage(`Found ${missingNotes.length} missing notes in "${selectedField}". Select template...`);
    const matches = await getAllTemplateConfigs(this.app);
    if (matches.length === 0) {
      showMessage("No templates found.");
      return;
    }
    let templateResult = null;
    templateResult = await new Promise((resolve) => {
      new GenericFuzzySuggestModal(
        this.app,
        matches,
        (item) => item.templateFile.basename,
        () => {
        },
        resolve
      ).open();
    });
    if (!templateResult) {
      showMessage("No template selected. Aborting.");
      return;
    }
    showMessage(`Generating ${missingNotes.length} notes with template ${templateResult.templateFile.basename}...`);
    for (const noteName of missingNotes) {
      try {
        const parentPath = activeFile.parent ? activeFile.parent.path : "";
        const newFilePath = (0, import_obsidian22.normalizePath)(`${parentPath}/${noteName}.md`);
        if (await pathExists(this.app, newFilePath)) {
          continue;
        }
        const newFile = await this.app.vault.create(newFilePath, "");
        await this.applyTemplateCommand.applyTemplate(newFile, templateResult);
        console.log(`Created and processed ${newFilePath}`);
      } catch (e) {
        console.error(`Error creating note ${noteName}:`, e);
        new import_obsidian22.Notice(`Failed to create ${noteName}`);
      }
    }
    showMessage(`Finished generating notes.`);
    console.log("[GenerateMissingNotesFromListFieldCommand] End");
  }
  extractLinkText(text) {
    if (!text)
      return null;
    const output = text.trim();
    if (output.startsWith("[[") && output.endsWith("]]")) {
      const content = output.slice(2, -2);
      return content.split("|")[0];
    }
    return output;
  }
  linkExists(linkName) {
    const file = this.app.metadataCache.getFirstLinkpathDest(linkName, "");
    return !!file;
  }
};

// src/Infrastructure/Obsidian/Commands/Photos/InsertLinkToSelectedPhotoCommand.ts
var import_child_process = require("child_process");
var import_core16 = __toESM(require_dist());
var InsertLinkToSelectedPhotoCommand = class {
  constructor(app) {
    this.app = app;
  }
  async execute(file) {
    const view = getActiveMarkdownView(this.app, file);
    if (!view) {
      showMessage("Abre una nota para insertar el link de la foto.");
      return;
    }
    const script = `
        tell application "Photos"
            set selectedItems to selection
            if selectedItems is {} then
                return "ERROR: No photo selected"
            else
                set item1 to item 1 of selectedItems
                set photoId to id of item1
                set photoName to filename of item1
                return photoId & "|||" & photoName
            end if
        end tell
        `;
    (0, import_child_process.exec)(`osascript -e '${script}'`, async (error, stdout, stderr) => {
      if (error) {
        console.error(`exec error: ${error}`);
        showMessage("Error al conectar con Photos (\xBFPermisos?)");
        return;
      }
      if (stderr) {
        console.error(`stderr: ${stderr}`);
      }
      const result = stdout.trim();
      if (result.startsWith("ERROR")) {
        showMessage("Selecciona una foto en la app Photos primero.");
        return;
      }
      const [id, name] = result.split("|||");
      if (!id || !name) {
        showMessage("Error al obtener datos de la foto.");
        return;
      }
      showMessage(`Foto detectada: ${name}`);
      const safeName = encodeURIComponent(name).replace(/\(/g, "%28").replace(/\)/g, "%29");
      const link = `elo-bridge://id=${encodeURIComponent(id)}&name=${safeName}`;
      await executeInEditMode(view, async () => {
        const f = view.file;
        if (!f)
          return;
        const content = await this.app.vault.read(f);
        const split = splitFrontmatter(content);
        const currentFrontmatter = parseFrontmatter(split.frontmatterText) || {};
        const currentPhotos = currentFrontmatter[import_core16.FrontmatterKeys.EloImages];
        let newPhotos = [];
        if (Array.isArray(currentPhotos)) {
          newPhotos = [...currentPhotos];
        } else if (currentPhotos) {
          newPhotos = [currentPhotos];
        }
        newPhotos.push(link);
        currentFrontmatter[import_core16.FrontmatterKeys.EloImages] = newPhotos;
        const frontmatterBlock = formatFrontmatterBlock(currentFrontmatter);
        const normalizedBody = split.body.replace(/^[\n\r]+/, "");
        const finalContent = frontmatterBlock + "\n\n" + normalizedBody;
        await this.app.vault.modify(f, finalContent);
        showMessage(`Link a\xF1adido a campo "Fotos": ${name}`);
      });
    });
  }
};

// src/Infrastructure/Obsidian/Commands/Photos/OpenLinkedPhotoCommand.ts
var import_obsidian23 = require("obsidian");
var OpenLinkedPhotoCommand = class {
  constructor(app) {
    this.app = app;
  }
  async tryGetFromFrontmatter(view) {
    const file = view.file;
    if (!file)
      return null;
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!frontmatter)
      return null;
    const candidates = [];
    const addCandidates = (key) => {
      const val = frontmatter[key];
      if (Array.isArray(val)) {
        candidates.push(...val);
      } else if (typeof val === "string") {
        candidates.push(val);
      }
    };
    addCandidates("!!images");
    addCandidates("Imagenes urls");
    if (candidates.length === 0)
      return null;
    const regex = /elo-bridge:\/\/id=([^&]+)&name=(.+)/;
    for (const candidate of candidates) {
      const match = candidate.match(regex);
      if (match) {
        return {
          id: decodeURIComponent(match[1]),
          name: decodeURIComponent(match[2])
        };
      }
    }
    return null;
  }
  async execute(file) {
    const view = getActiveMarkdownView(this.app, file);
    if (!view) {
      showMessage("Abre una nota.");
      return;
    }
    const editor = view.editor;
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const linkRegex = /elo-bridge:\/\/id=([^&]+)&name=(.+)/;
    console.log("[Elocuency] Checking line:", line);
    const match = line.match(linkRegex);
    let id = "";
    let name = "";
    if (match) {
      id = decodeURIComponent(match[1]);
      name = decodeURIComponent(match[2]);
    } else {
      console.log("[Elocuency] No link in line, checking Frontmatter...");
      const fromFrontmatter = await this.tryGetFromFrontmatter(view);
      if (fromFrontmatter) {
        id = fromFrontmatter.id;
        name = fromFrontmatter.name;
        showMessage(`Abriendo foto principal: ${name}`);
      } else {
        showMessage("No se encontr\xF3 link de foto (l\xEDnea o metadatos).");
        return;
      }
    }
    if (import_obsidian23.Platform.isMobile) {
      this.handleMobile(name);
    } else {
      this.handleDesktop(id, name);
    }
  }
  handleMobile(name) {
    const encodedName = encodeURIComponent(name);
    const url = `shortcuts://run-shortcut?name=OpenPhoto&input=${encodedName}`;
    window.open(url);
  }
  handleDesktop(id, name) {
    const { exec: exec2 } = require("child_process");
    showMessage(`Abriendo foto...`);
    const script = `
        set photoId to "${id}"
        set photoName to "${name}"
        
        tell application "Photos"
            activate
            set foundById to false
            
            try
                -- Try to select by ID
                if exists media item id photoId then
                    set selection to {media item id photoId}
                    set foundById to true
                end if
            end try
            
            if not foundById then
                -- Fallback to Name
                try
                    set searchResults to (every media item whose filename is photoName)
                    if (count of searchResults) > 0 then
                        set selection to {item 1 of searchResults}
                    else
                        return "ERROR: Not found by ID or Name"
                    end if
                on error
                    return "ERROR: Sarching failed"
                end try
            end if
            
            return "SUCCESS"
        end tell
        `;
    exec2(`osascript -e '${script}'`, (error, stdout, stderr) => {
      if (error) {
        console.error(`exec error: ${error}`);
        showMessage("Error al ejecutar AppleScript.");
        return;
      }
      const result = stdout ? stdout.trim() : "";
      if (result.startsWith("ERROR")) {
        showMessage(`No se encontr\xF3 la foto "${name}".`);
      }
    });
  }
};

// src/Infrastructure/Obsidian/Commands/AI/EnrichWithPromptUrlCommand/EnrichWithPromptUrlCommand.ts
var import_core17 = __toESM(require_dist());
var EnrichWithPromptUrlCommand = class {
  constructor(llm, imageEnricher, obsidian, settings) {
    this.llm = llm;
    this.imageEnricher = imageEnricher;
    this.obsidian = obsidian;
    this.settings = settings;
  }
  async execute(targetFile) {
    console.log("[EnrichWithPromptUrlCommand] Start");
    const view = getActiveMarkdownView(this.obsidian, targetFile);
    const file = targetFile != null ? targetFile : view == null ? void 0 : view.file;
    if (!file) {
      showMessage("Open a markdown note to enrich.");
      return;
    }
    new InputModal(
      this.obsidian,
      {
        title: "Enrich with Prompt URL",
        label: "Enter URL (e.g. Wikipedia article)",
        placeholder: "https://...",
        submitText: "Enrich"
      },
      async (url) => {
        if (!url) {
          showMessage("URL is required.");
          return;
        }
        await this.processUrl(file, url);
      }
    ).open();
  }
  async processUrl(file, url) {
    try {
      const content = await this.obsidian.vault.read(file);
      const split = splitFrontmatter(content);
      const frontmatter = parseFrontmatter(split.frontmatterText) || {};
      frontmatter[import_core17.FrontmatterKeys.EloPromptUrl] = url;
      const frontmatterBlock = formatFrontmatterBlock(frontmatter);
      const body = split.body ? split.body.trim() : "";
      const newContent = frontmatterBlock + (body ? "\n\n" + body : "");
      await this.obsidian.vault.modify(file, newContent);
      const command = new ApplyTemplateCommand(
        this.llm,
        this.imageEnricher,
        this.obsidian,
        this.settings
      );
      await command.execute(file);
    } catch (error) {
      console.error("[EnrichWithPromptUrlCommand] Error:", error);
      showMessage(`Error enriching with prompt URL: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// src/Infrastructure/Obsidian/Commands/Contacts/SyncContactsCommand.ts
var import_obsidian24 = require("obsidian");
var import_core18 = __toESM(require_dist());
var import_core19 = __toESM(require_dist());
var SyncCurrentContactCommand = class {
  constructor(app, bridge) {
    this.app = app;
    this.bridge = bridge;
    this.id = import_core18.CommandEnum.SyncContacts;
    this.name = "Contactos: Sincronizar Nota Activa con Mac/iPhone";
  }
  async execute(file) {
    const targetFile = file || this.app.workspace.getActiveFile();
    if (!targetFile || !(targetFile instanceof import_obsidian24.TFile)) {
      new import_obsidian24.Notice("No hay ninguna nota activa.");
      return;
    }
    if (!this.isPersona(targetFile)) {
      new import_obsidian24.Notice("La nota activa no es una Persona (falta tag #Personas).");
      return;
    }
    const view = getActiveMarkdownView(this.app, targetFile);
    if (!view) {
      new import_obsidian24.Notice("No se pudo obtener la vista de la nota para activar el modo edici\xF3n.");
      return;
    }
    await executeInEditMode(view, async () => {
      new import_obsidian24.Notice(`Sincronizando contacto: ${targetFile.basename}...`);
      try {
        await this.syncFile(targetFile);
        new import_obsidian24.Notice(`Sincronizaci\xF3n completada para ${targetFile.basename}`);
      } catch (e) {
        console.error(`Error syncing ${targetFile.basename}:`, e);
        new import_obsidian24.Notice(`Error al sincronizar: ${e.message}`);
      }
    });
  }
  isPersona(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache)
      return false;
    const tags = (0, import_obsidian24.getAllTags)(cache);
    if (tags && tags.some((t) => t.startsWith("#Personas/") || t === "#Personas")) {
      return true;
    }
    return false;
  }
  async syncFile(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!frontmatter)
      return;
    const name = file.basename.replace(/\(.*\)/g, "").trim() || file.basename;
    const finalName = (frontmatter == null ? void 0 : frontmatter["name"]) || file.basename;
    const contactData = {
      name: finalName,
      phone: frontmatter[import_core19.FrontmatterKeys.Telefono],
      email: frontmatter[import_core19.FrontmatterKeys.Email],
      birthday: frontmatter[import_core19.FrontmatterKeys.Cumpleanos],
      id: frontmatter[import_core19.FrontmatterKeys.EloAppleContactId]
      // Use existing ID if available
      // Add tags as notes?
    };
    let selectedCandidate = null;
    if (!contactData.id) {
      const cleanName = file.basename.replace(/\(.*\)/g, "").trim() || file.basename;
      console.log(`[SyncCurrentContact] Searching candidates for: ${cleanName}`);
      try {
        const candidates = await this.bridge.searchContacts(cleanName);
        console.log(`[SyncCurrentContact] Candidates found: ${candidates == null ? void 0 : candidates.length}`);
        if (candidates && candidates.length > 0) {
          selectedCandidate = await this.promptUserForCandidate(file.basename, cleanName, candidates);
          console.log(`[SyncCurrentContact] Selected candidate:`, selectedCandidate);
          if (selectedCandidate) {
            contactData.id = selectedCandidate.id;
            new import_obsidian24.Notice(`Enlazado a: ${selectedCandidate.name}`);
          } else {
            console.log(`[SyncCurrentContact] User cancelled or chose create new.`);
            new import_obsidian24.Notice(`Creando nuevo contacto: ${finalName}`);
          }
        }
      } catch (err) {
        console.error("Error searching candidate:", err);
      }
    }
    console.log(`[SyncCurrentContact] Upserting contact data:`, contactData);
    try {
      const syncedContact = await this.bridge.upsertContact(contactData);
      console.log(`[SyncCurrentContact] Upsert result:`, syncedContact);
      await this.app.fileManager.processFrontMatter(file, (fm) => {
        if (syncedContact) {
          if (syncedContact.id) {
            fm[import_core19.FrontmatterKeys.EloAppleContactId] = syncedContact.id;
          }
          if (!fm[import_core19.FrontmatterKeys.Telefono] && syncedContact.phones && syncedContact.phones.length > 0) {
            fm[import_core19.FrontmatterKeys.Telefono] = syncedContact.phones[0];
          }
          if (!fm[import_core19.FrontmatterKeys.Email] && syncedContact.emails && syncedContact.emails.length > 0) {
            fm[import_core19.FrontmatterKeys.Email] = syncedContact.emails[0];
          }
          if (!fm[import_core19.FrontmatterKeys.Cumpleanos] && syncedContact.birthday) {
            fm[import_core19.FrontmatterKeys.Cumpleanos] = syncedContact.birthday;
          }
        }
      });
    } catch (err) {
      console.error(`[SyncCurrentContact] Upsert failed:`, err);
      throw err;
    }
  }
  async promptUserForCandidate(noteName, query, candidates) {
    return new Promise((resolve) => {
      const modal = new ContactSelectionModal(this.app, noteName, query, candidates, (selected) => {
        resolve(selected);
      });
      modal.open();
    });
  }
};
var ContactSelectionModal = class extends import_obsidian24.FuzzySuggestModal {
  constructor(app, noteName, query, candidates, onChoose) {
    super(app);
    this.noteName = noteName;
    this.query = query;
    this.candidates = candidates;
    this.onChoose = onChoose;
    this.setPlaceholder(`Selecciona un contacto para "${noteName}"`);
  }
  getItems() {
    return [
      ...this.candidates,
      { id: "CREATE_NEW", name: `\u2795 Crear nuevo contacto: "${this.query}"`, phone: [], email: [] }
    ];
  }
  getItemText(item) {
    var _a2, _b;
    if (item.id === "CREATE_NEW")
      return item.name;
    const details = [
      (_a2 = item.phones) == null ? void 0 : _a2.join(", "),
      (_b = item.emails) == null ? void 0 : _b.join(", ")
    ].filter(Boolean).join(" | ");
    return `${item.name} ${details ? `(${details})` : ""}`;
  }
  onChooseItem(item, evt) {
    if (item.id === "CREATE_NEW") {
      this.onChoose(null);
    } else {
      this.onChoose(item);
    }
  }
};

// src/Infrastructure/Obsidian/Commands/Contacts/SyncGoogleContactsCommand.ts
var import_obsidian28 = require("obsidian");

// src/Infrastructure/Obsidian/Views/Modals/GoogleAuthModal.ts
var import_obsidian25 = require("obsidian");
var GoogleAuthModal = class extends import_obsidian25.Modal {
  constructor(app, adapter, onSuccess) {
    super(app);
    this.adapter = adapter;
    this.onSuccess = onSuccess;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Connect to Google Contacts" });
    contentEl.createEl("p", { text: "You need to connect to Google to use this feature." });
    const step1 = contentEl.createDiv({ cls: "step-1" });
    step1.createEl("h3", { text: "Step 1: Authorize" });
    step1.createEl("p", { text: "Click the button below to open the validation page. You will be redirected to Google. Copy the URL or the code from the address bar after the redirect." });
    new import_obsidian25.Setting(step1).addButton((btn) => btn.setButtonText("Connect Google").setCta().onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("Opening Browser...");
      const redirectUri = "https://google.com";
      const authUrl = this.adapter.generateAuthUrl(redirectUri);
      if (authUrl) {
        window.open(authUrl);
        showMessage("Browser opened. Please login and copy the code.");
        setTimeout(() => {
          btn.setDisabled(false);
          btn.setButtonText("Connect Google (Retry)");
        }, 5e3);
      } else {
        showMessage("Failed to generate auth URL. Check Client ID.");
        btn.setDisabled(false);
        btn.setButtonText("Connect Google");
      }
    }));
    const step2 = contentEl.createDiv({ cls: "step-2" });
    step2.createEl("h3", { text: "Step 2: Enter Code" });
    let code = "";
    new import_obsidian25.Setting(step2).setName("Authorization Code").setDesc("Paste the code or the full redirect URL here.").addText((text) => text.setPlaceholder("Paste code or URL...").onChange((value) => {
      code = value.trim();
      try {
        if (code.includes("code=")) {
          const url = new URL(code);
          const extracted = url.searchParams.get("code");
          if (extracted) {
            code = extracted;
          }
        } else if (code.includes("&")) {
          const params = new URLSearchParams(code);
          const extracted = params.get("code");
          if (extracted) {
            code = extracted;
          }
        }
      } catch (e) {
      }
    }));
    new import_obsidian25.Setting(contentEl).addButton((btn) => btn.setButtonText("Verify & Connect").setCta().onClick(async () => {
      if (!code) {
        showMessage("Please enter the code.");
        return;
      }
      try {
        const redirectUri = "https://google.com";
        btn.setButtonText("Verifying...");
        btn.setDisabled(true);
        const success = await this.adapter.finishAuthentication(code, redirectUri);
        if (success) {
          showMessage("Google Connected Successfully!");
          this.onSuccess();
          this.close();
        } else {
          showMessage("Failed to verify code.");
          btn.setButtonText("Verify & Connect");
          btn.setDisabled(false);
        }
      } catch (error) {
        showMessage(`Failed to connect: ${error.message}`);
        console.error(error);
        btn.setButtonText("Verify & Connect");
        btn.setDisabled(false);
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Infrastructure/Obsidian/Adapters/GoogleContactAdapter.ts
var import_obsidian26 = require("obsidian");
var GoogleContactAdapter = class {
  constructor(settings, saveSettings) {
    // --- Groups / Labels Support ---
    this.contactGroupIdsToNames = /* @__PURE__ */ new Map();
    this.contactGroupNamesToIds = /* @__PURE__ */ new Map();
    this.groupsLoaded = false;
    this.settings = settings;
    this.saveSettings = saveSettings;
  }
  generateAuthUrl(redirectUri) {
    if (!this.settings.googleClientId) {
      console.error("Google Client ID is missing.");
      return "";
    }
    const scope = "https://www.googleapis.com/auth/contacts";
    const url = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${this.settings.googleClientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=${encodeURIComponent(scope)}&access_type=offline&prompt=consent`;
    return url;
  }
  async finishAuthentication(code, redirectUri) {
    if (!this.settings.googleClientId || !this.settings.googleClientSecret) {
      throw new Error("Missing Client ID or Secret in settings.");
    }
    try {
      const response = await (0, import_obsidian26.requestUrl)({
        url: "https://oauth2.googleapis.com/token",
        method: "POST",
        throw: false,
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          client_id: this.settings.googleClientId,
          client_secret: this.settings.googleClientSecret,
          code,
          grant_type: "authorization_code",
          redirect_uri: redirectUri
        }).toString()
      });
      if (response.status !== 200) {
        console.error("[GoogleAdapter] Token Exchange Failed. Status:", response.status);
        throw new Error(`Failed to exchange token: ${response.text}`);
      }
      const data = response.json;
      if (!data.access_token) {
        throw new Error("No access_token in response");
      }
      this.settings.googleAccessToken = data.access_token;
      const now = Date.now();
      this.settings.googleTokenExpirationTime = now + data.expires_in * 1e3;
      if (data.refresh_token) {
        this.settings.googleRefreshToken = data.refresh_token;
      }
      await this.saveSettings(this.settings);
      console.log("[GoogleAdapter] Authentication Successful");
      return true;
    } catch (error) {
      console.error("[GoogleAdapter] Auth Error", error);
      throw error;
    }
  }
  async getAccessToken() {
    if (!this.settings.googleRefreshToken && !this.settings.googleAccessToken) {
      throw new Error("No Google tokens found. Please authenticate first.");
    }
    const now = Date.now();
    if (this.settings.googleAccessToken && this.settings.googleTokenExpirationTime > now + 3e5) {
      return this.settings.googleAccessToken;
    }
    if (!this.settings.googleRefreshToken) {
      throw new Error("Google Refresh Token is missing. Re-authentication required.");
    }
    console.log("[GoogleAdapter] Refreshing Access Token...");
    try {
      const response = await (0, import_obsidian26.requestUrl)({
        url: "https://oauth2.googleapis.com/token",
        method: "POST",
        throw: false,
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          client_id: this.settings.googleClientId,
          client_secret: this.settings.googleClientSecret,
          refresh_token: this.settings.googleRefreshToken,
          grant_type: "refresh_token"
        }).toString()
      });
      if (response.status !== 200) {
        console.error("[GoogleAdapter] Token Refresh Failed. Status:", response.status);
        console.error("[GoogleAdapter] Response Body:", response.text);
        throw new Error(`Failed to refresh token: ${response.status} - ${response.text}`);
      }
      const data = response.json;
      if (!data.access_token) {
        throw new Error("No access_token in response");
      }
      this.settings.googleAccessToken = data.access_token;
      this.settings.googleTokenExpirationTime = now + data.expires_in * 1e3;
      await this.saveSettings(this.settings);
      console.log("[GoogleAdapter] Token Refreshed Successfully");
      return this.settings.googleAccessToken;
    } catch (error) {
      console.error("[GoogleAdapter] Auth Error", error);
      new import_obsidian26.Notice("Error al autenticar con Google. Revisa la consola.");
      throw error;
    }
  }
  async request(url, method = "GET", body) {
    const token = await this.getAccessToken();
    const params = {
      url,
      method,
      headers: {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json"
      }
    };
    if (body) {
      params.body = JSON.stringify(body);
    }
    const response = await (0, import_obsidian26.requestUrl)(params);
    if (response.status >= 400) {
      throw new Error(`Google API Error ${response.status}: ${response.text}`);
    }
    return response.json;
  }
  async searchContacts(query) {
    await this.ensureContactGroupsLoaded();
    if (query.length < 1)
      return [];
    const url = `https://people.googleapis.com/v1/people:searchContacts?query=${encodeURIComponent(query)}&readMask=names,phoneNumbers,emailAddresses,birthdays,biographies,userDefined,metadata,nicknames,organizations,addresses,urls,events,relations,genders,occupations,interests,skills,residences,memberships`;
    try {
      const data = await this.request(url);
      if (!data.results)
        return [];
      return data.results.map((item) => this.mapToContact(item.person));
    } catch (e) {
      console.error("[GoogleAdapter] Search Error", e);
      throw e;
    }
  }
  async upsertContact(contact) {
    await this.ensureContactGroupsLoaded();
    if (contact.id) {
      return this.updateContact(contact.id, contact);
    } else {
      return this.createContact(contact);
    }
  }
  async createContact(contact) {
    const url = `https://people.googleapis.com/v1/people:createContact`;
    const body = this.mapToGooglePayload(contact);
    const data = await this.request(url, "POST", body);
    return this.mapToContact(data);
  }
  async updateContact(resourceName2, contact) {
    var _a2;
    const getUrl = `https://people.googleapis.com/v1/${resourceName2}?personFields=names,phoneNumbers,emailAddresses,birthdays,userDefined,nicknames,organizations,addresses,urls,events,relations,genders,occupations,interests,skills,residences,memberships`;
    const current = await this.request(getUrl);
    const etag = current.etag;
    const body = this.mapToGooglePayload(contact);
    body.etag = etag;
    const updateMask = [];
    if (contact.name)
      updateMask.push("names");
    if (contact.phone)
      updateMask.push("phoneNumbers");
    if (contact.email)
      updateMask.push("emailAddresses");
    if (contact.birthday)
      updateMask.push("birthdays");
    if (contact.customFields)
      updateMask.push("userDefined");
    if (contact.nickname)
      updateMask.push("nicknames");
    if (contact.jobTitle || contact.organization)
      updateMask.push("organizations");
    if (contact.groups) {
      updateMask.push("memberships");
      const currentMemberships = current.memberships || [];
      const targetGroupNames = new Set(contact.groups);
      const systemGroupIds = ["contactGroups/myContacts", "contactGroups/starred"];
      const newMemberships = [];
      for (const gName of contact.groups) {
        const gId = this.contactGroupNamesToIds.get(gName);
        if (gId) {
          newMemberships.push({
            contactGroupMembership: {
              contactGroupResourceName: gId
            }
          });
        }
      }
      for (const m of currentMemberships) {
        const id = (_a2 = m.contactGroupMembership) == null ? void 0 : _a2.contactGroupResourceName;
        const mappedName = this.contactGroupIdsToNames.get(id);
        if (!mappedName) {
          const exists = newMemberships.find((nm) => nm.contactGroupMembership.contactGroupResourceName === id);
          if (!exists)
            newMemberships.push(m);
        } else {
        }
      }
      body.memberships = newMemberships;
    }
    const updateUrl = `https://people.googleapis.com/v1/${resourceName2}:updateContact?updatePersonFields=${updateMask.join(",")}&personFields=names,phoneNumbers,emailAddresses,birthdays,biographies,userDefined,metadata,nicknames,organizations,addresses,urls,events,relations,genders,occupations,interests,skills,residences,memberships`;
    const data = await this.request(updateUrl, "PATCH", body);
    return this.mapToContact(data);
  }
  async listContacts(pageSize, pageToken) {
    await this.ensureContactGroupsLoaded();
    let url = `https://people.googleapis.com/v1/people/me/connections?personFields=names,phoneNumbers,emailAddresses,birthdays,biographies,userDefined,metadata,nicknames,organizations,addresses,urls,events,relations,genders,occupations,interests,skills,residences,memberships&pageSize=${pageSize}`;
    if (pageToken) {
      url += `&pageToken=${pageToken}`;
    }
    const data = await this.request(url);
    return {
      contacts: (data.connections || []).map((p) => this.mapToContact(p)),
      nextSyncToken: data.nextSyncToken,
      nextPageToken: data.nextPageToken
    };
  }
  async deleteContact(resourceName2) {
    const url = `https://people.googleapis.com/v1/${resourceName2}:deleteContact`;
    await this.request(url, "DELETE");
  }
  async ensureContactGroupsLoaded() {
    if (this.groupsLoaded)
      return;
    try {
      console.log("[GoogleAdapter] Loading Contact Groups...");
      const url = `https://people.googleapis.com/v1/contactGroups`;
      const data = await this.request(url);
      if (data.contactGroups) {
        for (const g of data.contactGroups) {
          const name = g.formattedName || g.name;
          const id = g.resourceName;
          this.contactGroupIdsToNames.set(id, name);
          this.contactGroupNamesToIds.set(name, id);
        }
      }
      this.groupsLoaded = true;
      console.log(`[GoogleAdapter] Loaded ${this.contactGroupIdsToNames.size} groups.`);
    } catch (e) {
      console.error("[GoogleAdapter] Error loading groups", e);
    }
  }
  mapToContact(person) {
    var _a2, _b, _c, _d, _e, _f;
    const names = person.names || [];
    const phones = person.phoneNumbers || [];
    const emails = person.emailAddresses || [];
    const birthdays = person.birthdays || [];
    const biographies = person.biographies || [];
    const userDefined = person.userDefined || [];
    const nicknames = person.nicknames || [];
    const organizations = person.organizations || [];
    const addresses = person.addresses || [];
    const urls = person.urls || [];
    const events = person.events || [];
    const relations = person.relations || [];
    const genders = person.genders || [];
    const occupations = person.occupations || [];
    const interests = person.interests || [];
    const skills = person.skills || [];
    const residences = person.residences || [];
    const memberships = person.memberships || [];
    const primaryName = names.find((n) => {
      var _a3;
      return (_a3 = n.metadata) == null ? void 0 : _a3.primary;
    }) || names[0];
    let bdayStr = void 0;
    if (birthdays.length > 0) {
      const b = birthdays[0].date;
      if (b.year && b.month && b.day) {
        bdayStr = `${b.year}-${String(b.month).padStart(2, "0")}-${String(b.day).padStart(2, "0")}`;
      }
    }
    let updatedAt = void 0;
    if (person.metadata && person.metadata.sources && person.metadata.sources.length > 0) {
      updatedAt = ((_a2 = person.metadata.sources.find((s) => s.type === "CONTACT")) == null ? void 0 : _a2.updateTime) || person.metadata.sources[0].updateTime;
    }
    const groups = memberships.map((m) => {
      var _a3;
      const id = (_a3 = m.contactGroupMembership) == null ? void 0 : _a3.contactGroupResourceName;
      return this.contactGroupIdsToNames.get(id);
    }).filter(Boolean);
    return {
      id: person.resourceName,
      name: primaryName ? primaryName.displayName : "No Name",
      phone: phones.map((p) => p.value),
      email: emails.map((e) => e.value),
      birthday: bdayStr,
      updatedAt,
      notes: (_b = biographies.find((b) => b.contentType === "TEXT_PLAIN")) == null ? void 0 : _b.value,
      nickname: (_c = nicknames[0]) == null ? void 0 : _c.value,
      jobTitle: (_d = organizations[0]) == null ? void 0 : _d.title,
      organization: (_e = organizations[0]) == null ? void 0 : _e.name,
      addresses: addresses.map((a) => a.formattedValue),
      urls: urls.map((u) => u.value),
      events: events.map((e) => {
        if (e.date && e.type) {
          const d = e.date;
          const dateStr = `${d.year || "????"}-${String(d.month).padStart(2, "0")}-${String(d.day).padStart(2, "0")}`;
          return `${e.type}: ${dateStr}`;
        }
        return null;
      }).filter(Boolean),
      relations: relations.map((r) => `${r.person} (${r.type})`),
      gender: (_f = genders[0]) == null ? void 0 : _f.value,
      occupations: occupations.map((o) => o.value),
      interests: interests.map((i) => i.value),
      skills: skills.map((s) => s.value),
      residences: residences.map((r) => r.value),
      customFields: userDefined.reduce((acc, curr) => {
        acc[curr.key] = curr.value;
        return acc;
      }, {}),
      groups
    };
  }
  mapToGooglePayload(contact) {
    const payload = {};
    if (contact.name) {
      const parts = contact.name.split(" ");
      const given = parts[0];
      const family = parts.slice(1).join(" ");
      payload.names = [{
        givenName: given,
        familyName: family
      }];
    }
    if (contact.phone && contact.phone.length > 0) {
      payload.phoneNumbers = contact.phone.map((p) => ({ value: p }));
    }
    if (contact.email && contact.email.length > 0) {
      payload.emailAddresses = contact.email.map((e) => ({ value: e }));
    }
    if (contact.birthday) {
      const [y, m, d] = contact.birthday.split("-").map(Number);
      if (y && m && d) {
        payload.birthdays = [{
          date: {
            year: y,
            month: m,
            day: d
          }
        }];
      }
    }
    if (contact.nickname) {
      payload.nicknames = [{
        value: contact.nickname
      }];
    }
    if (contact.jobTitle || contact.organization) {
      const org = {};
      if (contact.jobTitle)
        org.title = contact.jobTitle;
      if (contact.organization)
        org.name = contact.organization;
      payload.organizations = [org];
    }
    if (contact.customFields) {
      payload.userDefined = Object.entries(contact.customFields).map(([key, value]) => ({
        key,
        value
      }));
    }
    if (contact.groups) {
      const mShips = [];
      for (const gName of contact.groups) {
        const gId = this.contactGroupNamesToIds.get(gName);
        if (gId) {
          mShips.push({
            contactGroupMembership: {
              contactGroupResourceName: gId
            }
          });
        }
      }
      if (this.contactGroupNamesToIds.has("Contacts")) {
      }
      if (mShips.length > 0)
        payload.memberships = mShips;
    }
    return payload;
  }
};

// src/Infrastructure/Obsidian/Services/GoogleContactSyncService.ts
var import_obsidian27 = require("obsidian");
var GoogleContactSyncService = class {
  constructor(app, adapter, transformer) {
    this.app = app;
    this.adapter = adapter;
    this.transformer = transformer;
  }
  /**
   * Syncs a specific note with Google.
   * If no Google ID exists, searches for candidates or creates a new one.
   */
  async syncNoteWithGoogle(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!frontmatter)
      return;
    const tags = (0, import_obsidian27.getAllTags)(cache) || [];
    const contactData = this.transformer.toContact(file, frontmatter, tags);
    let selectedCandidate = null;
    if (!contactData.id) {
      const cleanName = contactData.name;
      console.log(`[SyncService] Searching candidates for: ${cleanName}`);
      try {
        const candidates = await this.adapter.searchContacts(cleanName);
        if (candidates && candidates.length > 0) {
          selectedCandidate = await this.promptUserForCandidate(file.basename, cleanName, candidates);
          if (selectedCandidate) {
            contactData.id = selectedCandidate.id;
            new import_obsidian27.Notice(`Enlazado a Google Contact: ${selectedCandidate.name}`);
          } else {
            new import_obsidian27.Notice(`Creando nuevo contacto en Google: ${cleanName}`);
          }
        } else {
          new import_obsidian27.Notice(`No se encontraron candidatos. Creando nuevo...`);
        }
      } catch (err) {
        console.error("Error searching candidate:", err);
      }
    }
    const syncedContact = await this.adapter.upsertContact(contactData);
    await this.app.fileManager.processFrontMatter(file, (fm) => {
      this.transformer.updateFrontmatterFromContact(fm, syncedContact);
    });
  }
  /**
   * Links a specific Google Contact to a Note.
   * Updates frontmatter and appends notes if any.
   */
  async linkContactToNote(contact, file) {
    await this.app.fileManager.processFrontMatter(file, (fm) => {
      this.transformer.updateFrontmatterFromContact(fm, contact);
    });
    if (contact.notes) {
      const content = await this.app.vault.read(file);
      await this.app.vault.modify(file, content + "\n\n" + contact.notes);
    }
    const updatedContact = {
      ...contact,
      customFields: {
        ...contact.customFields,
        eloSyncDate: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
    await this.adapter.upsertContact(updatedContact);
    new import_obsidian27.Notice(`Enlazado: ${contact.name} <-> ${file.basename}`);
  }
  /**
   * Creates a new note from a Contact and links them.
   * Deletes source contact if requested (via move logic usually, but here we just create).
   */
  async createNoteFromContact(contact) {
    const templatePath = "!!metadata/templates/Personas/Persona conocidos mios.md";
    const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
    let content = "";
    if (templateFile instanceof import_obsidian27.TFile) {
      content = await this.app.vault.read(templateFile);
    } else {
      console.warn(`Template not found: ${templatePath}`);
    }
    let filename = `Personas/${contact.name}.md`;
    if (!await this.app.vault.adapter.exists("Personas")) {
      await this.app.vault.createFolder("Personas");
    }
    let i = 1;
    while (await this.app.vault.adapter.exists(filename)) {
      filename = `Personas/${contact.name} ${i}.md`;
      i++;
    }
    const newFile = await this.app.vault.create(filename, content);
    await this.linkContactToNote(contact, newFile);
    return newFile;
  }
  async promptUserForCandidate(noteName, query, candidates) {
    return new Promise((resolve) => {
      const modal = new ContactSelectionModal2(this.app, noteName, query, candidates, (selected) => {
        resolve(selected);
      });
      modal.open();
    });
  }
};
var ContactSelectionModal2 = class extends import_obsidian27.FuzzySuggestModal {
  constructor(app, noteName, query, candidates, onChoose) {
    super(app);
    this.noteName = noteName;
    this.query = query;
    this.candidates = candidates;
    this.onChoose = onChoose;
    this.setPlaceholder(`Selecciona un contacto de Google para "${noteName}"`);
  }
  getItems() {
    return [
      ...this.candidates,
      { id: "CREATE_NEW", name: `\u2795 Crear nuevo contacto: "${this.query}"` }
    ];
  }
  getItemText(item) {
    var _a2, _b;
    if (item.id === "CREATE_NEW")
      return item.name;
    const details = [
      (_a2 = item.phone) == null ? void 0 : _a2.join(", "),
      (_b = item.email) == null ? void 0 : _b.join(", ")
    ].filter(Boolean).join(" | ");
    return `${item.name} ${details ? `(${details})` : ""}`;
  }
  onChooseItem(item, evt) {
    if (item.id === "CREATE_NEW") {
      this.onChoose(null);
    } else {
      this.onChoose(item);
    }
  }
};

// src/Infrastructure/Obsidian/Transformers/GoogleContactTransformer.ts
var import_core20 = __toESM(require_dist());
var _GoogleContactTransformer = class _GoogleContactTransformer {
  /**
   * Updates the frontmatter object in-place with data from the Contact.
   * Use this within app.fileManager.processFrontMatter callback.
   */
  updateFrontmatterFromContact(frontmatter, contact) {
    if (!contact)
      return;
    if (contact.id) {
      frontmatter[_GoogleContactTransformer.GOOGLE_ID_KEY] = contact.id;
    }
    frontmatter[_GoogleContactTransformer.GOOGLE_SYNC_DATE_KEY] = (/* @__PURE__ */ new Date()).toISOString();
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Telefono, contact.phone);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Email, contact.email);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Cumpleanos, contact.birthday);
    this.updateFieldIfMissing(frontmatter, "aliases", contact.nickname ? [contact.nickname] : void 0);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Puesto, contact.jobTitle);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Empresa, contact.organization);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Direcciones, contact.addresses);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Urls, contact.urls);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Eventos, contact.events);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Relaciones, contact.relations);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Genero, contact.gender);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Ocupaciones, contact.occupations);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Intereses, contact.interests);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Habilidades, contact.skills);
    this.updateFieldIfMissing(frontmatter, import_core20.FrontmatterKeys.Residencias, contact.residences);
    if (contact.customFields) {
      for (const [key, value] of Object.entries(contact.customFields)) {
        if (key === "eloSyncDate")
          continue;
        this.updateFieldIfMissing(frontmatter, key, value);
      }
    }
    if (contact.groups) {
      const currentTags = this.getTagsFromFrontmatter(frontmatter);
      const newTags = new Set(currentTags);
      const reverseMap = {};
      for (const [obsKey, gName] of Object.entries(_GoogleContactTransformer.TAG_MAPPINGS)) {
        reverseMap[gName] = obsKey;
      }
      for (const gName of contact.groups) {
        const mappedTag = reverseMap[gName];
        if (mappedTag) {
          newTags.add(mappedTag);
        }
      }
      if (newTags.size > currentTags.length) {
        frontmatter["tags"] = Array.from(newTags);
      }
    }
  }
  /**
   * Converts a TFile and its frontmatter to a Contact domain object.
   * Note: Does not read file content for notes, only metadata/frontmatter.
   */
  toContact(file, frontmatter, allFileTags) {
    const name = file.basename.replace(/\(.*\)/g, "").trim() || file.basename;
    const finalName = (frontmatter == null ? void 0 : frontmatter["name"]) || name;
    const fileTags = allFileTags || this.getTagsFromFrontmatter(frontmatter);
    const contactGroups = [];
    if (fileTags) {
      for (const tag of fileTags) {
        const cleanTag = tag.startsWith("#") ? tag.substring(1) : tag;
        const groupName = _GoogleContactTransformer.TAG_MAPPINGS[cleanTag];
        if (groupName) {
          contactGroups.push(groupName);
        }
      }
    }
    return {
      id: frontmatter[_GoogleContactTransformer.GOOGLE_ID_KEY],
      name: this.clean(finalName),
      phone: this.clean(this.toArray(frontmatter[import_core20.FrontmatterKeys.Telefono])),
      email: this.clean(this.toArray(frontmatter[import_core20.FrontmatterKeys.Email])),
      birthday: this.clean(frontmatter[import_core20.FrontmatterKeys.Cumpleanos]),
      nickname: this.getStringFromCleaned(this.clean(frontmatter["aliases"])),
      jobTitle: this.clean(frontmatter[import_core20.FrontmatterKeys.Puesto]),
      organization: this.clean(frontmatter[import_core20.FrontmatterKeys.Empresa]),
      customFields: {
        eloSyncDate: (/* @__PURE__ */ new Date()).toISOString()
      },
      groups: contactGroups
    };
  }
  getTagsFromFrontmatter(frontmatter) {
    const tags = frontmatter["tags"];
    if (!tags)
      return [];
    if (Array.isArray(tags))
      return tags;
    if (typeof tags === "string")
      return tags.split(",").map((t) => t.trim());
    return [];
  }
  clean(val) {
    if (!val)
      return val;
    if (Array.isArray(val)) {
      return val.map((v) => this.clean(v));
    }
    if (typeof val === "string") {
      return val.replace(/\[\[/g, "").replace(/\]\]/g, "");
    }
    return val;
  }
  getStringFromCleaned(val) {
    if (!val)
      return void 0;
    if (Array.isArray(val)) {
      return val.length > 0 ? String(val[0]) : void 0;
    }
    return String(val);
  }
  updateFieldIfMissing(frontmatter, key, value) {
    if (!frontmatter[key]) {
      if (Array.isArray(value) && value.length > 0) {
        frontmatter[key] = value;
      } else if (value) {
        frontmatter[key] = value;
      }
    }
  }
  toArray(val) {
    if (!val)
      return [];
    if (Array.isArray(val))
      return val;
    return [val];
  }
};
// Constant for Google ID in frontmatter - could be moved to Registry later
_GoogleContactTransformer.GOOGLE_ID_KEY = "!!googleContactId";
_GoogleContactTransformer.GOOGLE_SYNC_DATE_KEY = "!!googleSyncDate";
_GoogleContactTransformer.GOOGLE_LAST_MODIFIED_KEY = "!!googleLastModified";
// Tag Mapping Table: Obsidian Tag -> Google Group Name
_GoogleContactTransformer.TAG_MAPPINGS = {
  "Personas/Conocidos-mios": "Conocidos",
  "Personas/Compa\xF1eros-de-trabajo": "Compa\xF1ero de trabajo",
  "Personas/Familia": "Familia",
  "Personas/Servicios": "Servicios"
};
var GoogleContactTransformer = _GoogleContactTransformer;

// src/Infrastructure/Obsidian/Commands/Contacts/SyncGoogleContactsCommand.ts
var SyncGoogleContactsCommand = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.id = "elo-sync-google-contacts";
    this.name = "Contactos: Sincronizar Nota Activa con Google";
    this.adapter = new GoogleContactAdapter(
      plugin.settings,
      plugin.saveSettings.bind(plugin)
    );
    const transformer = new GoogleContactTransformer();
    this.service = new GoogleContactSyncService(app, this.adapter, transformer);
  }
  async execute(file) {
    const targetFile = file || this.app.workspace.getActiveFile();
    if (!targetFile || !(targetFile instanceof import_obsidian28.TFile)) {
      new import_obsidian28.Notice("No hay ninguna nota activa.");
      return;
    }
    if (!this.isPersona(targetFile)) {
      new import_obsidian28.Notice("La nota activa no es una Persona (falta tag #Personas).");
      return;
    }
    const view = getActiveMarkdownView(this.app, targetFile);
    if (!view) {
      new import_obsidian28.Notice("No se pudo obtener la vista de la nota para activar el modo edici\xF3n.");
      return;
    }
    await executeInEditMode(view, async () => {
      new import_obsidian28.Notice(`Sincronizando con Google: ${targetFile.basename}...`);
      try {
        await this.service.syncNoteWithGoogle(targetFile);
        new import_obsidian28.Notice(`Sincronizaci\xF3n con Google completada para ${targetFile.basename}`);
      } catch (e) {
        console.error(`Error syncing ${targetFile.basename}:`, e);
        const msg = e.message;
        if (msg.includes("Refresh Token is missing") || msg.includes("No Google tokens") || msg.includes("401") || msg.includes("403") || msg.includes("invalid_grant") || msg.includes("Token has been expired")) {
          new import_obsidian28.Notice("Autenticaci\xF3n necesaria con Google.");
          new GoogleAuthModal(this.app, this.adapter, async () => {
            new import_obsidian28.Notice("Autenticado correctamente. Ejecuta el comando de nuevo.");
          }).open();
        } else {
          new import_obsidian28.Notice(`Error al sincronizar con Google: ${msg}`);
        }
      }
    });
  }
  isPersona(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache)
      return false;
    const tags = (0, import_obsidian28.getAllTags)(cache);
    if (tags && tags.some((t) => t.startsWith("#Personas/"))) {
      return true;
    }
    return false;
  }
};

// src/Infrastructure/Obsidian/Commands/Contacts/ProcessUnsyncedGoogleContactsCommand.ts
var import_obsidian29 = require("obsidian");
var ProcessUnsyncedGoogleContactsCommand = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.id = "elo-process-unsynced-google-contacts";
    this.name = "Contactos: Procesar No Sincronizados de Google";
    this.adapter = new GoogleContactAdapter(
      plugin.settings,
      plugin.saveSettings.bind(plugin)
    );
    const transformer = new GoogleContactTransformer();
    this.service = new GoogleContactSyncService(app, this.adapter, transformer);
  }
  async execute() {
    new import_obsidian29.Notice("Buscando contactos no sincronizados en Google...");
    try {
      const matches = await this.fetchUnsyncedContacts();
      if (matches.length === 0) {
        new import_obsidian29.Notice("No se encontraron contactos pendientes de sincronizar.");
        return;
      }
      new UnsyncedContactsBatchModal(this.app, matches, this.adapter, this.service).open();
    } catch (e) {
      console.error("Error fetching unsynced contacts:", e);
      new import_obsidian29.Notice(`Error: ${e.message}`);
    }
  }
  async fetchUnsyncedContacts() {
    const matches = [];
    let pageToken = void 0;
    let limit = 10;
    let pagesFetched = 0;
    const MAX_PAGES = 20;
    while (matches.length < limit && pagesFetched < MAX_PAGES) {
      const response = await this.adapter.listContacts(30, pageToken);
      if (!response.contacts || response.contacts.length === 0) {
        break;
      }
      for (const contact of response.contacts) {
        if (contact.customFields && contact.customFields["eloSyncDate"]) {
          continue;
        }
        const match = {
          contact
        };
        const suggested = this.findSuggestedNote(contact.name);
        if (suggested) {
          match.suggestedNote = suggested;
        }
        matches.push(match);
        if (matches.length >= limit)
          break;
      }
      pageToken = response.nextPageToken;
      pagesFetched++;
      if (!pageToken)
        break;
    }
    return matches;
  }
  findSuggestedNote(contactName) {
    if (!contactName)
      return void 0;
    const lowerName = contactName.toLowerCase();
    const files = this.app.vault.getMarkdownFiles();
    let exact = files.find((f) => f.basename.toLowerCase() === lowerName);
    if (exact)
      return exact;
    return files.find((f) => f.basename.toLowerCase().includes(lowerName) || lowerName.includes(f.basename.toLowerCase()));
  }
};
var UnsyncedContactsBatchModal = class extends import_obsidian29.Modal {
  constructor(app, matches, adapter, service) {
    super(app);
    this.matches = matches;
    this.adapter = adapter;
    this.service = service;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Contactos de Google No Sincronizados" });
    contentEl.createEl("p", { text: "Se muestran hasta 10 contactos pendientes. Elige una acci\xF3n para cada uno." });
    const container = contentEl.createDiv({ cls: "elo-google-contacts-list" });
    this.matches.forEach((match) => {
      this.renderContactItem(container, match);
    });
  }
  renderContactItem(container, match) {
    var _a2, _b;
    const itemDiv = container.createDiv({ cls: "elo-contact-item", attr: { style: "display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--background-modifier-border);" } });
    const infoDiv = itemDiv.createDiv();
    infoDiv.createEl("strong", { text: match.contact.name });
    const details = [(_a2 = match.contact.email) == null ? void 0 : _a2[0], (_b = match.contact.phone) == null ? void 0 : _b[0]].filter(Boolean).join(", ");
    if (details) {
      infoDiv.createEl("small", { text: ` (${details})`, attr: { style: "color: var(--text-muted);" } });
    }
    if (match.suggestedNote) {
      infoDiv.createDiv({ text: `\u{1F4A1} Sugerencia: [[${match.suggestedNote.basename}]]`, attr: { style: "color: var(--text-accent); font-size: 0.9em;" } });
    }
    const actionsDiv = itemDiv.createDiv({ attr: { style: "display: flex; gap: 5px;" } });
    new import_obsidian29.ButtonComponent(actionsDiv).setButtonText(match.suggestedNote ? "Enlazar" : "Enlazar...").setIcon("link").setTooltip(match.suggestedNote ? `Enlazar con ${match.suggestedNote.basename}` : "Buscar nota para enlazar").onClick(async () => {
      if (match.suggestedNote) {
        await this.service.linkContactToNote(match.contact, match.suggestedNote);
        itemDiv.remove();
      } else {
        this.close();
        new NoteSelectionModal(this.app, match.contact, async (file) => {
          await this.service.linkContactToNote(match.contact, file);
        }).open();
      }
    });
    new import_obsidian29.ButtonComponent(actionsDiv).setButtonText("Crear").setIcon("file-plus").setCta().setTooltip("Crear nueva nota en Personas/Conocidos-mios").onClick(async () => {
      const newFile = await this.service.createNoteFromContact(match.contact);
      new import_obsidian29.Notice(`Nota creada: ${newFile.basename}`);
      itemDiv.remove();
    });
    new import_obsidian29.ButtonComponent(actionsDiv).setButtonText("Mover").setIcon("import").setTooltip("Crear nota y eliminar de Google").onClick(async () => {
      if (confirm(`\xBFCrear nota para "${match.contact.name}" y eliminarlo de Google?`)) {
        await this.service.createNoteFromContact(match.contact);
        if (match.contact.id) {
          await this.adapter.deleteContact(match.contact.id);
          new import_obsidian29.Notice(`Movido a Obsidian: ${match.contact.name}`);
        }
        itemDiv.remove();
      }
    });
    new import_obsidian29.ButtonComponent(actionsDiv).setButtonText("Eliminar").setIcon("trash").setWarning().setTooltip("Eliminar de Google Contacts").onClick(async () => {
      if (confirm(`\xBFSeguro que quieres eliminar a "${match.contact.name}" de Google Contacts?`)) {
        if (match.contact.id) {
          await this.adapter.deleteContact(match.contact.id);
          new import_obsidian29.Notice(`Eliminado de Google: ${match.contact.name}`);
        }
        itemDiv.remove();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var NoteSelectionModal = class extends import_obsidian29.FuzzySuggestModal {
  constructor(app, contact, onSelect) {
    super(app);
    this.contact = contact;
    this.onSelect = onSelect;
    this.setPlaceholder(`Selecciona nota para enlazar con "${contact.name}"`);
  }
  getItems() {
    return this.app.vault.getMarkdownFiles();
  }
  getItemText(item) {
    return item.path;
  }
  onChooseItem(item, evt) {
    this.onSelect(item);
  }
};

// src/Infrastructure/Obsidian/Commands/Dictionary/TokenizeAndCreateDictionaryNotesCommand.ts
var TokenizeAndCreateDictionaryNotesCommand = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  async execute(file) {
    const activeView = getActiveMarkdownView(this.app, file);
    if (!activeView) {
      showMessage("No active markdown view");
      return;
    }
    const targetFile = activeView.file;
    if (!targetFile) {
      showMessage("No active file");
      return;
    }
    await this.processFile(targetFile);
  }
  async processFile(file) {
    const content = await this.app.vault.read(file);
    const metadata = this.app.metadataCache.getFileCache(file);
    const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
    let noteLanguage = frontmatter == null ? void 0 : frontmatter["language"];
    const userLanguage = this.settings.userLanguage || "es";
    if (!noteLanguage) {
      showMessage("Metadata 'language' not found in note. Using 'en' as default.");
      noteLanguage = "en";
    }
    const dictionaryFolder = `-Diccionario/${noteLanguage}-${userLanguage}`;
    if (!this.app.vault.getAbstractFileByPath(dictionaryFolder)) {
      try {
        await this.app.vault.createFolder(dictionaryFolder);
      } catch (e) {
      }
    }
    let body = content;
    if (metadata == null ? void 0 : metadata.frontmatterPosition) {
      body = content.substring(metadata.frontmatterPosition.end.offset);
    }
    const tokens = body.toLowerCase().match(/\b[a-zA-Z-]+\b/g);
    if (!tokens || tokens.length === 0) {
      showMessage("No tokens found in note.");
      return;
    }
    const uniqueTokens = [...new Set(tokens)];
    let createdCount = 0;
    for (const token of uniqueTokens) {
      if (token.length < 2)
        continue;
      const safeTokenFilename = token;
      const filePath = `${dictionaryFolder}/${safeTokenFilename}.md`;
      const fileExists = this.app.vault.getAbstractFileByPath(filePath);
      if (!fileExists) {
        await this.app.vault.create(filePath, "");
        createdCount++;
      }
    }
    showMessage(`Dictionary sync complete. Created ${createdCount} notes in ${dictionaryFolder}.`);
  }
};

// src/Infrastructure/Obsidian/Commands/GoogleKeep/ImportKeepTakeoutCommand.ts
var import_obsidian30 = require("obsidian");
var fs3 = __toESM(require("fs"));
var path4 = __toESM(require("path"));
var ImportModal = class extends import_obsidian30.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.result = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Importar Google Keep desde Takeout" });
    new import_obsidian30.Setting(contentEl).setName("Ruta de la carpeta 'Keep'").setDesc("Ruta absoluta donde se encuentran los archivos JSON y las im\xE1genes (ej: /Users/usuario/Downloads/Takeout/Keep)").addText(
      (text) => text.onChange((value) => {
        this.result = value;
      })
    );
    new import_obsidian30.Setting(contentEl).addButton((btn) => btn.setButtonText("Importar").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ImportKeepTakeoutCommand = class {
  constructor(app) {
    this.app = app;
  }
  async execute() {
    new ImportModal(this.app, async (folderPath) => {
      if (!folderPath)
        return;
      await this.importNotes(folderPath);
    }).open();
  }
  async importNotes(folderPath) {
    const notice = new import_obsidian30.Notice("Iniciando importaci\xF3n...", 0);
    try {
      if (!fs3.existsSync(folderPath)) {
        new import_obsidian30.Notice("La carpeta especificada no existe.");
        return;
      }
      const files = fs3.readdirSync(folderPath);
      const jsonFiles = files.filter((f) => f.endsWith(".json"));
      const total = jsonFiles.length;
      let current = 0;
      const attachmentsFolder = "Keep Attachments";
      if (!await this.app.vault.adapter.exists(attachmentsFolder)) {
        await this.app.vault.createFolder(attachmentsFolder);
      }
      for (const file of jsonFiles) {
        current++;
        notice.setMessage(`Importando nota ${current}/${total}`);
        const fullPath = path4.join(folderPath, file);
        const content = fs3.readFileSync(fullPath, "utf-8");
        try {
          const note = JSON.parse(content);
          if (note.isTrashed)
            continue;
          await this.createObsidianNote(note, folderPath, attachmentsFolder);
        } catch (e) {
          console.error(`Error parsing ${file}:`, e);
        }
      }
      new import_obsidian30.Notice(`Importaci\xF3n completada. ${current} notas procesadas.`);
    } catch (e) {
      console.error(e);
      new import_obsidian30.Notice("Error durante la importaci\xF3n. Revisa la consola.");
    } finally {
      notice.hide();
    }
  }
  async createObsidianNote(note, sourceFolder, attachmentsFolder) {
    var _a2;
    let filename = this.sanitizeFilename(note.title);
    if (!filename) {
      const date = new Date(note.createdTimestampUsec / 1e3);
      filename = `Keep Note - ${date.toISOString().replace(/[:.]/g, "-")}`;
    }
    let targetPath = `${filename}.md`;
    let counter = 1;
    while (await this.app.vault.adapter.exists(targetPath)) {
      targetPath = `${filename} (${counter}).md`;
      counter++;
    }
    let body = "";
    const tags = ((_a2 = note.labels) == null ? void 0 : _a2.map((l) => l.name)) || [];
    if (note.color !== "DEFAULT")
      tags.push(`KeepColor/${note.color}`);
    const frontmatter = [
      "---",
      `created: ${new Date(note.createdTimestampUsec / 1e3).toISOString()}`,
      `updated: ${new Date(note.userEditedTimestampUsec / 1e3).toISOString()}`,
      tags.length > 0 ? `tags:
  - ${tags.join("\n  - ")}` : "tags: []",
      "---",
      ""
    ].join("\n");
    body += frontmatter;
    if (note.textContent) {
      body += note.textContent + "\n\n";
    }
    if (note.listContent) {
      for (const item of note.listContent) {
        const check = item.isChecked ? "x" : " ";
        body += `- [${check}] ${item.text}
`;
      }
      body += "\n";
    }
    if (note.annotations) {
      for (const ann of note.annotations) {
        if (ann.source === "WEBLINK") {
          body += `[${ann.title}](${ann.url})

`;
        }
      }
    }
    if (note.attachments) {
      for (const att of note.attachments) {
        const sourceFile = path4.join(sourceFolder, att.filePath);
        if (fs3.existsSync(sourceFile)) {
          const ext = path4.extname(att.filePath);
          const destName = `${path4.basename(att.filePath, ext)}-${Date.now()}${ext}`;
          const destPath = `${attachmentsFolder}/${destName}`;
          const buffer = fs3.readFileSync(sourceFile);
          const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
          await this.app.vault.createBinary(destPath, arrayBuffer);
          body += `![[${destName}]]
`;
        }
      }
    }
    await this.app.vault.create(targetPath, body);
  }
  sanitizeFilename(name) {
    if (!name)
      return "";
    return name.replace(/[\\/:*?"<>|]/g, "").trim();
  }
};

// src/Infrastructure/Obsidian/Commands/Series/DownloadSubtitlesCommand.ts
var import_obsidian32 = require("obsidian");

// src/Infrastructure/Obsidian/Services/OpenSubtitlesService.ts
var import_obsidian31 = require("obsidian");
var OpenSubtitlesService = class {
  constructor(settings) {
    this.settings = settings;
    this.baseUrl = "https://api.opensubtitles.com/api/v1";
    this.token = null;
  }
  async login() {
    if (!this.settings.apiKey || !this.settings.username || !this.settings.password) {
      throw new Error("OpenSubtitles credentials are missing in settings.");
    }
    const response = await (0, import_obsidian31.requestUrl)({
      url: `${this.baseUrl}/login`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Api-Key": this.settings.apiKey
      },
      body: JSON.stringify({
        username: this.settings.username,
        password: this.settings.password
      })
    });
    if (response.status !== 200) {
      throw new Error(`OpenSubtitles Login Failed: ${response.text}`);
    }
    this.token = response.json.token;
  }
  async getAuthHeaders() {
    if (!this.token) {
      await this.login();
    }
    return {
      "Content-Type": "application/json",
      "Api-Key": this.settings.apiKey,
      "Authorization": `Bearer ${this.token}`
    };
  }
  /**
   * Search for English subtitles for a specific episode.
   */
  async search(query, season, episode) {
    const headers = await this.getAuthHeaders();
    const params = new URLSearchParams({
      query,
      season_number: season.toString(),
      episode_number: episode.toString(),
      languages: "en"
    });
    const url = `${this.baseUrl}/subtitles?${params.toString()}`;
    const response = await (0, import_obsidian31.requestUrl)({
      url,
      method: "GET",
      headers
    });
    if (response.status !== 200) {
      console.error("OpenSubtitles Search Failed", response);
      return [];
    }
    return response.json.data || [];
  }
  async download(fileId) {
    const headers = await this.getAuthHeaders();
    const response = await (0, import_obsidian31.requestUrl)({
      url: `${this.baseUrl}/download`,
      method: "POST",
      headers,
      body: JSON.stringify({
        file_id: fileId
      })
    });
    if (response.status !== 200) {
      throw new Error(`OpenSubtitles Download Step 1 Failed: ${response.text}`);
    }
    const downloadUrl = response.json.link;
    const fileResponse = await (0, import_obsidian31.requestUrl)({
      url: downloadUrl,
      method: "GET"
    });
    return fileResponse.text;
  }
};

// src/Infrastructure/Obsidian/Commands/Series/DownloadSubtitlesCommand.ts
var DownloadSubtitlesCommand = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.service = new OpenSubtitlesService({
      apiKey: this.plugin.settings.openSubtitlesApiKey,
      username: this.plugin.settings.openSubtitlesUsername,
      password: this.plugin.settings.openSubtitlesPassword
    });
  }
  getCommand() {
    return {
      id: "download-subtitles",
      name: "Series: Download Subtitles",
      editorCallback: async (editor, view) => {
        var _a2;
        const frontmatter = (_a2 = this.plugin.app.metadataCache.getFileCache(view.file)) == null ? void 0 : _a2.frontmatter;
        if (!frontmatter) {
          new import_obsidian32.Notice("No frontmatter found.");
          return;
        }
        const serie = frontmatter["Serie"];
        const season = frontmatter["Temporada"];
        const episode = frontmatter["Capitulo"];
        if (!serie || !season || !episode) {
          new import_obsidian32.Notice("Missing Serie, Temporada, or Capitulo fields.");
          return;
        }
        new import_obsidian32.Notice(`Searching subtitles for ${serie} S${season}E${episode}...`);
        try {
          const results = await this.service.search(serie, Number(season), Number(episode));
          if (results.length === 0) {
            new import_obsidian32.Notice("No subtitles found.");
            return;
          }
          const bestMatch = results[0];
          if (!bestMatch.attributes.files || bestMatch.attributes.files.length === 0) {
            new import_obsidian32.Notice("Subtitle entry has no files.");
            return;
          }
          const fileId = bestMatch.attributes.files[0].file_id;
          new import_obsidian32.Notice("Downloading subtitle...");
          const subtitleContent = await this.service.download(fileId);
          const currentContent = editor.getValue();
          const newContent = currentContent + "\n\n## Subtitles\n\n" + subtitleContent;
          editor.setValue(newContent);
          new import_obsidian32.Notice("Subtitles downloaded and appended.");
        } catch (error) {
          console.error(error);
          new import_obsidian32.Notice("Error downloading subtitles. Check console.");
        }
      }
    };
  }
};

// src/Infrastructure/Obsidian/Commands/Music/ImportSpotifyPlaylistCommand.ts
var import_obsidian34 = require("obsidian");

// src/Infrastructure/Obsidian/Views/Modals/SpotifyPlaylistModal.ts
var import_obsidian33 = require("obsidian");
var SpotifyPlaylistModal = class extends import_obsidian33.Modal {
  constructor(app, musicService, onImport) {
    super(app);
    this.playlists = [];
    this.selectedPlaylist = null;
    this.musicService = musicService;
    this.onImport = onImport;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select a Playlist" });
    contentEl.createEl("p", { text: "Loading playlists..." });
    try {
      this.playlists = await this.musicService.getUserPlaylists();
      this.displayPlaylists();
    } catch (error) {
      contentEl.empty();
      contentEl.createEl("h2", { text: "Error" });
      contentEl.createEl("p", { text: "Failed to load playlists. Please check your connection and settings." });
      console.error(error);
    }
  }
  displayPlaylists() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select a Playlist" });
    const list = contentEl.createEl("ul");
    list.style.listStyle = "none";
    list.style.padding = "0";
    this.playlists.forEach((playlist) => {
      const item = list.createEl("li");
      item.style.marginBottom = "10px";
      item.style.padding = "10px";
      item.style.border = "1px solid var(--background-modifier-border)";
      item.style.borderRadius = "5px";
      item.style.cursor = "pointer";
      item.style.display = "flex";
      item.style.justifyContent = "space-between";
      item.style.alignItems = "center";
      item.createDiv({ text: playlist.name, cls: "spotify-playlist-name" }).style.fontWeight = "bold";
      item.createDiv({ text: `${playlist.totalTracks} tracks`, cls: "spotify-playlist-count" }).style.fontSize = "0.8em";
      item.addEventListener("click", () => {
        this.selectedPlaylist = playlist;
        this.displayTracks(playlist);
      });
    });
  }
  async displayTracks(playlist) {
    var _a2;
    const { contentEl } = this;
    contentEl.empty();
    const header = contentEl.createDiv();
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.marginBottom = "20px";
    const backBtn = header.createEl("button", { text: "\u2190 Back" });
    backBtn.style.marginRight = "10px";
    backBtn.addEventListener("click", () => this.displayPlaylists());
    header.createEl("h2", { text: playlist.name });
    contentEl.createEl("p", { text: "Loading tracks..." });
    try {
      const tracks = await this.musicService.getPlaylistTracks(playlist.id);
      (_a2 = contentEl.lastChild) == null ? void 0 : _a2.remove();
      if (tracks.length === 0) {
        contentEl.createEl("p", { text: "No tracks found in this playlist." });
        return;
      }
      const copyAllBtn = contentEl.createEl("button", { text: "Copy All to Clipboard" });
      copyAllBtn.style.marginBottom = "15px";
      copyAllBtn.addEventListener("click", () => {
        const text = tracks.map((t) => `${t.artists.join(", ")} - ${t.name}`).join("\n");
        navigator.clipboard.writeText(text);
        showMessage("Copied all tracks to clipboard");
        this.close();
      });
      if (this.onImport) {
        const importBtn = contentEl.createEl("button", { text: "Import to Note" });
        importBtn.style.marginBottom = "15px";
        importBtn.style.marginLeft = "10px";
        importBtn.classList.add("mod-cta");
        importBtn.addEventListener("click", () => {
          this.onImport(tracks);
          this.close();
        });
      }
      const list = contentEl.createEl("ul");
      list.style.listStyle = "none";
      list.style.padding = "0";
      tracks.forEach((track) => {
        const item = list.createEl("li");
        item.style.marginBottom = "5px";
        item.style.padding = "5px";
        item.style.borderBottom = "1px solid var(--background-modifier-border)";
        item.style.display = "flex";
        item.style.justifyContent = "space-between";
        const info = item.createDiv();
        info.createEl("span", { text: track.name }).style.fontWeight = "bold";
        info.createEl("span", { text: ` - ${track.artists.join(", ")}` });
      });
    } catch (error) {
      contentEl.empty();
      contentEl.createEl("h2", { text: "Error" });
      contentEl.createEl("p", { text: "Failed to load tracks." });
      console.error(error);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Infrastructure/Obsidian/Commands/Music/ImportSpotifyPlaylistCommand.ts
var import_core21 = __toESM(require_dist());
var ImportSpotifyPlaylistCommand = class {
  constructor(app, spotifyAdapter, musicService, onAuthRequired) {
    this.app = app;
    this.spotifyAdapter = spotifyAdapter;
    this.musicService = musicService;
    this.onAuthRequired = onAuthRequired;
    this.id = import_core21.CommandEnum.ImportPlaylistTracks;
    this.name = "Import Spotify Playlist";
  }
  checkCallback(checking) {
    const view = getActiveMarkdownView(this.app);
    if (view) {
      if (!checking) {
        this.execute(view);
      }
      return true;
    }
    if (!checking) {
      new import_obsidian34.Notice("Please open a Markdown note (checklist) to import tracks.");
    }
    return false;
  }
  async execute(view) {
    console.log("[ImportSpotifyPlaylistCommand] Start");
    if (!this.spotifyAdapter.isAuthenticated()) {
      this.onAuthRequired();
      console.log("[ImportSpotifyPlaylistCommand] End (Auth required)");
      return;
    }
    new SpotifyPlaylistModal(this.app, this.musicService, (tracks) => {
      this.importTracks(view, tracks);
    }).open();
    console.log("[ImportSpotifyPlaylistCommand] End");
  }
  async importTracks(view, tracks) {
    if (!tracks || tracks.length === 0) {
      showMessage("No tracks to import.");
      return;
    }
    const editor = view.editor;
    const currentContent = editor.getValue();
    const trackList = tracks.map((track) => {
      const artistNames = track.artists.join(", ");
      return `- [ ] ${track.name} - ${artistNames} (${track.uri})`;
    }).join("\n");
    const header = "\n\n## Imported Spotify Tracks\n";
    const newContent = currentContent + header + trackList;
    editor.setValue(newContent);
    showMessage(`Imported ${tracks.length} tracks from Spotify.`);
  }
};

// src/Infrastructure/Obsidian/Commands/Search/NaturalLanguageSearchCommand.ts
var NaturalLanguageSearchCommand = class {
  constructor(app, llm) {
    this.app = app;
    this.llm = llm;
  }
  async execute() {
    new InputModal(
      this.app,
      {
        title: "B\xFAsqueda en Lenguaje Natural",
        label: "Describe lo que buscas",
        placeholder: 'e.g., "notas de cocina creadas ayer"',
        submitText: "Buscar",
        isTextArea: true
      },
      async (query) => {
        if (!query)
          return;
        await this.processSearch(query);
      }
    ).open();
  }
  async processSearch(userQuery) {
    showMessage("Interpretando b\xFAsqueda...");
    const prompt = `
      Act\xFAa como un experto en Obsidian. Tu tarea es traducir una consulta de b\xFAsqueda en lenguaje natural a una "Search Query" v\xE1lida de Obsidian.
      
      Reglas:
      - Usa operadores de b\xFAsqueda de Obsidian como:
        - \`file:Name\` para nombre de archivo.
        - \`path:Path\` para carpeta.
        - \`content:Text\` o simplemente \`Text\` para contenido.
        - \`tag:#tag\` para etiquetas.
        - \`line:(...)\`, \`block:(...)\`, \`section:(...)\` si aplica.
        - Fechas: NO uses fechas relativas como "ayer" o "hoy". Debes calcular la fecha absoluta en formato YYYY-MM-DD bas\xE1ndote en que hoy es ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.
        - \`file:2024-01-01\` busca en el nombre, si quieres fecha de creaci\xF3n/modificaci\xF3n no hay operador nativo directo en la b\xFAsqueda global est\xE1ndar para fecha de archivo (stat), PERO si el usuario pide "notas diarias" o fechas que suelen estar en el nombre, \xFAsalo en \`file:\`.
        - **IMPORTANTE**: Cuando el usuario mencione "Campo", "Campos" o "Propiedad", se refiere a campos del Frontmatter. Usa la sintaxis de b\xFAsqueda de propiedades de Obsidian:
           - \`["nombre_campo":valor]\` para buscar un valor espec\xEDfico (e.g. \`["coche":ford]\`).
           - \`["nombre_campo"]\` para buscar notas que tengan ese campo definido, sin importar el valor.
           - Si pide "que no tenga el campo X", usa \`-["nombre_campo"]\`.
      - Si la consulta es compleja, comb\xEDnalos con espacios (AND impl\xEDcito) o OR.
      - Responde \xDANICAMENTE con la cadena de b\xFAsqueda, sin explicaciones ni markdown.

      Ejemplos:
      - "Recetas de pasta" -> "tag:#receta pasta" (si se asume tag) o "pasta"
      - "Notas de la carpeta cocina" -> "path:cocina"
      - "Notas del 2024" -> "file:2024"

      Consulta del usuario: "${userQuery}"
    `;
    const searchQuery = await this.llm.request({ prompt });
    if (!searchQuery) {
      showMessage("No se pudo interpretar la b\xFAsqueda.");
      return;
    }
    console.log(`[NaturalLanguageSearchCommand] Original: "${userQuery}" -> Query: "${searchQuery}"`);
    this.executeObsidianSearch(searchQuery.trim());
  }
  executeObsidianSearch(query) {
    var _a2;
    const internalPlugins = this.app.internalPlugins;
    const searchPlugin = internalPlugins.getPluginById("global-search");
    if (searchPlugin && searchPlugin.instance) {
      searchPlugin.instance.openGlobalSearch(query);
    } else {
      let searchLeaf = this.app.workspace.getLeavesOfType("search")[0];
      if (!searchLeaf) {
        (_a2 = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a2.setViewState({
          type: "search",
          active: true
        });
        searchLeaf = this.app.workspace.getLeavesOfType("search")[0];
      }
      if (searchLeaf) {
        const view = searchLeaf.view;
        if (typeof view.setQuery === "function") {
          view.setQuery(query);
          if (typeof view.submit === "function") {
            view.submit();
          }
        }
        this.app.workspace.revealLeaf(searchLeaf);
      } else {
        showMessage("No se pudo abrir el panel de b\xFAsqueda.");
      }
    }
  }
};

// src/Infrastructure/Obsidian/main.ts
var import_core32 = __toESM(require_dist());
var import_core33 = __toESM(require_dist());

// src/Infrastructure/Adapters/GoogleMapsAdapter/GoogleMapsAdapter.ts
var import_obsidian35 = require("obsidian");
var EMPTY_PLACE_DETAILS = {
  municipio: "",
  provincia: "",
  region: "",
  pais: ""
};
var LOG_PREFIX = "[elo-obsidian-ext]";
var GoogleMapsAdapter = class {
  constructor(apiKey, app) {
    this.apiKey = apiKey.trim();
    this.app = app;
  }
  async requestPlaceDetails(params) {
    var _a2, _b, _c;
    if (!this.apiKey) {
      showMessage(
        "Configura tu clave de la API de Google Maps en los ajustes para completar los datos de un lugar."
      );
      return null;
    }
    const trimmedName = params.placeName.trim();
    if (!trimmedName && !params.placeId) {
      console.warn(
        `${LOG_PREFIX} Google Maps request omitido: el nombre del lugar y el ID est\xE1n vac\xEDos.`
      );
      return EMPTY_PLACE_DETAILS;
    }
    try {
      let placeIdToUse = params.placeId;
      if (placeIdToUse && /^0x[a-fA-F0-9]+:0x[a-fA-F0-9]+$/.test(placeIdToUse)) {
        console.info(`${LOG_PREFIX} Detectado ID hexadecimal (CID). Resolviendo a Place ID est\xE1ndar...`);
        const resolvedPlaceId = await this.resolveCidToPlaceId(placeIdToUse);
        if (resolvedPlaceId) {
          placeIdToUse = resolvedPlaceId;
          console.info(`${LOG_PREFIX} CID resuelto a Place ID: ${placeIdToUse}`);
        } else {
          console.warn(`${LOG_PREFIX} No se pudo resolver el CID a Place ID.`);
          if (trimmedName) {
            console.info(`${LOG_PREFIX} Usando nombre "${trimmedName}" como fallback.`);
            placeIdToUse = void 0;
          } else {
            showMessage("No se pudo resolver el ID de Google Maps y no hay nombre asociado.");
            return null;
          }
        }
      }
      let query;
      if (placeIdToUse) {
        query = new URLSearchParams({
          place_id: placeIdToUse,
          key: this.apiKey,
          language: "es"
        });
      } else {
        query = new URLSearchParams({
          address: trimmedName,
          key: this.apiKey,
          language: "es"
        });
      }
      const response = await (0, import_obsidian35.requestUrl)({
        url: `https://maps.googleapis.com/maps/api/geocode/json?${query.toString()}`,
        method: "GET"
      });
      const data = (_a2 = response.json) != null ? _a2 : JSON.parse(response.text);
      if (!data || typeof data !== "object") {
        console.error(
          `${LOG_PREFIX} Google Maps devolvi\xF3 una respuesta inesperada para "${trimmedName}".`,
          data
        );
        showMessage(
          "No se pudo interpretar la respuesta de Google Maps. Revisa la consola."
        );
        return null;
      }
      console.log({ google_maps: data });
      const status = typeof data.status === "string" ? data.status : "";
      if (status !== "OK") {
        if (status === "ZERO_RESULTS") {
          console.warn(
            `${LOG_PREFIX} Google Maps no encontr\xF3 resultados para "${trimmedName}".`
          );
          showMessage(
            `Google Maps no encontr\xF3 resultados para "${trimmedName}".`
          );
          return { ...EMPTY_PLACE_DETAILS };
        }
        if (status === "INVALID_REQUEST") {
          console.error(`${LOG_PREFIX} Google Maps INVALID_REQUEST. PlaceID: ${placeIdToUse}, Name: ${trimmedName}`);
          showMessage("Error en la petici\xF3n a Google Maps (IDs inv\xE1lidos).");
          return null;
        }
        const errorMessage = typeof data.error_message === "string" ? data.error_message : "Consulta la consola para m\xE1s detalles.";
        console.error(
          `${LOG_PREFIX} Google Maps rechaz\xF3 la petici\xF3n (${status}) para "${trimmedName}": ${errorMessage}`
        );
        showMessage(
          "Google Maps rechaz\xF3 la petici\xF3n. Consulta la consola para m\xE1s detalles."
        );
        return null;
      }
      const results = Array.isArray(data.results) ? data.results : [];
      if (results.length === 0) {
        console.warn(
          `${LOG_PREFIX} Google Maps devolvi\xF3 una respuesta sin resultados para "${trimmedName}".`
        );
        return { ...EMPTY_PLACE_DETAILS };
      }
      let selectedResult;
      if (results.length > 1) {
        const userSelection = await this.askUserToSelect(results);
        if (!userSelection) {
          showMessage("Selecci\xF3n cancelada por el usuario.");
          return null;
        }
        selectedResult = userSelection;
      } else {
        selectedResult = results[0];
      }
      const placeDetails = this.extractPlaceDetails(selectedResult, 0);
      if (!placeDetails.municipio && placeDetails.provincia && placeDetails.pais) {
        console.warn(
          `${LOG_PREFIX} Google Maps no devolvi\xF3 municipio, pero s\xED provincia y pa\xEDs para "${trimmedName}". Intentando recuperar el municipio...`
        );
        const bestLocation = (_b = selectedResult.geometry) == null ? void 0 : _b.location;
        if (bestLocation) {
          console.info(
            `${LOG_PREFIX} en (${bestLocation.lat}, ${bestLocation.lng})...`
          );
          try {
            const reverseQuery = new URLSearchParams({
              latlng: `${bestLocation.lat},${bestLocation.lng}`,
              key: this.apiKey,
              language: "es"
            });
            const reverseResponse = await (0, import_obsidian35.requestUrl)({
              url: `https://maps.googleapis.com/maps/api/geocode/json?${reverseQuery.toString()}`,
              method: "GET"
            });
            const reverseData = (_c = reverseResponse.json) != null ? _c : JSON.parse(reverseResponse.text);
            if (reverseData && reverseData.status === "OK" && Array.isArray(reverseData.results) && reverseData.results.length > 0) {
              const reverseBest = this.extractPlaceDetails(reverseData.results[0], 0);
              console.log({ reverseBest, placeDetails });
              if (!placeDetails.municipio && reverseBest.municipio)
                placeDetails.municipio = reverseBest.municipio;
              if (!placeDetails.provincia && reverseBest.provincia)
                placeDetails.provincia = reverseBest.provincia;
              if (!placeDetails.region && reverseBest.region)
                placeDetails.region = reverseBest.region;
              if (!placeDetails.pais && reverseBest.pais)
                placeDetails.pais = reverseBest.pais;
              console.info(
                `${LOG_PREFIX} Datos actualizados tras geocodificaci\xF3n inversa:`,
                placeDetails
              );
            }
          } catch (reverseError) {
            console.error(
              `${LOG_PREFIX} Fall\xF3 la geocodificaci\xF3n inversa.`,
              reverseError
            );
          }
        }
      } else {
        console.info(
          `${LOG_PREFIX} Google Maps resolvi\xF3 "${trimmedName}" correctamente.`
        );
      }
      this.normalizeSpanishRegion(placeDetails);
      console.log({ placeDetails });
      return placeDetails;
    } catch (error) {
      console.error(
        `${LOG_PREFIX} Error al consultar Google Maps para "${trimmedName}".`,
        error
      );
      showMessage(
        "Google Maps no respondi\xF3. Revisa la consola para m\xE1s detalles."
      );
      return null;
    }
  }
  async resolveCidToPlaceId(hexCid) {
    var _a2;
    try {
      const parts = hexCid.split(":");
      if (parts.length !== 2)
        return null;
      const cidHex = parts[1];
      const cidDecimal = BigInt(cidHex).toString();
      const query = new URLSearchParams({
        input: `cid:${cidDecimal}`,
        inputtype: "textquery",
        fields: "place_id",
        key: this.apiKey
      });
      const url = `https://maps.googleapis.com/maps/api/place/findplacefromtext/json?${query.toString()}`;
      const response = await (0, import_obsidian35.requestUrl)({
        url,
        method: "GET"
      });
      const data = (_a2 = response.json) != null ? _a2 : JSON.parse(response.text);
      if (data.status === "OK" && Array.isArray(data.candidates) && data.candidates.length > 0) {
        return data.candidates[0].place_id;
      }
      console.warn(`${LOG_PREFIX} resolveCidToPlaceId failed: ${data.status}`, data);
      return null;
    } catch (e) {
      console.error(`${LOG_PREFIX} resolveCidToPlaceId error`, e);
      return null;
    }
  }
  async askUserToSelect(results) {
    return new Promise((resolve) => {
      const modal = new GoogleMapsSuggestModal(this.app, results, (selected) => {
        resolve(selected);
      });
      modal.open();
    });
  }
  extractPlaceDetails(result, index) {
    var _a2, _b;
    const components = Array.isArray(result.address_components) ? result.address_components : [];
    const lookup = (types) => {
      for (const component of components) {
        const componentTypes = Array.isArray(component.types) ? component.types : [];
        if (types.some((type) => componentTypes.includes(type))) {
          const value = typeof component.long_name === "string" ? component.long_name.trim() : "";
          if (value) {
            return value;
          }
        }
      }
      return "";
    };
    const lugar = lookup([
      "locality"
    ]);
    const barrio = lookup([
      "postal_town",
      "sublocality"
    ]);
    const municipio = lookup([
      "administrative_area_level_4",
      "administrative_area_level_3"
    ]);
    const provincia = lookup([
      "administrative_area_level_2"
    ]);
    const region = lookup(["administrative_area_level_1"]);
    const pais = lookup(["country"]);
    const googlePlaceId = result.place_id;
    const lat = (_a2 = result.geometry) == null ? void 0 : _a2.location.lat;
    const lng = (_b = result.geometry) == null ? void 0 : _b.location.lng;
    console.info(
      `${LOG_PREFIX} Evaluando resultado #${index + 1} para geocodificaci\xF3n.`,
      {
        lugar,
        barrio,
        municipio,
        provincia,
        region,
        pais,
        placeId: result.place_id,
        formatted_address: result.formatted_address
      }
    );
    return { lugar, barrio, municipio, provincia, region, pais, googlePlaceId, lat, lng };
  }
  normalizeSpanishRegion(place) {
    if (!place.pais || place.pais.toLowerCase() !== "espa\xF1a" && place.pais.toLowerCase() !== "spain") {
      return;
    }
    if (!place.provincia) {
      return;
    }
    const normalizedProvincia = place.provincia.trim();
    const region = PROVINCE_TO_REGION[normalizedProvincia];
    if (region) {
      console.info(
        `${LOG_PREFIX} Normalizando regi\xF3n para Espa\xF1a: "${normalizedProvincia}" -> "${region}"`
      );
      place.region = region;
    }
  }
};
var GoogleMapsSuggestModal = class extends import_obsidian35.SuggestModal {
  constructor(app, results, resolve) {
    super(app);
    this.results = results;
    this.isResolved = false;
    this.resolve = resolve;
    console.log("[GoogleMapsSuggestModal] Created (SuggestModal) with results:", results.length);
  }
  getSuggestions(query) {
    const lowerQuery = query.toLowerCase();
    return this.results.filter((item) => {
      const text = item.formatted_address || "";
      return text.toLowerCase().includes(lowerQuery);
    });
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.formatted_address || "Ubicaci\xF3n desconocida" });
  }
  selectSuggestion(value, evt) {
    console.log("[GoogleMapsSuggestModal] selectSuggestion called (pre-super)", value);
    this.isResolved = true;
    this.resolve(value);
    super.selectSuggestion(value, evt);
  }
  onChooseSuggestion(item, evt) {
    console.log("[GoogleMapsSuggestModal] onChooseSuggestion called", item);
  }
  onClose() {
    console.log("[GoogleMapsSuggestModal] onClose called. isResolved:", this.isResolved);
    if (!this.isResolved) {
      this.resolve(null);
    }
  }
};
var PROVINCE_TO_REGION = {
  Alava: "Pa\xEDs Vasco",
  \u00C1lava: "Pa\xEDs Vasco",
  Araba: "Pa\xEDs Vasco",
  Albacete: "Castilla-La Mancha",
  Alicante: "Comunitat Valenciana",
  Alacant: "Comunitat Valenciana",
  Almer\u00EDa: "Andaluc\xEDa",
  Asturias: "Principado de Asturias",
  Avila: "Castilla y Le\xF3n",
  \u00C1vila: "Castilla y Le\xF3n",
  Badajoz: "Extremadura",
  Baleares: "Illes Balears",
  "Illes Balears": "Illes Balears",
  Barcelona: "Catalu\xF1a",
  Burgos: "Castilla y Le\xF3n",
  Caceres: "Extremadura",
  C\u00E1ceres: "Extremadura",
  Cadiz: "Andaluc\xEDa",
  C\u00E1diz: "Andaluc\xEDa",
  Cantabria: "Cantabria",
  Castellon: "Comunitat Valenciana",
  Castell\u00F3n: "Comunitat Valenciana",
  Castell\u00F3: "Comunitat Valenciana",
  Ceuta: "Ceuta",
  "Ciudad Real": "Castilla-La Mancha",
  Cordoba: "Andaluc\xEDa",
  C\u00F3rdoba: "Andaluc\xEDa",
  Cuenca: "Castilla-La Mancha",
  Gerona: "Catalu\xF1a",
  Girona: "Catalu\xF1a",
  Granada: "Andaluc\xEDa",
  Guadalajara: "Castilla-La Mancha",
  Guipuzcoa: "Pa\xEDs Vasco",
  Guip\u00FAzcoa: "Pa\xEDs Vasco",
  Gipuzkoa: "Pa\xEDs Vasco",
  Huelva: "Andaluc\xEDa",
  Huesca: "Arag\xF3n",
  Jaen: "Andaluc\xEDa",
  Ja\u00E9n: "Andaluc\xEDa",
  "La Coru\xF1a": "Galicia",
  "A Coru\xF1a": "Galicia",
  "La Rioja": "La Rioja",
  "Las Palmas": "Canarias",
  Leon: "Castilla y Le\xF3n",
  Le\u00F3n: "Castilla y Le\xF3n",
  Lerida: "Catalu\xF1a",
  L\u00E9rida: "Catalu\xF1a",
  Lleida: "Catalu\xF1a",
  Lugo: "Galicia",
  Madrid: "Comunidad de Madrid",
  Malaga: "Andaluc\xEDa",
  M\u00E1laga: "Andaluc\xEDa",
  Melilla: "Melilla",
  Murcia: "Regi\xF3n de Murcia",
  Navarra: "Comunidad Foral de Navarra",
  Orense: "Galicia",
  Ourense: "Galicia",
  Palencia: "Castilla y Le\xF3n",
  Pontevedra: "Galicia",
  Salamanca: "Castilla y Le\xF3n",
  "Santa Cruz de Tenerife": "Canarias",
  Segovia: "Castilla y Le\xF3n",
  Sevilla: "Andaluc\xEDa",
  Soria: "Castilla y Le\xF3n",
  Tarragona: "Catalu\xF1a",
  Teruel: "Arag\xF3n",
  Toledo: "Castilla-La Mancha",
  Valencia: "Comunitat Valenciana",
  Val\u00E8ncia: "Comunitat Valenciana",
  Valladolid: "Castilla y Le\xF3n",
  Vizcaya: "Pa\xEDs Vasco",
  Bizkaia: "Pa\xEDs Vasco",
  Zamora: "Castilla y Le\xF3n",
  Zaragoza: "Arag\xF3n"
};

// src/Infrastructure/Adapters/GoogleImageSearchAdapter/GoogleImageSearchAdapter.ts
var import_obsidian36 = require("obsidian");
var LOG_PREFIX2 = "[GoogleImageSearchAdapter]";
var GoogleImageSearchAdapter = class {
  constructor(apiKey, searchEngineId) {
    this.apiKey = apiKey;
    this.searchEngineId = searchEngineId;
  }
  async searchImages(query, count) {
    var _a2;
    if (!this.apiKey || !this.searchEngineId) {
      console.warn(`${LOG_PREFIX2} Missing API Key or Search Engine ID.`);
      return [];
    }
    try {
      const url = `https://www.googleapis.com/customsearch/v1?q=${encodeURIComponent(query)}&cx=${this.searchEngineId}&key=${this.apiKey}&searchType=image&num=${count}`;
      const response = await (0, import_obsidian36.requestUrl)({
        url,
        method: "GET"
      });
      const data = (_a2 = response.json) != null ? _a2 : JSON.parse(response.text);
      if (data.error) {
        console.error(`${LOG_PREFIX2} API Error: ${data.error.message}`);
        showMessage(`Image search failed: ${data.error.message}`);
        return [];
      }
      if (!data.items || data.items.length === 0) {
        console.warn(`${LOG_PREFIX2} No images found for query: "${query}"`);
        return [];
      }
      return data.items.map((item) => item.link);
    } catch (error) {
      console.error(`${LOG_PREFIX2} Unexpected error`, error);
      showMessage("An error occurred while searching for images.");
      return [];
    }
  }
};

// src/Infrastructure/Obsidian/Views/Settings/SettingsView.ts
var import_obsidian37 = require("obsidian");
var SettingsView = class extends import_obsidian37.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", {
      text: "Elocuency Settings"
    });
    new import_obsidian37.Setting(containerEl).setName("User Language").setDesc('Your primary language (e.g., "es").').addText((text) => {
      text.setPlaceholder("es").setValue(this.plugin.settings.userLanguage).onChange(async (value) => {
        this.plugin.settings.userLanguage = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian37.Setting(containerEl).setName("To Learn Language").setDesc('The language you are learning (e.g., "en").').addText((text) => {
      text.setPlaceholder("en").setValue(this.plugin.settings.toLearnLanguage).onChange(async (value) => {
        this.plugin.settings.toLearnLanguage = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian37.Setting(containerEl).setName("Note location strategy").setDesc(
      "Create notes alongside the source file or inside a fixed folder."
    ).addDropdown((dropdown) => {
      dropdown.addOption("same-folder", "Same folder as link source").addOption("fixed-folder", "Fixed folder").setValue(this.plugin.settings.locationStrategy).onChange(async (value) => {
        this.plugin.settings.locationStrategy = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian37.Setting(containerEl).setName("Target folder").setDesc(
      "Folder where notes are created when using the fixed folder strategy."
    ).addText((text) => {
      text.setPlaceholder("inbox").setValue(this.plugin.settings.targetFolder).onChange(async (value) => {
        this.plugin.settings.targetFolder = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian37.Setting(containerEl).setName("Note template").setDesc("Template used when creating new notes (supports {{title}}).").addTextArea((text) => {
      text.setPlaceholder("# {{title}}").setValue(this.plugin.settings.missingNotesTemplatePath).onChange(async (value) => {
        this.plugin.settings.missingNotesTemplatePath = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
    });
    new import_obsidian37.Setting(containerEl).setName("Gemini API key").setDesc(
      "Used to ask Gemini for descriptions when a template has no body content."
    ).addText((text) => {
      text.setPlaceholder("AIza...").setValue(this.plugin.settings.geminiApiKey).onChange(async (value) => {
        this.plugin.settings.geminiApiKey = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian37.Setting(containerEl).setName("Roles Folder").setDesc("Folder containing notes with roles for Chat Session (defined by !!prompt frontmatter).").addText((text) => {
      text.setPlaceholder("Roles").setValue(this.plugin.settings.geminiRolesFolder).onChange(async (value) => {
        this.plugin.settings.geminiRolesFolder = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian37.Setting(containerEl).setName("Google Geocoding API key").setDesc(
      "Used for Geocoding (backend queries). Restricted by IP if possible."
    ).addText((text) => {
      text.setPlaceholder("AIza...").setValue(this.plugin.settings.googleGeocodingAPIKey).onChange(async (value) => {
        this.plugin.settings.googleGeocodingAPIKey = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian37.Setting(containerEl).setName("Google Maps Embed API key").setDesc(
      "Used for rendering the map (frontend). Restricted by HTTP Referrer."
    ).addText((text) => {
      text.setPlaceholder("AIza...").setValue(this.plugin.settings.googleMapsEmbedAPIKey).onChange(async (value) => {
        this.plugin.settings.googleMapsEmbedAPIKey = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian37.Setting(containerEl).setName("Google Custom Search API key").setDesc("Used for searching images.").addText((text) => {
      text.setPlaceholder("AIza...").setValue(this.plugin.settings.googleCustomSearchApiKey).onChange(async (value) => {
        this.plugin.settings.googleCustomSearchApiKey = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian37.Setting(containerEl).setName("Google Custom Search Engine ID").setDesc("CX ID for the custom search engine.").addText((text) => {
      text.setPlaceholder("0123456789...").setValue(this.plugin.settings.googleCustomSearchEngineId).onChange(async (value) => {
        this.plugin.settings.googleCustomSearchEngineId = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian37.Setting(containerEl).setName("Spotify Client ID").setDesc("Required for Spotify integration.").addText((text) => {
      text.setPlaceholder("Client ID").setValue(this.plugin.settings.spotifyClientId).onChange(async (value) => {
        this.plugin.settings.spotifyClientId = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian37.Setting(containerEl).setName("Spotify Access Token").setDesc("Access token for Spotify API.").addText((text) => {
      text.setPlaceholder("Access Token").setValue(this.plugin.settings.spotifyAccessToken).onChange(async (value) => {
        this.plugin.settings.spotifyAccessToken = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian37.Setting(containerEl).setName("Spotify Redirect URI").setDesc("Must match exactly what is in Spotify Dashboard.").addText((text) => {
      text.setPlaceholder("http://localhost:8080").setValue(this.plugin.settings.spotifyRedirectUri).onChange(async (value) => {
        this.plugin.settings.spotifyRedirectUri = value.trim();
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Google Integration (Contacts)" });
    new import_obsidian37.Setting(containerEl).setName("Google Client ID").setDesc("OAuth2 Client ID for Google People API.").addText((text) => {
      text.setPlaceholder("Client ID").setValue(this.plugin.settings.googleClientId).onChange(async (value) => {
        this.plugin.settings.googleClientId = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian37.Setting(containerEl).setName("Google Client Secret").setDesc("OAuth2 Client Secret.").addText((text) => {
      text.setPlaceholder("Client Secret").setValue(this.plugin.settings.googleClientSecret).onChange(async (value) => {
        this.plugin.settings.googleClientSecret = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian37.Setting(containerEl).setName("Google Refresh Token").setDesc("OAuth2 Refresh Token (Get this via OAuth Playground or similar).").addText((text) => {
      text.setPlaceholder("Refresh Token").setValue(this.plugin.settings.googleRefreshToken).onChange(async (value) => {
        this.plugin.settings.googleRefreshToken = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    containerEl.createEl("h3", { text: "OpenSubtitles" });
    new import_obsidian37.Setting(containerEl).setName("API Key").setDesc("Consumer Key from OpenSubtitles.com API.").addText((text) => {
      text.setPlaceholder("API Key").setValue(this.plugin.settings.openSubtitlesApiKey).onChange(async (value) => {
        this.plugin.settings.openSubtitlesApiKey = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian37.Setting(containerEl).setName("Username").setDesc("OpenSubtitles.com Username.").addText((text) => {
      text.setPlaceholder("Username").setValue(this.plugin.settings.openSubtitlesUsername).onChange(async (value) => {
        this.plugin.settings.openSubtitlesUsername = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian37.Setting(containerEl).setName("Password").setDesc("OpenSubtitles.com Password.").addText((text) => {
      text.setPlaceholder("Password").setValue(this.plugin.settings.openSubtitlesPassword).onChange(async (value) => {
        this.plugin.settings.openSubtitlesPassword = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
  }
};

// src/Infrastructure/Obsidian/Views/Renderers/SpotifyPlayer.ts
var import_obsidian38 = require("obsidian");
function registerSpotifyRenderer(plugin) {
  console.log("[SpotifyPlayer] Registering markdown post processor");
  plugin.registerMarkdownPostProcessor((element, context) => {
    renderFrontmatterPlayer(plugin, element, context);
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
    const nodesToReplace = [];
    let node;
    while (node = walker.nextNode()) {
      const textHTML = node.textContent || "";
      const regex = /\((spotify:[a-zA-Z0-9]+:[a-zA-Z0-9]+)\)/g;
      const matches = [...textHTML.matchAll(regex)];
      if (matches.length > 0) {
        nodesToReplace.push({ node, matches });
      }
    }
    for (const { node: node2, matches } of nodesToReplace) {
      const parent = node2.parentNode;
      if (!parent)
        continue;
      const fragment = document.createDocumentFragment();
      let lastIndex = 0;
      const textContent = node2.textContent || "";
      for (const match of matches) {
        if (match.index === void 0)
          continue;
        if (match.index > lastIndex) {
          fragment.appendChild(document.createTextNode(textContent.slice(lastIndex, match.index)));
        }
        const uri = match[1];
        const container = fragment.createEl("span", { cls: "elo-spotify-inline-play" });
        container.style.marginLeft = "5px";
        container.style.cursor = "pointer";
        container.style.color = "var(--text-accent)";
        container.setAttribute("aria-label", `Play on Spotify`);
        const iconSpan = container.createSpan();
        (0, import_obsidian38.setIcon)(iconSpan, "play-circle");
        container.addEventListener("click", (e) => {
          e.preventDefault();
          window.open(uri);
        });
        lastIndex = match.index + match[0].length;
      }
      if (lastIndex < textContent.length) {
        fragment.appendChild(document.createTextNode(textContent.slice(lastIndex)));
      }
      parent.replaceChild(fragment, node2);
    }
  });
}
function renderFrontmatterPlayer(plugin, element, context) {
  var _a2;
  const file = plugin.app.vault.getAbstractFileByPath(context.sourcePath);
  if (!(file instanceof import_obsidian38.TFile)) {
    return;
  }
  const cache = plugin.app.metadataCache.getFileCache(file);
  const frontmatter = cache == null ? void 0 : cache.frontmatter;
  if (!frontmatter) {
    return;
  }
  const type = (_a2 = frontmatter.type) == null ? void 0 : _a2.toLowerCase();
  const validTypes = ["singer", "cantante", "song", "canci\xF3n"];
  if (!validTypes.includes(type)) {
    return;
  }
  if (element.querySelector(".elo-spotify-container"))
    return;
  const spotifyUri = frontmatter.spotify_uri;
  const container = element.createDiv({ cls: "elo-spotify-container" });
  container.style.marginTop = "10px";
  container.style.marginBottom = "10px";
  container.style.display = "flex";
  container.style.alignItems = "center";
  if (spotifyUri) {
    const parts = spotifyUri.split(":");
    if (parts.length === 3 && parts[0] === "spotify") {
      const type2 = parts[1];
      const id = parts[2];
      const embedUrl = `https://open.spotify.com/embed/${type2}/${id}`;
      const iframe = container.createEl("iframe");
      iframe.src = embedUrl;
      iframe.width = "100%";
      iframe.height = "152";
      iframe.setAttribute("frameborder", "0");
      iframe.setAttribute("allowtransparency", "true");
      iframe.setAttribute("allow", "encrypted-media; clipboard-write; fullscreen; picture-in-picture");
      iframe.setAttribute("sandbox", "allow-forms allow-presentation allow-same-origin allow-scripts allow-popups");
      iframe.setAttribute("loading", "lazy");
      container.style.width = "100%";
    } else {
      const button = container.createEl("button", { text: "Invalid Spotify URI" });
      button.disabled = true;
    }
  } else {
    const button = container.createEl("button", { text: "Search on Spotify" });
    button.style.backgroundColor = "#191414";
    button.style.color = "white";
    button.style.border = "none";
    button.style.borderRadius = "20px";
    button.style.padding = "8px 16px";
    button.style.cursor = "pointer";
    button.style.fontWeight = "bold";
    button.style.fontSize = "14px";
    button.addEventListener("click", () => {
      const query = encodeURIComponent(file.basename);
      window.open(`spotify:search:${query}`);
    });
  }
}

// src/Infrastructure/Obsidian/Views/Modals/SpotifyModal.ts
var import_obsidian39 = require("obsidian");
var SpotifyModal = class extends import_obsidian39.Modal {
  constructor(app, musicService) {
    super(app);
    this.musicService = musicService;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Search Spotify Track" });
    let searchQuery = "";
    new import_obsidian39.Setting(contentEl).setName("Search Query").setDesc("Enter song name").addText((text) => text.setPlaceholder("Bohemian Rhapsody").onChange((value) => {
      searchQuery = value;
    }).inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        this.performSearch(searchQuery, contentEl);
      }
    }));
    new import_obsidian39.Setting(contentEl).addButton((btn) => btn.setButtonText("Search").setCta().onClick(() => {
      this.performSearch(searchQuery, contentEl);
    }));
    contentEl.createDiv({ cls: "spotify-results-container" });
  }
  async performSearch(query, contentEl) {
    if (!query) {
      showMessage("Please enter a search query");
      return;
    }
    const resultsContainer = contentEl.querySelector(".spotify-results-container");
    if (resultsContainer) {
      resultsContainer.empty();
      resultsContainer.createEl("p", { text: "Searching..." });
    }
    try {
      const tracks = await this.musicService.searchTracks(query);
      if (resultsContainer) {
        resultsContainer.empty();
        if (tracks.length === 0) {
          resultsContainer.createEl("p", { text: "No results found." });
          return;
        }
        const list = resultsContainer.createEl("ul");
        list.style.listStyle = "none";
        list.style.padding = "0";
        tracks.forEach((track) => {
          const item = list.createEl("li");
          item.style.marginBottom = "10px";
          item.style.padding = "10px";
          item.style.border = "1px solid var(--background-modifier-border)";
          item.style.borderRadius = "5px";
          item.style.display = "flex";
          item.style.justifyContent = "space-between";
          item.style.alignItems = "center";
          const info = item.createDiv();
          info.createEl("div", { text: track.name, cls: "spotify-track-name" }).style.fontWeight = "bold";
          info.createEl("div", { text: `${track.artists.join(", ")} - ${track.album}`, cls: "spotify-track-details" }).style.fontSize = "0.8em";
          const copyBtn = item.createEl("button", { text: "Copy URI" });
          copyBtn.addEventListener("click", () => {
            navigator.clipboard.writeText(track.uri);
            showMessage(`Copied ${track.uri} to clipboard`);
            this.close();
          });
        });
      }
    } catch (error) {
      showMessage("Error searching Spotify. Check console and settings.");
      console.error(error);
      if (resultsContainer) {
        resultsContainer.empty();
        resultsContainer.createEl("p", { text: "Error occurred. Please check your API settings." });
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Infrastructure/Obsidian/Views/Renderers/GoogleMapsRenderer.ts
var import_obsidian40 = require("obsidian");
var import_core22 = __toESM(require_dist());
function registerGoogleMapsRenderer(plugin) {
  console.log("[GoogleMapsRenderer] Registering markdown post processor");
  plugin.registerMarkdownPostProcessor((element, context) => {
    var _a2, _b;
    const file = plugin.app.vault.getAbstractFileByPath(context.sourcePath);
    if (!(file instanceof import_obsidian40.TFile)) {
      return;
    }
    const cache = plugin.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!frontmatter) {
      return;
    }
    const getFrontmatterValue = (key) => {
      const entry = Object.entries(frontmatter).find(([k]) => k.toLowerCase() === key.toLowerCase());
      return entry ? entry[1] : void 0;
    };
    let placeId = getFrontmatterValue(import_core22.FrontmatterKeys.LugarId);
    if (placeId && typeof placeId === "string") {
      const normalizedId = placeId.trim();
      if (normalizedId.startsWith("google-maps-id:")) {
        placeId = normalizedId.replace("google-maps-id:", "").trim();
      } else {
        placeId = null;
      }
    } else {
      placeId = null;
    }
    const lat = getFrontmatterValue(import_core22.FrontmatterKeys.Latitud);
    const lng = getFrontmatterValue(import_core22.FrontmatterKeys.Longitud);
    if (!placeId && (!lat || !lng)) {
      return;
    }
    if (element.querySelector(".elo-google-maps-container")) {
      return;
    }
    const sectionInfo = context.getSectionInfo(element);
    if (!sectionInfo)
      return;
    const frontmatterEndLine = (_b = (_a2 = frontmatter.position) == null ? void 0 : _a2.end.line) != null ? _b : -1;
    const currentLine = sectionInfo.lineStart;
    if (currentLine > frontmatterEndLine + 5) {
      return;
    }
    console.log("[GoogleMapsRenderer] Rendering map for:", file.basename);
    const container = element.createDiv({ cls: "elo-google-maps-container" });
    container.style.marginTop = "10px";
    container.style.marginBottom = "10px";
    container.style.width = "100%";
    const apiKey = plugin.settings.googleMapsEmbedAPIKey;
    if (!apiKey) {
      container.createEl("div", { text: 'Google Maps Map API Key missing in settings. Please verify "Google Maps Map API Key" is set.' });
      return;
    }
    const iframe = container.createEl("iframe");
    iframe.width = "100%";
    iframe.height = "450";
    iframe.style.border = "0";
    iframe.allow = "fullscreen";
    iframe.setAttribute("loading", "lazy");
    iframe.setAttribute("referrerpolicy", "no-referrer-when-downgrade");
    let src = "";
    if (placeId) {
      src = `https://www.google.com/maps/embed/v1/place?key=${apiKey}&q=place_id:${placeId}`;
    } else if (lat && lng) {
      src = `https://www.google.com/maps/embed/v1/view?key=${apiKey}&center=${lat},${lng}&zoom=14`;
      src = `https://www.google.com/maps/embed/v1/place?key=${apiKey}&q=${lat},${lng}`;
    }
    iframe.src = src;
  });
}

// src/Infrastructure/Obsidian/Views/Renderers/ImageGalleryRenderer.ts
var import_obsidian41 = require("obsidian");
var import_core23 = __toESM(require_dist());
function registerImageGalleryRenderer(plugin) {
  console.log("[ImageGalleryRenderer] Registering markdown post processor");
  plugin.registerMarkdownPostProcessor((element, context) => {
    var _a2, _b;
    const file = plugin.app.vault.getAbstractFileByPath(context.sourcePath);
    if (!(file instanceof import_obsidian41.TFile)) {
      return;
    }
    const cache = plugin.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!frontmatter) {
      return;
    }
    const imagesRaw = frontmatter[import_core23.FrontmatterKeys.EloImages] || [];
    const allImages = [];
    if (Array.isArray(imagesRaw)) {
      const regex = /elo-bridge:\/\/id=([^&]+)/;
      imagesRaw.forEach((entry) => {
        if (entry.startsWith("elo-bridge://")) {
          const match = entry.match(regex);
          if (match && match[1]) {
            const id = match[1];
            const url = `http://localhost:27345/image?id=${id}`;
            allImages.push(url);
          } else {
            console.log("[ImageGalleryRenderer] Failed to parse bridge link:", entry);
          }
        } else if (entry.startsWith("http")) {
          allImages.push(entry);
        }
      });
    }
    if (allImages.length === 0) {
      return;
    }
    if (element.querySelector(".elo-image-gallery-container")) {
      console.log("[ImageGalleryRenderer] Gallery already exists, skipping.");
      return;
    }
    const frontmatterEndLine = (_b = (_a2 = frontmatter.position) == null ? void 0 : _a2.end.line) != null ? _b : -1;
    const sectionInfo = context.getSectionInfo(element);
    if (!sectionInfo)
      return;
    const currentLine = sectionInfo.lineStart;
    if (currentLine > frontmatterEndLine + 5) {
      return;
    }
    console.log("[ImageGalleryRenderer] Rendering gallery for:", file.basename, "with images:", allImages);
    const container = element.createDiv({ cls: "elo-image-gallery-container" });
    container.style.marginTop = "10px";
    container.style.marginBottom = "20px";
    container.style.display = "grid";
    container.style.gap = "10px";
    container.style.gridTemplateColumns = "repeat(auto-fill, minmax(200px, 1fr))";
    container.style.width = "100%";
    allImages.forEach((url) => {
      if (typeof url !== "string" || !url.startsWith("http"))
        return;
      const imgContainer = container.createDiv({ cls: "elo-gallery-item" });
      imgContainer.style.overflow = "hidden";
      imgContainer.style.borderRadius = "8px";
      imgContainer.style.boxShadow = "0 2px 4px rgba(0,0,0,0.1)";
      imgContainer.style.aspectRatio = "9/16";
      const img = imgContainer.createEl("img");
      img.src = url;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "cover";
      img.style.cursor = "pointer";
      img.style.transition = "transform 0.2s";
      img.addEventListener("click", () => {
        window.open(url, "_blank");
      });
      img.onmouseenter = () => img.style.transform = "scale(1.05)";
      img.onmouseleave = () => img.style.transform = "scale(1)";
    });
  });
}

// src/Infrastructure/Obsidian/Views/Modals/SpotifyAuthModal.ts
var import_obsidian42 = require("obsidian");
var SpotifyAuthModal = class extends import_obsidian42.Modal {
  constructor(app, musicService) {
    super(app);
    this.musicService = musicService;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Connect to Spotify" });
    contentEl.createEl("p", { text: "You need to connect to Spotify to use this feature." });
    const step1 = contentEl.createDiv({ cls: "step-1" });
    step1.createEl("h3", { text: "Step 1: Authorize" });
    step1.createEl("p", { text: "Click the button below to open the validation page. You will be redirected to Google. Copy the URL from the address bar after the redirect." });
    new import_obsidian42.Setting(step1).addButton((btn) => btn.setButtonText("Connect Spotify").setCta().onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("Opening Browser...");
      const redirectUri = "https://google.com";
      const authUrl = await this.musicService.initiateConnection(redirectUri);
      if (authUrl) {
        window.open(authUrl);
        showMessage("Browser opened. Please login and copy the code.");
        setTimeout(() => {
          btn.setDisabled(false);
          btn.setButtonText("Connect Spotify (Retry)");
        }, 5e3);
      } else {
        showMessage("Failed to generate auth URL. Check Client ID.");
        btn.setDisabled(false);
        btn.setButtonText("Connect Spotify");
      }
    }));
    const step2 = contentEl.createDiv({ cls: "step-2" });
    step2.createEl("h3", { text: "Step 2: Enter Code" });
    let code = "";
    new import_obsidian42.Setting(step2).setName("Authorization Code").setDesc("Paste the code or the full redirect URL here.").addText((text) => text.setPlaceholder("Paste code or URL...").onChange((value) => {
      code = value.trim();
      try {
        if (code.includes("code=")) {
          const url = new URL(code);
          const extracted = url.searchParams.get("code");
          if (extracted) {
            code = extracted;
          }
        }
      } catch (e) {
      }
    }));
    new import_obsidian42.Setting(contentEl).addButton((btn) => btn.setButtonText("Verify & Connect").setCta().onClick(async () => {
      if (!code) {
        showMessage("Please enter the code.");
        return;
      }
      try {
        const redirectUri = "https://google.com";
        const success = await this.musicService.completeConnection(code, redirectUri);
        if (success) {
          showMessage("Spotify Connected Successfully!");
          this.close();
        } else {
          showMessage("Failed to verify code.");
        }
      } catch (error) {
        showMessage("Failed to connect. Check console.");
        console.error(error);
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Infrastructure/Obsidian/Views/Chat/ChatView.ts
var import_obsidian52 = require("obsidian");

// src/Infrastructure/Adapters/ObsidianRoleRepository.ts
var import_obsidian43 = require("obsidian");
var ObsidianRoleRepository = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  async loadRoles() {
    var _a2, _b, _c, _d, _e, _f;
    const folderPath = this.settings.getGeminiRolesFolder();
    if (!folderPath)
      return [];
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder || !(folder instanceof import_obsidian43.TFolder)) {
      return [];
    }
    const roles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian43.TFile && child.extension === "md") {
        const cache = this.app.metadataCache.getFileCache(child);
        const prompt = (_a2 = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a2["!!prompt"];
        const evaluationPrompt = (_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b["!!evaluationPrompt"];
        const trackLevelRaw = (_c = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _c["!!trackLevelAnswer"];
        const trackLevel = trackLevelRaw === true || trackLevelRaw === "true";
        const liveVoice = (_d = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _d["!!liveVoice"];
        const liveTemperature = (_e = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _e["!!liveTemperature"];
        const vocabularyList = (_f = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _f["!!vocabularyList"];
        if (prompt && typeof prompt === "string") {
          roles.push({
            name: child.basename,
            prompt,
            trackLevelAnswer: trackLevel,
            evaluationPrompt: typeof evaluationPrompt === "string" ? evaluationPrompt : void 0,
            liveVoice: typeof liveVoice === "string" ? liveVoice : void 0,
            liveTemperature: typeof liveTemperature === "number" ? liveTemperature : void 0,
            vocabularyList: Array.isArray(vocabularyList) ? vocabularyList : void 0
          });
        }
      }
    }
    return roles;
  }
};

// src/Infrastructure/Adapters/ObsidianSettingsAdapter.ts
var ObsidianSettingsAdapter = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  getSpotifyClientId() {
    return this.plugin.settings.spotifyClientId;
  }
  // getSpotifyClientSecret(): string {
  //     return this.plugin.settings.spotifyClientSecret;
  // }
  getSpotifyAccessToken() {
    return this.plugin.settings.spotifyAccessToken;
  }
  getSpotifyRefreshToken() {
    return this.plugin.settings.spotifyRefreshToken;
  }
  getSpotifyTokenExpirationTime() {
    return this.plugin.settings.spotifyTokenExpirationTime;
  }
  getSpotifyPkceVerifier() {
    return this.plugin.settings.spotifyPkceVerifier;
  }
  setSpotifyAccessToken(token) {
    this.plugin.settings.spotifyAccessToken = token;
  }
  setSpotifyRefreshToken(token) {
    this.plugin.settings.spotifyRefreshToken = token;
  }
  setSpotifyTokenExpirationTime(time) {
    this.plugin.settings.spotifyTokenExpirationTime = time;
  }
  setSpotifyPkceVerifier(verifier) {
    this.plugin.settings.spotifyPkceVerifier = verifier;
  }
  getGeminiRolesFolder() {
    return this.plugin.settings.geminiRolesFolder;
  }
  getUserLanguage() {
    return this.plugin.settings.userLanguage;
  }
  getToLearnLanguage() {
    return this.plugin.settings.toLearnLanguage;
  }
  setUserLanguage(lang) {
    this.plugin.settings.userLanguage = lang;
  }
  setToLearnLanguage(lang) {
    this.plugin.settings.toLearnLanguage = lang;
  }
  async saveSettings() {
    await this.plugin.saveSettings();
  }
};

// src/Infrastructure/Adapters/GoogleGeminiLiveAdapter/AudioRecorder.ts
var WORKLET_CODE = `
class GeminiAudioProcessor extends AudioWorkletProcessor {
    constructor() {
        super();
        this.bufferSize = 4096;
        this.buffer = new Float32Array(this.bufferSize);
        this.bufferIndex = 0;
    }

    process(inputs, outputs, parameters) {
        const input = inputs[0];
        if (!input || !input.length) return true;

        const channelData = input[0];
        
        for (let i = 0; i < channelData.length; i++) {
            this.buffer[this.bufferIndex++] = channelData[i];

            if (this.bufferIndex >= this.bufferSize) {
                this.flush();
            }
        }

        return true;
    }

    flush() {
        // Send the buffer to the main thread
        // We clone the buffer because the underlying ArrayBuffer might be detached or reused
        const dataToSend = new Float32Array(this.buffer);
        this.port.postMessage(dataToSend);
        this.bufferIndex = 0;
    }
}

registerProcessor('gemini-audio-processor', GeminiAudioProcessor);
`;
var AudioRecorder = class {
  constructor(onDataAvailable) {
    this.mediaStream = null;
    this.audioContext = null;
    this.workletNode = null;
    this.input = null;
    this.onDataAvailable = onDataAvailable;
  }
  async start() {
    try {
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          channelCount: 1,
          sampleRate: 16e3,
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      });
      this.audioContext = new AudioContext({
        sampleRate: 16e3
      });
      const blob = new Blob([WORKLET_CODE], { type: "application/javascript" });
      const workletUrl = URL.createObjectURL(blob);
      await this.audioContext.audioWorklet.addModule(workletUrl);
      this.input = this.audioContext.createMediaStreamSource(this.mediaStream);
      this.workletNode = new AudioWorkletNode(this.audioContext, "gemini-audio-processor");
      this.workletNode.port.onmessage = (event) => {
        const float32Data = event.data;
        this.processAudio(float32Data);
      };
      this.input.connect(this.workletNode);
      this.workletNode.connect(this.audioContext.destination);
      const muteNode = this.audioContext.createGain();
      muteNode.gain.value = 0;
      this.workletNode.connect(muteNode);
      muteNode.connect(this.audioContext.destination);
      return true;
    } catch (error) {
      console.error("Error starting audio recording:", error);
      showMessage("No se pudo acceder al micr\xF3fono.");
      return false;
    }
  }
  stop() {
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => track.stop());
      this.mediaStream = null;
    }
    if (this.workletNode) {
      this.workletNode.disconnect();
      this.workletNode = null;
    }
    if (this.input) {
      this.input.disconnect();
      this.input = null;
    }
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
  }
  processAudio(inputData) {
    const pcmData = new Int16Array(inputData.length);
    for (let i = 0; i < inputData.length; i++) {
      const s = Math.max(-1, Math.min(1, inputData[i]));
      pcmData[i] = s < 0 ? s * 32768 : s * 32767;
    }
    const buffer = pcmData.buffer;
    const base64 = this.arrayBufferToBase64(buffer);
    this.onDataAvailable(base64);
  }
  arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }
};

// src/Infrastructure/Adapters/GoogleGeminiLiveAdapter/AudioPlayer.ts
var AudioPlayer = class {
  constructor(onStateChange) {
    this.isPlaying = false;
    this.startTime = 0;
    this.queue = [];
    this.onStateChange = onStateChange || (() => {
    });
    this.audioContext = new AudioContext({ latencyHint: "interactive" });
  }
  async resume() {
    if (this.audioContext.state === "suspended") {
      await this.audioContext.resume();
    }
  }
  addPcmData(base64Data) {
    const pcmData = this.base64ToArrayBuffer(base64Data);
    this.queue.push(pcmData);
    this.scheduleNextBuffer();
  }
  scheduleNextBuffer() {
    if (this.queue.length === 0)
      return;
    if (this.audioContext.state === "suspended") {
      this.audioContext.resume();
    }
    if (!this.isPlaying) {
      this.isPlaying = true;
      this.onStateChange(true);
      this.startTime = this.audioContext.currentTime + 0.1;
    }
    const nextBuffer = this.queue.shift();
    if (nextBuffer) {
      this.playBuffer(nextBuffer);
    }
  }
  playBuffer(arrayBuffer) {
    const int16Array = new Int16Array(arrayBuffer);
    const float32Array = new Float32Array(int16Array.length);
    for (let i = 0; i < int16Array.length; i++) {
      float32Array[i] = int16Array[i] / 32768;
    }
    const audioBuffer = this.audioContext.createBuffer(1, float32Array.length, 24e3);
    audioBuffer.copyToChannel(float32Array, 0, 0);
    const source = this.audioContext.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(this.audioContext.destination);
    const playTime = Math.max(this.audioContext.currentTime, this.startTime);
    source.start(playTime);
    this.startTime = playTime + audioBuffer.duration;
    source.onended = () => {
      if (this.queue.length > 0) {
        this.scheduleNextBuffer();
      } else {
        if (this.audioContext.currentTime >= this.startTime) {
          this.isPlaying = false;
          this.onStateChange(false);
        }
      }
    };
  }
  async close() {
    this.queue = [];
    this.isPlaying = false;
    this.onStateChange(false);
    if (this.audioContext.state !== "closed") {
      await this.audioContext.close();
    }
  }
  clearQueue() {
    this.queue = [];
    this.isPlaying = false;
    this.onStateChange(false);
  }
  base64ToArrayBuffer(base64) {
    const binaryString = window.atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
};

// src/Infrastructure/Adapters/GoogleGeminiLiveAdapter/GoogleGeminiLiveAdapter.ts
var GEMINI_LIVE_URL = "wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent";
var GoogleGeminiLiveAdapter = class {
  constructor(apiKey, onTextReceived, onScoreReceived, onUserTextReceived) {
    this.ws = null;
    this.isConnected = false;
    this.systemInstruction = "";
    this.isAiSpeaking = false;
    this.chunkCount = 0;
    this.apiKey = apiKey;
    this.onTextReceived = onTextReceived || (() => {
    });
    this.onScoreReceived = onScoreReceived || (() => {
    });
    this.onUserTextReceived = onUserTextReceived || (() => {
    });
    this.audioPlayer = new AudioPlayer((isPlaying) => {
      this.isAiSpeaking = isPlaying;
    });
    this.audioRecorder = new AudioRecorder((base64Audio) => {
      this.sendAudioChunk(base64Audio);
    });
  }
  async resumeAudio() {
    await this.audioPlayer.resume();
  }
  async connect(systemInstruction = "", enableScoreTracking = false, voice = "Aoede", temperature = 0.5, topP = 0.95) {
    this.systemInstruction = systemInstruction;
    if (!this.apiKey) {
      showMessage("Falta la API Key de Gemini");
      return false;
    }
    const url = `${GEMINI_LIVE_URL}?key=${this.apiKey}`;
    try {
      this.ws = new WebSocket(url);
    } catch (e) {
      console.error("Error creating WebSocket", e);
      showMessage("Error al crear la conexi\xF3n WebSocket");
      return false;
    }
    return new Promise((resolve) => {
      if (!this.ws)
        return resolve(false);
      this.ws.onopen = async () => {
        console.log("Gemini Live WS Connected");
        this.isConnected = true;
        this.sendSetupMessage(enableScoreTracking, voice, temperature, topP);
        const micStarted = await this.audioRecorder.start();
        if (!micStarted) {
          this.disconnect();
          resolve(false);
          return;
        }
        resolve(true);
      };
      this.ws.onmessage = async (event) => {
        await this.handleMessage(event);
      };
      this.ws.onerror = (error) => {
        console.error("Gemini Live WS Error:", error);
        showMessage("Error en la conexi\xF3n con Gemini Live");
        this.disconnect();
      };
      this.ws.onclose = () => {
        console.log("Gemini Live WS Closed");
        this.disconnect();
      };
    });
  }
  disconnect() {
    this.isConnected = false;
    this.audioRecorder.stop();
    this.audioPlayer.close();
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
  sendSetupMessage(enableScoreTracking, voice, temperature, topP) {
    if (!this.ws)
      return;
    const setupMsg = {
      setup: {
        model: "models/gemini-2.0-flash-exp",
        generation_config: {
          response_modalities: ["AUDIO"],
          speech_config: {
            voice_config: {
              prebuilt_voice_config: {
                voice_name: voice
              }
            }
          },
          temperature,
          top_p: topP
        }
      }
    };
    setupMsg.setup.output_audio_transcription = {};
    if (enableScoreTracking) {
      console.log("Enabling Score Tracking Tool in Setup");
      setupMsg.setup.tools = [
        {
          function_declarations: [
            {
              name: "report_score",
              description: "Report the score of the user's answer effectiveness.",
              parameters: {
                type: "OBJECT",
                properties: {
                  score: {
                    type: "INTEGER",
                    description: "The score of the answer from 0 to 10."
                  }
                },
                required: ["score"]
              }
            }
          ]
        }
      ];
    }
    if (this.systemInstruction) {
      let finalInstruction = this.systemInstruction;
      if (enableScoreTracking) {
        finalInstruction += `

IMPORTANT: You are configured to track the user's answer quality. When the user answers, you MUST evaluate it and call the "report_score" function with a score from 0 to 10.`;
      }
      setupMsg.setup.system_instruction = {
        parts: [
          { text: finalInstruction }
        ]
      };
    }
    console.log(`Gemini Live: Sending Setup with Temperature: ${temperature}, TopP: ${topP}, Voice: ${voice}`);
    console.log("Sending Setup Msg:", JSON.stringify(setupMsg, null, 2));
    this.ws.send(JSON.stringify(setupMsg));
  }
  sendContextUpdate(fileName, content) {
    if (!this.ws || !this.isConnected)
      return;
    const msg = {
      client_content: {
        turns: [{
          role: "user",
          parts: [{ text: `SYSTEM UPDATE: 
${content}` }]
        }],
        turn_complete: true
      }
    };
    console.log("Sending Context Update Msg:", JSON.stringify(msg, null, 2));
    this.ws.send(JSON.stringify(msg));
  }
  sendText(text) {
    if (!this.ws || !this.isConnected)
      return;
    const msg = {
      client_content: {
        turns: [{
          role: "user",
          parts: [{ text }]
        }],
        turn_complete: true
      }
    };
    console.log("Sending Text Message:", text);
    this.ws.send(JSON.stringify(msg));
  }
  sendAudioChunk(base64Audio) {
    if (!this.ws || !this.isConnected || this.isAiSpeaking)
      return;
    if (this.ws.readyState !== WebSocket.OPEN)
      return;
    const msg = {
      realtime_input: {
        media_chunks: [
          {
            mime_type: "audio/pcm",
            data: base64Audio
          }
        ]
      }
    };
    this.chunkCount++;
    if (this.chunkCount % 50 === 0) {
    }
    this.ws.send(JSON.stringify(msg));
  }
  async handleMessage(event) {
    var _a2;
    let data;
    try {
      if (event.data instanceof Blob) {
        data = JSON.parse(await event.data.text());
      } else {
        data = JSON.parse(event.data);
      }
    } catch (e) {
      console.error("Error parsing WS message", e);
      return;
    }
    if (data.setupComplete) {
      console.log("Gemini Live: Setup Complete");
      return;
    }
    if (data.error) {
      console.error("Gemini Live API Error:", data.error);
      showMessage(`Gemini Error: ${data.error.message || "Unknown error"}`);
      return;
    }
    const serverContent = data == null ? void 0 : data.serverContent;
    if (!serverContent) {
      console.log("No serverContent in message (and not setup/error)", data);
      return;
    }
    if (serverContent.outputTranscription && serverContent.outputTranscription.text) {
      this.onTextReceived(serverContent.outputTranscription.text);
    }
    const recognitionResult = serverContent.speechRecognitionResults || serverContent.recognitionResult;
    if (recognitionResult) {
      const transcript = recognitionResult.transcript || (recognitionResult.parts ? (_a2 = recognitionResult.parts[0]) == null ? void 0 : _a2.text : "");
      if (transcript) {
        console.log("Received User Transcription:", transcript);
        this.onUserTextReceived(transcript);
      }
    }
    const modelTurn = serverContent.modelTurn;
    if (!modelTurn || !modelTurn.parts) {
      if (serverContent.turnComplete) {
        console.log("Turn Complete");
      }
      return;
    }
    const parts = modelTurn.parts;
    if (parts && Array.isArray(parts)) {
      for (const part of parts) {
        if (part.inlineData && part.inlineData.mimeType.startsWith("audio/pcm")) {
          this.audioPlayer.addPcmData(part.inlineData.data);
        } else if (part.text) {
          console.log("Received Text Part:", part.text);
          this.onTextReceived(part.text);
        } else if (part.functionCall) {
          console.log("Gemini Live: Function Call detected", part.functionCall);
          if (part.functionCall.name === "report_score") {
            const args = part.functionCall.args;
            console.log("Gemini Live: report_score args:", args);
            let score = args == null ? void 0 : args.score;
            if (typeof score === "string") {
              score = parseInt(score, 10);
            }
            if (typeof score === "number" && !isNaN(score)) {
              console.log("Gemini Live: Emitting score event:", score);
              this.onScoreReceived(score);
            } else {
              console.warn("Gemini Live: Invalid score received:", args);
            }
          }
          const responseId = part.functionCall.id || "no-id";
          this.sendFunctionResponse(part.functionCall.name, responseId, { status: "ok" });
        } else if (part.executableCode) {
          console.log("Gemini Live: Executable Code detected", part.executableCode);
          const code = part.executableCode.code;
          if (code) {
            const match = code.match(/report_score\s*\(\s*(?:score\s*=\s*)?(\d+)\s*\)/);
            if (match && match[1]) {
              const score = parseInt(match[1], 10);
              console.log("Gemini Live: Parsed score from code:", score);
              if (!isNaN(score)) {
                this.onScoreReceived(score);
              }
            }
          }
        }
      }
    }
  }
  sendFunctionResponse(name, id, result) {
    if (!this.ws || !this.isConnected)
      return;
    const msg = {
      tool_response: {
        function_responses: [
          {
            name,
            id,
            response: { result }
          }
        ]
      }
    };
    this.ws.send(JSON.stringify(msg));
  }
};

// src/Infrastructure/Obsidian/Views/Chat/ChatView.ts
var import_core28 = __toESM(require_dist());

// src/Infrastructure/Services/SessionLogger.ts
var import_obsidian44 = require("obsidian");
var SessionLogger = class {
  constructor(app) {
    this.logFolderPath = "!!metadatos/Sesiones";
    this.app = app;
  }
  async ensureLogFile() {
    let folder = this.app.vault.getAbstractFileByPath(this.logFolderPath);
    if (!folder) {
      try {
        folder = await this.app.vault.createFolder(this.logFolderPath);
      } catch (e) {
        console.error("Error creating logging folder", e);
        return null;
      }
    }
    if (!(folder instanceof import_obsidian44.TFolder)) {
      console.error("Log path exists but is not a folder");
      return null;
    }
    const date = /* @__PURE__ */ new Date();
    const dateStr = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
    const filename = `${this.logFolderPath}/${dateStr}.md`;
    let file = this.app.vault.getAbstractFileByPath(filename);
    if (!file) {
      try {
        file = await this.app.vault.create(filename, "");
      } catch (e) {
        console.error("Error creating log file", e);
        return null;
      }
    }
    return file instanceof import_obsidian44.TFile ? file : null;
  }
  formatTime(date) {
    return `${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}`;
  }
  async appendLine(line) {
    try {
      const file = await this.ensureLogFile();
      if (file) {
        await this.app.vault.append(file, line + "\n");
      }
    } catch (e) {
      console.error("Failed to log session", e);
    }
  }
  async logStart(date) {
    await this.appendLine(`[${this.formatTime(date)}] Inicio sesi\xF3n`);
  }
  async logEnd(date, durationMinutes) {
    await this.appendLine(`[${this.formatTime(date)}] Fin sesi\xF3n. Duraci\xF3n: ${Math.round(durationMinutes)} min.`);
  }
  async logQuestion(question) {
    const date = /* @__PURE__ */ new Date();
    await this.appendLine(`[${this.formatTime(date)}] Pregunta: ${question}`);
  }
  async logScore(score) {
    const date = /* @__PURE__ */ new Date();
    await this.appendLine(`[${this.formatTime(date)}] Score: ${score}`);
  }
  async logTranscript(speaker, text) {
    const date = /* @__PURE__ */ new Date();
    await this.appendLine(`[${this.formatTime(date)}] ${speaker}: ${text}`);
  }
};

// src/Application/Services/HeaderEvaluationService.ts
var import_core24 = __toESM(require_dist());
var HeaderEvaluationService = class {
  constructor(llm, noteManager) {
    this.llm = llm;
    this.noteManager = noteManager;
  }
  async evaluateHeaders(notePath, roleEvaluationPrompt) {
    if (!roleEvaluationPrompt) {
      throw new Error("No evaluation prompt provided.");
    }
    const headings = await this.noteManager.getNoteHeadings(notePath);
    if (!headings || headings.length === 0) {
      return { processed: 0 };
    }
    const content = await this.noteManager.readNote(notePath);
    const lines = content.split("\n");
    let processedCount = 0;
    for (let i = 0; i < headings.length; i++) {
      const heading = headings[i];
      const startLine = heading.position.start.line;
      let endLine = lines.length;
      if (i < headings.length - 1) {
        endLine = headings[i + 1].position.start.line;
      }
      const sectionText = heading.heading + "\n" + lines.slice(startLine + 1, endLine).join("\n");
      const finalPrompt = `${roleEvaluationPrompt}
Analyze:
"${sectionText}"
RETURN JSON ONLY: { "difficulty": 1-3, "importance": 1-5 }`;
      try {
        const result = await this.llm.requestJson({ prompt: finalPrompt });
        if (result && typeof result.difficulty === "number" && typeof result.importance === "number") {
          const idMatch = lines[startLine].match(/\^([a-zA-Z0-9-]+)$/);
          let blockId = idMatch ? idMatch[1] : null;
          if (blockId) {
            await this.noteManager.updateBlockMetadata(notePath, blockId, {
              [import_core24.HeaderMetadataKeys.Difficulty]: result.difficulty,
              [import_core24.HeaderMetadataKeys.Importance]: result.importance
            });
            processedCount++;
          } else {
          }
        }
      } catch (e) {
        console.error("Error evaluating header", e);
      }
    }
    return { processed: processedCount };
  }
};

// src/Application/Services/RolesService.ts
var import_core25 = __toESM(require_dist());
var RolesService = class {
  constructor(repository) {
    this.repository = repository;
  }
  async loadRoles() {
    return await this.repository.loadRoles();
  }
};

// src/Infrastructure/Services/ContextService.ts
var import_obsidian45 = require("obsidian");
var ContextService = class {
  constructor(app) {
    this.app = app;
  }
  cleanContext(text) {
    return text.replace(/\s+\^[a-zA-Z0-9-]+$/gm, "");
  }
  async getSectionContent(file, headerName) {
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache || !cache.headings)
      return "";
    const targetHeading = cache.headings.find((h) => {
      const cleanHeading = h.heading.replace(/\s+\^[a-zA-Z0-9-]+$/, "");
      return cleanHeading === headerName;
    });
    if (!targetHeading)
      return "";
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const startLine = targetHeading.position.start.line;
    let endLine = lines.length;
    for (let i = cache.headings.indexOf(targetHeading) + 1; i < cache.headings.length; i++) {
      const h = cache.headings[i];
      if (h.level <= targetHeading.level) {
        endLine = h.position.start.line;
        break;
      }
    }
    return lines.slice(startLine, endLine).join("\n");
  }
  async getLinkedFileContent(path5, range) {
    const sourceFile = this.app.vault.getAbstractFileByPath(path5);
    if (!(sourceFile instanceof import_obsidian45.TFile))
      return "";
    const cache = this.app.metadataCache.getFileCache(sourceFile);
    if (!cache)
      return "";
    let linksToProcess = [];
    if (range) {
      if (cache.links) {
        linksToProcess = cache.links.filter(
          (l) => l.position.start.line >= range.start && l.position.start.line < range.end
        );
      }
    } else {
      if (cache.links)
        linksToProcess.push(...cache.links);
      if (cache.frontmatterLinks)
        linksToProcess.push(...cache.frontmatterLinks);
    }
    if (linksToProcess.length === 0)
      return "";
    let linkedContext = "";
    const processedFiles = /* @__PURE__ */ new Set();
    for (const link of linksToProcess) {
      const fullLinkPath = link.link;
      let linkPathPart = fullLinkPath;
      let headerName = void 0;
      const hashIndex = fullLinkPath.indexOf("#");
      const caretIndex = fullLinkPath.indexOf("^");
      if (hashIndex !== -1) {
        linkPathPart = fullLinkPath.substring(0, hashIndex);
        const endOfHeader = caretIndex > hashIndex ? caretIndex : fullLinkPath.length;
        headerName = fullLinkPath.substring(hashIndex + 1, endOfHeader);
      } else if (caretIndex !== -1) {
        linkPathPart = fullLinkPath.substring(0, caretIndex);
      }
      const linkFile = this.app.metadataCache.getFirstLinkpathDest(linkPathPart, sourceFile.path);
      if (linkFile instanceof import_obsidian45.TFile && linkFile.extension === "md") {
        const uniqueKey = linkFile.path + (headerName ? `:${headerName}` : "");
        if (!processedFiles.has(uniqueKey)) {
          processedFiles.add(uniqueKey);
          try {
            let content = "";
            let displayTitle = linkFile.basename;
            if (headerName) {
              content = await this.getSectionContent(linkFile, headerName);
              displayTitle += ` > ${headerName}`;
            } else {
              content = await this.app.vault.read(linkFile);
            }
            if (content) {
              linkedContext += `

--- Nota Vinculada: [[${displayTitle}]] ---
${this.cleanContext(content)}`;
            }
          } catch (e) {
            console.error(`Failed to read linked file: ${linkFile.path}`, e);
          }
        }
      } else {
        console.warn(`ContextManager: Could not resolve link: ${fullLinkPath}`);
      }
    }
    return linkedContext;
  }
  async getVocabularyContent(items) {
    if (items.size === 0)
      return "";
    let vocabContext = "";
    const activeFile = this.app.workspace.getActiveFile();
    const resolvedPath = (activeFile == null ? void 0 : activeFile.path) || "";
    for (const item of items) {
      const cleanItem = item.replace(/^\[\[|\]\]$/g, "");
      let file = this.app.metadataCache.getFirstLinkpathDest(cleanItem, resolvedPath);
      if (!file) {
        file = this.app.metadataCache.getFirstLinkpathDest(cleanItem, "");
      }
      if (!file) {
        file = this.app.vault.getFiles().find((f) => f.basename === cleanItem) || null;
      }
      if (file && file instanceof import_obsidian45.TFile && file.extension === "md") {
        try {
          const content = await this.app.vault.read(file);
          vocabContext += `
-- VOCABULARIO que debes utilizar en la pregunta: ---- 
${cleanItem}
${content}
`;
        } catch (e) {
          console.warn(`Failed to read vocabulary note: ${cleanItem}`, e);
        }
      } else {
        console.warn(`ContextService: Could not find note for vocabulary item: "${item}"`);
      }
    }
    return vocabContext;
  }
};

// src/Application/Services/QuizService.ts
var import_core26 = __toESM(require_dist());
var import_core27 = __toESM(require_dist());
var QuizService = class {
  constructor(noteManager, contextProvider, metadataService) {
    this.noteManager = noteManager;
    this.contextProvider = contextProvider;
    this.metadataService = metadataService;
    this.queue = [];
    this.currentIndex = -1;
    this.onlyTitlesWithoutSubtitles = true;
    this.selectedStarLevel = "0";
  }
  async recordBlockScore(item, score) {
    if (!item || !item.blockId)
      return null;
    const activeFile = this.noteManager.getActiveNote();
    if (!activeFile)
      return null;
    const fileMetadata = await this.metadataService.getFileMetadata(activeFile.path);
    const currentMeta = fileMetadata[item.blockId];
    const oldScore = (currentMeta == null ? void 0 : currentMeta.score) || 0;
    const oldAttempts = (currentMeta == null ? void 0 : currentMeta.attempts) || 0;
    let finalScore = score;
    if (oldScore > 0) {
      finalScore = (oldScore + score) / 2;
      finalScore = Math.round(finalScore * 10) / 10;
    }
    await this.metadataService.updateBlockMetadata(activeFile.path, item.blockId, {
      [import_core27.HeaderMetadataKeys.Score]: finalScore,
      [import_core27.HeaderMetadataKeys.Attempts]: oldAttempts + 1
    });
    return finalScore;
  }
  async generateQuestionPrompt() {
    const item = this.getCurrentItem();
    if (!item)
      return null;
    const activeFile = this.noteManager.getActiveNote();
    if (!activeFile)
      return null;
    let sectionLinkedContent = "";
    try {
      sectionLinkedContent = await this.contextProvider.getLinkedFileContent(activeFile.path, item.range);
    } catch (e) {
      console.error("Error fetching linked content", e);
    }
    return `Examina al usuario sobre el siguiente contenido:

${item.text}

${sectionLinkedContent ? `--- Temas ---
${sectionLinkedContent}` : ""}`;
  }
  async buildQuizQueue() {
    const activeFile = this.noteManager.getActiveNote();
    if (!activeFile || activeFile.extension !== "md") {
      showMessage("Open a markdown file to start quiz.");
      return false;
    }
    const content = await this.noteManager.getActiveNoteContent();
    if (!content)
      return false;
    const lines = content.split("\n");
    const metadata = await this.noteManager.getNoteMetadata(activeFile.path);
    const queue = [];
    const selectedLevelStr = this.selectedStarLevel;
    const isNoFilter = selectedLevelStr === "0";
    const requiredLevel = parseInt(selectedLevelStr) || 1;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const headerMatch = line.match(/^(#{1,6})\s+(.*)/);
      if (headerMatch) {
        const level = headerMatch[1].length;
        const headingText = headerMatch[2].trim();
        const idMatch = line.match(/\^([a-zA-Z0-9-]+)$/);
        const blockId = idMatch ? idMatch[1] : null;
        let shouldInclude = false;
        if (isNoFilter) {
          if (level === 1 || level === 2) {
            shouldInclude = true;
          }
        } else {
          if (blockId && metadata[blockId]) {
            const importance = metadata[blockId].importance;
            if (typeof importance === "number" && (0, import_core26.normalizeImportance)(importance) >= requiredLevel) {
              shouldInclude = true;
            }
          }
        }
        if (shouldInclude) {
          let hasChildren = false;
          let endLine = lines.length;
          for (let j = i + 1; j < lines.length; j++) {
            const nextHeaderMatch = lines[j].match(/^(#{1,6})\s+/);
            if (nextHeaderMatch) {
              const nextHeaderLevel = nextHeaderMatch[1].length;
              if (nextHeaderLevel > level) {
                hasChildren = true;
              }
              endLine = j;
              break;
            }
          }
          if (this.onlyTitlesWithoutSubtitles && hasChildren) {
            continue;
          }
          const sectionContent = lines.slice(i, endLine).join("\n");
          queue.push({
            heading: headingText.replace(/\^([a-zA-Z0-9-]+)$/, "").trim(),
            blockId: blockId ? blockId : "",
            // might be empty if no filter and no ID
            text: sectionContent,
            range: { start: i, end: endLine }
          });
        }
      }
    }
    this.queue = queue;
    this.currentIndex = this.queue.length > 0 ? 0 : -1;
    if (this.queue.length === 0) {
      showMessage("No headers found. Falling back to whole file.");
      queue.push({
        heading: activeFile.basename,
        blockId: "__FILE__",
        text: content,
        range: { start: 0, end: lines.length }
      });
      this.queue = queue;
    }
    if (this.queue.length > 0 && this.currentIndex === -1) {
      this.currentIndex = 0;
    }
    if (this.queue.length === 0) {
      if (isNoFilter) {
        showMessage(`No H1 or H2 headers found.`);
      } else {
        showMessage(`No headers found with Importance >= ${requiredLevel}`);
      }
      return false;
    }
    showMessage(`Quiz Queue: ${this.queue.length} items ready.`);
    return true;
  }
  getCurrentItem() {
    return this.queue[this.currentIndex];
  }
  hasNext() {
    return this.currentIndex < this.queue.length;
  }
  next() {
    if (this.hasNext()) {
      this.currentIndex++;
    }
  }
};

// src/Infrastructure/Obsidian/Views/Chat/Components/RolesComponent.ts
var import_obsidian46 = require("obsidian");
var RolesComponent = class {
  constructor(container) {
    this.container = container;
    this.voiceDropdownRef = null;
    this.localVoiceDropdownRef = null;
    // New ref
    this.tempSliderRef = null;
    this.tempValLabelRef = null;
    this.topPSliderRef = null;
    this.topPValLabelRef = null;
  }
  render(props) {
    const primaryControls = this.container.createDiv();
    primaryControls.style.marginBottom = "20px";
    primaryControls.style.display = "flex";
    primaryControls.style.flexDirection = "column";
    primaryControls.style.gap = "15px";
    const roleRow = primaryControls.createDiv();
    roleRow.style.display = "flex";
    roleRow.style.alignItems = "center";
    roleRow.style.gap = "10px";
    roleRow.createSpan({ text: "Role:" });
    if (props.roles.length === 0) {
      roleRow.createSpan({ text: "(No roles found in folder)", cls: "gemini-muted-text" });
    } else {
      const dropdown = new import_obsidian46.DropdownComponent(roleRow);
      props.roles.forEach((role) => dropdown.addOption(role.prompt, role.name));
      dropdown.setValue(props.selectedRolePrompt);
      dropdown.onChange((val) => props.onRoleChange(val));
    }
    const liveModeContainer = primaryControls.createDiv();
    liveModeContainer.style.display = "flex";
    liveModeContainer.style.flexDirection = "column";
    liveModeContainer.style.gap = "10px";
    const aiModeRow = liveModeContainer.createDiv();
    aiModeRow.style.display = "flex";
    aiModeRow.style.alignItems = "center";
    aiModeRow.style.gap = "10px";
    aiModeRow.createSpan({ text: "IA:" });
    const aiDropdown = new import_obsidian46.DropdownComponent(aiModeRow);
    aiDropdown.addOption("gemini_live_voice_text", "Voz live y texto");
    aiDropdown.addOption("gemini_live_voice_only", "Voz live");
    aiDropdown.addOption("local_voice_text", "Voz y texto");
    aiDropdown.addOption("local_voice_only", "Voz");
    aiDropdown.addOption("text_only", "Solo Texto");
    aiDropdown.setValue(props.liveMode || "gemini_live_voice_text");
    aiDropdown.onChange((val) => props.onLiveModeChange(val));
    const userModeRow = liveModeContainer.createDiv();
    userModeRow.style.display = "flex";
    userModeRow.style.alignItems = "center";
    userModeRow.style.gap = "10px";
    userModeRow.createSpan({ text: "Usuario:" });
    const userDropdown = new import_obsidian46.DropdownComponent(userModeRow);
    userDropdown.addOption("voice_text", "Voz y Texto");
    userDropdown.addOption("text_only", "Solo Texto");
    userDropdown.addOption("voice_only", "Solo Voz");
    userDropdown.setValue(props.liveUserMode || "voice_text");
    userDropdown.onChange((val) => props.onLiveUserModeChange(val));
    if (props.liveMode.startsWith("local_voice")) {
      const localVoiceRow = liveModeContainer.createDiv();
      localVoiceRow.style.display = "flex";
      localVoiceRow.style.alignItems = "center";
      localVoiceRow.style.gap = "10px";
      localVoiceRow.createSpan({ text: "Voz Local:" });
      this.localVoiceDropdownRef = new import_obsidian46.DropdownComponent(localVoiceRow);
      const loadVoices = () => {
        var _a2;
        const voices = window.speechSynthesis.getVoices();
        if (voices.length > 0 && this.localVoiceDropdownRef) {
          voices.sort((a, b) => a.name.localeCompare(b.name));
          voices.forEach((voice) => {
            this.localVoiceDropdownRef.addOption(voice.voiceURI, `${voice.name} (${voice.lang})`);
          });
          if (props.selectedLocalVoice) {
            this.localVoiceDropdownRef.setValue(props.selectedLocalVoice);
          } else if (voices.length > 0) {
            this.localVoiceDropdownRef.setValue(voices[0].voiceURI);
            props.onLocalVoiceChange(voices[0].voiceURI);
          }
        } else if (voices.length === 0) {
          (_a2 = this.localVoiceDropdownRef) == null ? void 0 : _a2.addOption("", "Cargando voces...");
        }
      };
      loadVoices();
      if (window.speechSynthesis.onvoiceschanged !== void 0) {
        window.speechSynthesis.onvoiceschanged = () => {
          var _a2;
          if (((_a2 = this.localVoiceDropdownRef) == null ? void 0 : _a2.selectEl.options.length) && this.localVoiceDropdownRef.selectEl.options[0].text === "Cargando voces...") {
            this.localVoiceDropdownRef.selectEl.innerHTML = "";
            loadVoices();
          }
        };
      }
      this.localVoiceDropdownRef.onChange((val) => props.onLocalVoiceChange(val));
    }
    const configRow = primaryControls.createDiv();
    configRow.style.display = "flex";
    configRow.style.alignItems = "center";
    configRow.style.gap = "15px";
    configRow.style.flexWrap = "wrap";
    if (props.liveMode.startsWith("gemini_live")) {
      configRow.createSpan({ text: "Voz (Gemini):" });
      this.voiceDropdownRef = new import_obsidian46.DropdownComponent(configRow);
      ["Puck", "Charon", "Kore", "Fenrir", "Aoede"].forEach((voice) => {
        this.voiceDropdownRef.addOption(voice, voice);
      });
      this.voiceDropdownRef.setValue(props.selectedVoice);
      this.voiceDropdownRef.onChange((val) => props.onVoiceChange(val));
    }
    const tempContainer = configRow.createDiv();
    tempContainer.style.display = "flex";
    tempContainer.style.alignItems = "center";
    tempContainer.style.gap = "5px";
    tempContainer.createSpan({ text: "Temp:" });
    this.tempValLabelRef = tempContainer.createSpan({ text: props.selectedTemperature.toFixed(1) });
    this.tempSliderRef = document.createElement("input");
    this.tempSliderRef.type = "range";
    this.tempSliderRef.min = "0";
    this.tempSliderRef.max = "2";
    this.tempSliderRef.step = "0.1";
    this.tempSliderRef.value = props.selectedTemperature.toString();
    this.tempSliderRef.style.width = "60px";
    this.tempSliderRef.addEventListener("change", (e) => {
      const val = parseFloat(e.target.value);
      props.onTemperatureChange(val);
      if (this.tempValLabelRef)
        this.tempValLabelRef.textContent = val.toFixed(1);
    });
    this.tempSliderRef.addEventListener("input", (e) => {
      if (this.tempValLabelRef)
        this.tempValLabelRef.textContent = parseFloat(e.target.value).toFixed(1);
    });
    tempContainer.appendChild(this.tempSliderRef);
    const topPContainer = configRow.createDiv();
    topPContainer.style.display = "flex";
    topPContainer.style.alignItems = "center";
    topPContainer.style.gap = "5px";
    topPContainer.createSpan({ text: "TopP:" });
    this.topPValLabelRef = topPContainer.createSpan({ text: props.selectedTopP.toFixed(2) });
    this.topPSliderRef = document.createElement("input");
    this.topPSliderRef.type = "range";
    this.topPSliderRef.min = "0";
    this.topPSliderRef.max = "1";
    this.topPSliderRef.step = "0.05";
    this.topPSliderRef.value = props.selectedTopP.toString();
    this.topPSliderRef.style.width = "60px";
    this.topPSliderRef.addEventListener("change", (e) => {
      const val = parseFloat(e.target.value);
      props.onTopPChange(val);
      if (this.topPValLabelRef)
        this.topPValLabelRef.textContent = val.toFixed(2);
    });
    this.topPSliderRef.addEventListener("input", (e) => {
      if (this.topPValLabelRef)
        this.topPValLabelRef.textContent = parseFloat(e.target.value).toFixed(2);
    });
    topPContainer.appendChild(this.topPSliderRef);
    const details = this.container.createEl("details");
    details.style.marginBottom = "20px";
    details.style.border = "1px solid var(--background-modifier-border)";
    details.style.borderRadius = "4px";
    details.style.overflow = "hidden";
    const summary = details.createEl("summary", { text: "Avanzada" });
    summary.style.padding = "10px";
    summary.style.cursor = "pointer";
    summary.style.backgroundColor = "var(--background-secondary)";
    summary.style.fontWeight = "bold";
    const content = details.createDiv();
    content.style.padding = "15px";
    content.style.display = "flex";
    content.style.flexDirection = "column";
    content.style.gap = "15px";
    if (props.roles.length > 0) {
      const buttonContainer = content.createDiv();
      buttonContainer.style.display = "flex";
      buttonContainer.style.gap = "10px";
      new import_obsidian46.ButtonComponent(buttonContainer).setButtonText("Eval Headers").setTooltip("Batchevaluation of headers").onClick(() => props.onEvalHeaders());
      new import_obsidian46.ButtonComponent(buttonContainer).setButtonText("Generate Header Metadata").setTooltip("Assign Block IDs and create metadata structure for headers").onClick(() => props.onGenerateMetadata());
    }
  }
};

// src/Infrastructure/Obsidian/Views/Chat/Components/QuizComponent.ts
var import_obsidian48 = require("obsidian");

// src/Infrastructure/Obsidian/Views/Chat/Components/SessionControlsComponent.ts
var import_obsidian47 = require("obsidian");
var SessionControlsComponent = class {
  constructor(sessionBtnContainer, onStartStop) {
    this.sessionBtnContainer = sessionBtnContainer;
    this.onStartStop = onStartStop;
    this.sessionBtn = null;
    this.render();
  }
  render() {
    this.sessionBtn = new import_obsidian47.ButtonComponent(this.sessionBtnContainer).setButtonText("Preguntar").setCta().onClick(() => this.onStartStop());
  }
  updateStatus(isActive, text = "", color = "") {
    if (this.sessionBtn) {
      if (isActive) {
        this.sessionBtn.setButtonText("Stop Session");
        this.sessionBtn.removeCta();
        this.sessionBtn.setWarning();
        this.sessionBtn.buttonEl.style.fontSize = "";
        this.sessionBtn.buttonEl.style.padding = "";
      } else {
        this.sessionBtn.setButtonText("Preguntar");
        this.sessionBtn.buttonEl.removeClass("mod-warning");
        this.sessionBtn.setCta();
        this.sessionBtn.buttonEl.style.fontSize = "";
        this.sessionBtn.buttonEl.style.padding = "";
      }
    }
  }
};

// src/Infrastructure/Obsidian/Views/Chat/Components/QuizComponent.ts
var QuizComponent = class {
  constructor(container) {
    this.container = container;
    this.sessionControls = null;
    this.quizListContainer = null;
    this.quizStatusEl = null;
  }
  render(props) {
    const quizContainer = this.container.createDiv({ cls: "gemini-quiz-container" });
    quizContainer.style.marginBottom = "20px";
    quizContainer.style.padding = "10px";
    quizContainer.style.border = "1px solid var(--background-modifier-border)";
    quizContainer.style.borderRadius = "4px";
    quizContainer.style.display = "flex";
    quizContainer.style.flexDirection = "column";
    quizContainer.style.height = "100%";
    quizContainer.createEl("h4", { text: "Quiz Mode" });
    quizContainer.querySelector("h4").style.marginTop = "0";
    const quizControls = quizContainer.createDiv();
    quizControls.style.display = "flex";
    quizControls.style.gap = "10px";
    quizControls.style.alignItems = "center";
    quizControls.style.flexWrap = "wrap";
    quizControls.style.marginBottom = "15px";
    quizControls.createSpan({ text: "Relevancia:" });
    const importanceDropdown = new import_obsidian48.DropdownComponent(quizControls);
    importanceDropdown.addOption("0", "(Sin filtro)");
    ["1", "2", "3", "4", "5"].forEach((level) => importanceDropdown.addOption(level, `\u2B50`.repeat(Number(level))));
    importanceDropdown.setValue(props.quizService.selectedStarLevel);
    importanceDropdown.onChange((val) => props.onStarLevelChange(val));
    const filterContainer = quizControls.createDiv();
    filterContainer.style.display = "flex";
    filterContainer.style.alignItems = "center";
    filterContainer.style.gap = "5px";
    const filterCheckbox = document.createElement("input");
    filterCheckbox.type = "checkbox";
    filterCheckbox.checked = props.quizService.onlyTitlesWithoutSubtitles;
    filterCheckbox.id = "only-titles-no-subtitles";
    filterCheckbox.addEventListener("change", (e) => {
      props.onFilterChange(e.target.checked);
    });
    const filterLabel = document.createElement("label");
    filterLabel.htmlFor = "only-titles-no-subtitles";
    filterLabel.innerText = "Solo t\xEDtulos sin subt\xEDtulos";
    filterContainer.appendChild(filterCheckbox);
    filterContainer.appendChild(filterLabel);
    const refreshBtn = new import_obsidian48.ButtonComponent(quizControls);
    refreshBtn.setIcon("refresh-cw");
    refreshBtn.setTooltip("Refrescar Datos");
    refreshBtn.onClick(() => props.onRefresh());
    refreshBtn.buttonEl.style.marginLeft = "auto";
    this.quizListContainer = quizContainer.createDiv({ cls: "gemini-quiz-list" });
    this.quizListContainer.style.marginTop = "10px";
    this.quizListContainer.style.flex = "1";
    this.quizListContainer.style.minHeight = "200px";
    this.quizListContainer.style.overflowY = "auto";
    this.quizListContainer.style.border = "1px solid var(--background-modifier-border)";
    this.quizListContainer.style.borderRadius = "4px";
    this.quizListContainer.style.padding = "5px";
    this.refreshList(props.quizService, (i) => {
      if (props.onTopicSelect) {
        props.onTopicSelect(i);
      }
    });
    this.quizStatusEl = quizContainer.createDiv({ cls: "gemini-quiz-status" });
    this.quizStatusEl.style.marginTop = "15px";
    this.quizStatusEl.style.padding = "10px";
    this.quizStatusEl.style.backgroundColor = "var(--background-secondary)";
    this.quizStatusEl.style.borderRadius = "4px";
    this.quizStatusEl.style.fontSize = "1.1em";
    this.quizStatusEl.style.fontWeight = "bold";
    this.quizStatusEl.style.color = "var(--text-normal)";
    this.quizStatusEl.style.borderLeft = "4px solid var(--text-accent)";
    this.setStatusText("Selecciona un tema para comenzar.");
    const controlsContainer = quizContainer.createDiv();
    controlsContainer.style.marginTop = "auto";
    controlsContainer.style.paddingTop = "15px";
    controlsContainer.style.display = "flex";
    controlsContainer.style.justifyContent = "center";
    this.sessionControls = new SessionControlsComponent(
      controlsContainer,
      props.onAskNext
      // We use the AskNext action which handles session start logic
    );
  }
  setStatusText(text) {
    if (this.quizStatusEl) {
      this.quizStatusEl.textContent = text;
    }
  }
  updateSessionStatus(isActive, text, color) {
    var _a2;
    (_a2 = this.sessionControls) == null ? void 0 : _a2.updateStatus(isActive, text, color);
  }
  refreshList(quizService, onSelect) {
    if (!this.quizListContainer)
      return;
    this.quizListContainer.empty();
    if (quizService.queue.length === 0) {
      const emptyEl = this.quizListContainer.createDiv();
      emptyEl.innerText = "No topics found.";
      emptyEl.style.color = "var(--text-muted)";
      emptyEl.style.textAlign = "center";
      emptyEl.style.padding = "20px";
      return;
    }
    this.quizListContainer.style.display = "block";
    quizService.queue.forEach((item, index) => {
      const itemEl = this.quizListContainer.createDiv({ cls: "gemini-quiz-item" });
      itemEl.style.padding = "8px";
      itemEl.style.cursor = "pointer";
      itemEl.style.borderBottom = "1px solid var(--background-modifier-border)";
      itemEl.style.display = "flex";
      itemEl.style.justifyContent = "space-between";
      itemEl.style.alignItems = "center";
      itemEl.style.fontSize = "0.9em";
      if (index === quizService.currentIndex) {
        itemEl.style.backgroundColor = "var(--interactive-accent)";
        itemEl.style.color = "var(--text-on-accent)";
      } else {
        itemEl.addEventListener("mouseenter", () => {
          itemEl.style.backgroundColor = "var(--background-modifier-hover)";
        });
        itemEl.addEventListener("mouseleave", () => {
          itemEl.style.backgroundColor = "transparent";
        });
      }
      const textEl = itemEl.createSpan({ text: `${index + 1}. ${item.heading}` });
      textEl.style.overflow = "hidden";
      textEl.style.textOverflow = "ellipsis";
      textEl.style.whiteSpace = "nowrap";
      textEl.style.flex = "1";
      itemEl.addEventListener("click", () => {
        if (onSelect)
          onSelect(index);
      });
    });
  }
};

// src/Infrastructure/Obsidian/Views/Chat/Components/TranscriptComponent.ts
var import_obsidian49 = require("obsidian");
var TranscriptComponent = class {
  constructor(container, app, component) {
    this.fullTranscript = "";
    this.currentAiMessageEl = null;
    this.currentAiMessageText = "";
    this.app = app;
    this.component = component;
    this.transcriptContainer = container.createDiv({ cls: "gemini-live-transcript" });
    this.transcriptContainer.style.height = "300px";
    this.transcriptContainer.style.overflowY = "auto";
    this.transcriptContainer.style.border = "1px solid var(--background-modifier-border)";
    this.transcriptContainer.style.padding = "10px";
    this.transcriptContainer.style.marginBottom = "20px";
    this.transcriptContainer.style.borderRadius = "4px";
    this.transcriptContainer.style.backgroundColor = "var(--background-primary)";
    this.renderPlaceholder();
  }
  renderPlaceholder() {
    const placeholder = this.transcriptContainer.createEl("span", { text: "Transcription will appear here...", cls: "transcript-placeholder" });
    placeholder.style.color = "var(--text-muted)";
    placeholder.style.fontStyle = "italic";
  }
  clear() {
    this.transcriptContainer.empty();
    this.fullTranscript = "";
    this.currentAiMessageEl = null;
    this.currentAiMessageText = "";
    this.renderPlaceholder();
  }
  startSession() {
    const placeholder = this.transcriptContainer.querySelector(".transcript-placeholder");
    if (placeholder)
      placeholder.remove();
  }
  async appendAiText(text) {
    if (!this.currentAiMessageEl) {
      this.currentAiMessageEl = this.transcriptContainer.createDiv({ cls: "gemini-ai-message" });
      this.currentAiMessageEl.style.marginBottom = "10px";
      this.currentAiMessageText = "";
    }
    this.currentAiMessageText += text;
    this.fullTranscript += text;
    this.currentAiMessageEl.empty();
    await import_obsidian49.MarkdownRenderer.render(
      this.app,
      this.currentAiMessageText,
      this.currentAiMessageEl,
      "",
      this.component
    );
    this.autoScroll();
  }
  finalizeMessage() {
    this.currentAiMessageEl = null;
    this.currentAiMessageText = "";
  }
  appendUserText(text) {
    this.finalizeMessage();
    const userEl = this.transcriptContainer.createDiv({
      text: `\u{1F464} ${text}`,
      cls: "gemini-user-transcript"
    });
    userEl.style.color = "var(--text-accent)";
    userEl.style.fontStyle = "italic";
    userEl.style.marginTop = "10px";
    userEl.style.marginBottom = "10px";
    userEl.style.textAlign = "right";
    this.autoScroll();
    this.fullTranscript += `
[User]: ${text}
`;
  }
  appendScore(score) {
    this.finalizeMessage();
    const scoreEl = this.transcriptContainer.createEl("div", {
      text: `\u{1F31F} Nota: ${score}`,
      cls: "gemini-score-flag"
    });
    scoreEl.style.color = "gold";
    scoreEl.style.backgroundColor = "#333";
    scoreEl.style.fontSize = "1.5em";
    scoreEl.style.fontWeight = "bold";
    scoreEl.style.marginTop = "15px";
    scoreEl.style.marginBottom = "15px";
    scoreEl.style.border = "2px solid gold";
    scoreEl.style.padding = "10px";
    scoreEl.style.textAlign = "center";
    scoreEl.style.borderRadius = "8px";
    scoreEl.scrollIntoView({ behavior: "smooth", block: "center" });
    this.fullTranscript += `

[SCORE: ${score}]

`;
  }
  appendTopic(heading) {
    this.finalizeMessage();
    const topicEl = this.transcriptContainer.createEl("div", {
      text: `\u{1F4DD} PREGUNTA: ${heading}`,
      cls: "gemini-quiz-topic"
    });
    topicEl.style.backgroundColor = "var(--interactive-accent)";
    topicEl.style.color = "var(--text-on-accent)";
    topicEl.style.padding = "10px";
    topicEl.style.borderRadius = "8px";
    topicEl.style.marginTop = "15px";
    topicEl.style.marginBottom = "15px";
    topicEl.style.textAlign = "center";
    topicEl.style.fontWeight = "bold";
    topicEl.scrollIntoView({ behavior: "smooth", block: "center" });
    this.fullTranscript += `

[PREGUNTA: ${heading}]

`;
  }
  autoScroll() {
    this.transcriptContainer.scrollTop = this.transcriptContainer.scrollHeight;
  }
  getHtml() {
    return this.transcriptContainer.innerHTML;
  }
  setHtml(html) {
    this.transcriptContainer.innerHTML = html;
    this.autoScroll();
    this.finalizeMessage();
  }
  getFullTranscript() {
    return this.fullTranscript;
  }
};

// src/Infrastructure/Obsidian/Views/Chat/Components/VocabularyComponent.ts
var VocabularyComponent = class {
  constructor(container) {
    this.listContainer = null;
    this.container = container;
  }
  render(vocabularyList, selectedItems, onToggle) {
    if (this.listContainer) {
      this.listContainer.remove();
    }
    if (!vocabularyList || vocabularyList.length === 0) {
      return;
    }
    this.listContainer = this.container.createDiv({ cls: "gemini-vocabulary-container" });
    this.listContainer.style.marginTop = "15px";
    this.listContainer.style.padding = "10px";
    this.listContainer.style.border = "1px solid var(--background-modifier-border)";
    this.listContainer.style.borderRadius = "4px";
    this.listContainer.style.backgroundColor = "var(--background-secondary)";
    const header = this.listContainer.createEl("h4", { text: "Vocabulary Context" });
    header.style.margin = "0 0 10px 0";
    header.style.fontSize = "0.9em";
    header.style.color = "var(--text-muted)";
    const sub = this.listContainer.createDiv({ text: "Click to add note content to prompt context." });
    sub.style.fontSize = "0.8em";
    sub.style.marginBottom = "10px";
    sub.style.color = "var(--text-faint)";
    const list = this.listContainer.createDiv({ cls: "gemini-vocabulary-list" });
    list.style.display = "flex";
    list.style.flexWrap = "wrap";
    list.style.gap = "8px";
    vocabularyList.forEach((word) => {
      const isSelected = selectedItems.has(word);
      const tag = list.createSpan({ text: word });
      tag.style.padding = "4px 8px";
      tag.style.borderRadius = "12px";
      tag.style.fontSize = "0.85em";
      tag.style.cursor = "pointer";
      tag.style.transition = "all 0.2s ease";
      tag.style.userSelect = "none";
      if (isSelected) {
        tag.style.backgroundColor = "var(--interactive-accent)";
        tag.style.color = "var(--text-on-accent)";
        tag.style.border = "1px solid var(--interactive-accent)";
      } else {
        tag.style.backgroundColor = "var(--background-primary)";
        tag.style.color = "var(--text-normal)";
        tag.style.border = "1px solid var(--background-modifier-border)";
      }
      tag.addEventListener("click", () => {
        onToggle(word);
      });
    });
  }
};

// src/Infrastructure/Obsidian/Views/Chat/Components/ChatInputComponent.ts
var import_obsidian51 = require("obsidian");

// src/Infrastructure/Obsidian/Utils/AudioRecorder.ts
var AudioRecorder2 = class {
  constructor() {
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.stream = null;
  }
  async start() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(this.stream);
      this.audioChunks = [];
      this.mediaRecorder.ondataavailable = (event) => {
        this.audioChunks.push(event.data);
      };
      this.mediaRecorder.start();
      return true;
    } catch (error) {
      console.error("AudioRecorder: Error starting recording:", error);
      showMessage("Error accessing microphone.");
      return false;
    }
  }
  async stop() {
    if (!this.mediaRecorder || this.mediaRecorder.state === "inactive")
      return null;
    return new Promise((resolve) => {
      if (this.mediaRecorder) {
        this.mediaRecorder.onstop = () => {
          const audioBlob = new Blob(this.audioChunks, { type: "audio/webm" });
          this.cleanup();
          resolve(audioBlob);
        };
        this.mediaRecorder.stop();
      }
    });
  }
  cleanup() {
    if (this.stream) {
      this.stream.getTracks().forEach((track) => track.stop());
      this.stream = null;
    }
    this.mediaRecorder = null;
    this.audioChunks = [];
  }
  isRecording() {
    var _a2;
    return ((_a2 = this.mediaRecorder) == null ? void 0 : _a2.state) === "recording";
  }
};

// src/Infrastructure/Adapters/GeminiTranscriptionAdapter.ts
var import_obsidian50 = require("obsidian");
var GeminiTranscriptionAdapter = class {
  constructor(apiKey) {
    this.modelName = "gemini-2.0-flash-exp";
    this.apiKey = apiKey;
  }
  async transcribe(audioBlob) {
    var _a2, _b, _c, _d, _e, _f;
    if (!this.apiKey) {
      throw new Error("API Key is missing for GeminiTranscriptionAdapter");
    }
    const base64Data = await this.blobToBase64(audioBlob);
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.modelName}:generateContent?key=${this.apiKey}`;
    try {
      const response = await (0, import_obsidian50.requestUrl)({
        url,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [{
            parts: [
              { text: "Transcribe the following audio exactly as spoken. Output ONLY the transcription, no extra text." },
              { inline_data: { mime_type: "audio/webm", data: base64Data } }
            ]
          }]
        }),
        throw: false
      });
      if (response.status === 200) {
        const data = response.json;
        const transcription = (_f = (_e = (_d = (_c = (_b = (_a2 = data.candidates) == null ? void 0 : _a2[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) == null ? void 0 : _f.trim();
        if (transcription) {
          return transcription;
        } else {
          throw new Error("No transcription found in Gemini response.");
        }
      } else {
        throw new Error(`Gemini API Error: ${response.status} - ${response.text}`);
      }
    } catch (error) {
      console.error("GeminiTranscriptionAdapter Error:", error);
      throw error;
    }
  }
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(blob);
      reader.onloadend = () => {
        const result = reader.result;
        if (result) {
          resolve(result.split(",")[1]);
        } else {
          reject(new Error("Failed to convert Blob to Base64"));
        }
      };
      reader.onerror = (error) => reject(error);
    });
  }
};

// src/Infrastructure/Obsidian/Views/Chat/Components/ChatInputComponent.ts
var ChatInputComponent = class {
  constructor(container, apiKey, onSend) {
    this.inputEl = null;
    this.micButton = null;
    this.container = container;
    this.apiKey = apiKey;
    this.onSend = onSend;
    this.audioRecorder = new AudioRecorder2();
    this.transcriptionAdapter = new GeminiTranscriptionAdapter(apiKey);
  }
  render(isEnabled, userMode = "voice_text") {
    this.container.empty();
    const wrapper = this.container.createDiv();
    wrapper.style.display = "flex";
    wrapper.style.gap = "10px";
    wrapper.style.marginTop = "10px";
    wrapper.style.marginBottom = "10px";
    wrapper.style.alignItems = "center";
    const showText = userMode === "voice_text" || userMode === "text_only";
    const showMic = userMode === "voice_text" || userMode === "voice_only";
    this.inputEl = new import_obsidian51.TextComponent(wrapper);
    this.inputEl.setPlaceholder("Escribe tu respuesta...");
    this.inputEl.inputEl.style.flex = "1";
    this.inputEl.setDisabled(!isEnabled);
    if (!showText) {
      this.inputEl.inputEl.style.display = "none";
    }
    this.inputEl.inputEl.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        this.sendMessage();
      }
    });
    this.micButton = new import_obsidian51.ButtonComponent(wrapper);
    this.micButton.setIcon("microphone");
    this.micButton.setTooltip("Hablar para escribir");
    this.micButton.setDisabled(!isEnabled);
    this.micButton.onClick(() => {
      if (showMic)
        this.toggleRecording();
    });
    if (!showMic) {
      this.micButton.buttonEl.style.display = "none";
    }
    const sendBtn = new import_obsidian51.ButtonComponent(wrapper);
    sendBtn.setIcon("send");
    sendBtn.setTooltip("Enviar");
    sendBtn.setDisabled(!isEnabled);
    if (!showText) {
      sendBtn.buttonEl.style.display = "none";
    }
    sendBtn.onClick(() => {
      this.sendMessage();
    });
  }
  async toggleRecording() {
    if (this.audioRecorder.isRecording()) {
      await this.stopRecording();
    } else {
      await this.startRecording();
    }
  }
  async startRecording() {
    if (!this.apiKey) {
      showMessage("API Key missing. Cannot transcribe.");
      return;
    }
    const success = await this.audioRecorder.start();
    if (success) {
      this.updateMicButtonState();
      showMessage("Recording started...");
    }
  }
  async stopRecording() {
    var _a2, _b;
    if (!this.audioRecorder.isRecording())
      return;
    const blob = await this.audioRecorder.stop();
    this.updateMicButtonState();
    if (blob) {
      showMessage("Transcribing...");
      try {
        const text = await this.transcriptionAdapter.transcribe(blob);
        if (text) {
          const current = ((_a2 = this.inputEl) == null ? void 0 : _a2.getValue()) || "";
          const separator = current && !current.endsWith(" ") ? " " : "";
          (_b = this.inputEl) == null ? void 0 : _b.setValue(current + separator + text);
          showMessage("Transcription added.");
          this.sendMessage();
        }
      } catch (error) {
        showMessage("Transcription failed. Check console for details.");
        console.error(error);
      }
    }
  }
  updateMicButtonState() {
    if (!this.micButton)
      return;
    if (this.audioRecorder.isRecording()) {
      this.micButton.buttonEl.addClass("is-recording");
      this.micButton.setIcon("mic-off");
      this.micButton.buttonEl.style.color = "var(--text-error)";
    } else {
      this.micButton.buttonEl.removeClass("is-recording");
      this.micButton.setIcon("microphone");
      this.micButton.buttonEl.style.color = "";
    }
  }
  sendMessage() {
    if (!this.inputEl)
      return;
    if (this.audioRecorder.isRecording()) {
      this.stopRecording();
    }
    const text = this.inputEl.getValue().trim();
    if (text) {
      this.onSend(text);
      this.inputEl.setValue("");
    }
  }
  focus() {
    var _a2, _b;
    (_b = (_a2 = this.inputEl) == null ? void 0 : _a2.inputEl) == null ? void 0 : _b.focus();
  }
};

// src/Infrastructure/Obsidian/Views/Chat/ChatView.ts
var VIEW_TYPE_CHAT = "gemini-live-session-view";
var ChatView = class extends import_obsidian52.ItemView {
  // =========================================================================================
  // Lifecycle
  // =========================================================================================
  constructor(leaf) {
    super(leaf);
    this.apiKey = "";
    this.liveMode = "gemini_live_voice_text";
    this.liveUserMode = "voice_text";
    this.adapter = null;
    // --- Components ---
    this.transcriptComponent = null;
    this.rolesComponent = null;
    this.quizComponent = null;
    this.chatInputComponent = null;
    this.sessionControlsComponent = null;
    // --- UI Elements ---
    this.contentContainer = null;
    this.configTabBtn = null;
    this.chatTabBtn = null;
    this.quizTabBtn = null;
    // New Quiz Tab Button
    this.configContentDiv = null;
    this.chatContentDiv = null;
    this.quizContentDiv = null;
    // New Quiz Content Div
    this.chatStopButton = null;
    // --- State ---
    this.activeTab = "config";
    this.isSessionActive = false;
    this.sessionStartTime = null;
    this.originalSidebarSize = null;
    // User Selections
    this.selectedRolePrompt = "";
    this.selectedRoleEvaluationPrompt = "";
    this.selectedVoice = "Aoede";
    this.selectedLocalVoice = "";
    // New Local Voice
    this.selectedTemperature = 1;
    this.selectedTopP = 0.95;
    // Data
    this.availableRoles = [];
    this.selectedVocabularyItems = /* @__PURE__ */ new Set();
    // UI Persistence
    this.savedTranscriptHtml = "";
    this.aiTranscriptBuffer = "";
    this.userTranscriptBuffer = "";
    this.sessionLogger = new SessionLogger(this.app);
    this.contextService = new ContextService(this.app);
    const noteManager = new ObsidianNoteManager(this.app);
    const metadataService = new MetadataService(this.app);
    this.quizService = new QuizService(noteManager, this.contextService, metadataService);
  }
  setPlugin(plugin) {
    var _a2, _b, _c;
    this.plugin = plugin;
    this.apiKey = plugin.settings.geminiApiKey;
    this.liveMode = (_a2 = plugin.settings.geminiLiveMode) != null ? _a2 : "gemini_live_voice_text";
    this.liveUserMode = (_b = plugin.settings.geminiLiveUserMode) != null ? _b : "voice_text";
    this.selectedLocalVoice = (_c = plugin.settings.geminiLiveLocalVoice) != null ? _c : "";
    if (!this.selectedRolePrompt && plugin.settings.geminiLiveRole) {
    }
    const settingsAdapter = new ObsidianSettingsAdapter(this.plugin);
    const roleRepo = new ObsidianRoleRepository(this.app, settingsAdapter);
    this.rolesService = new RolesService(roleRepo);
    const noteManager = new ObsidianNoteManager(this.app);
    this.headerEvaluationService = new HeaderEvaluationService(this.plugin.llm, noteManager);
  }
  setApiKey(key) {
    this.apiKey = key;
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "Chat Session";
  }
  async onOpen() {
    await this.renderContent();
    this.registerEvent(this.app.workspace.on("active-leaf-change", async (leaf) => {
      var _a2;
      if (leaf) {
        if (leaf.view.getViewType() === VIEW_TYPE_CHAT && leaf.view === this) {
        } else if (leaf.view instanceof import_obsidian52.MarkdownView) {
          await this.quizService.buildQuizQueue();
          (_a2 = this.quizComponent) == null ? void 0 : _a2.refreshList(this.quizService, (i) => this.onQuizSelect(i));
        }
      }
    }));
  }
  async onClose() {
    await this.stopSession();
    this.toggleMaximize(false);
  }
  // =========================================================================================
  // Rendering
  // =========================================================================================
  async renderContent() {
    if (this.transcriptComponent) {
      this.savedTranscriptHtml = this.transcriptComponent.getHtml();
    }
    const container = this.contentContainer || this.containerEl.children[1];
    container.empty();
    this.contentContainer = container;
    if (this.rolesService) {
      this.availableRoles = await this.rolesService.loadRoles();
    }
    if (this.availableRoles.length > 0) {
      if (!this.selectedRolePrompt && this.plugin.settings.geminiLiveRole) {
        const savedRole = this.availableRoles.find((r) => r.name === this.plugin.settings.geminiLiveRole || r.prompt === this.plugin.settings.geminiLiveRole);
        const roleByPrompt = this.availableRoles.find((r) => r.prompt === this.plugin.settings.geminiLiveRole);
        if (roleByPrompt) {
          this.applyRoleSettings(roleByPrompt);
        }
      }
      if (!this.selectedRolePrompt) {
        const firstRole = this.availableRoles[0];
        this.applyRoleSettings(firstRole);
        this.plugin.settings.geminiLiveRole = firstRole.prompt;
        this.plugin.saveSettings();
      }
    }
    const mainInterface = this.contentContainer.createDiv();
    this.renderTabs(mainInterface);
    this.configContentDiv = mainInterface.createDiv("tab-content");
    this.quizContentDiv = mainInterface.createDiv("tab-content");
    this.chatContentDiv = mainInterface.createDiv("tab-content");
    this.updateTabVisibility();
    this.renderConfigTab();
    this.renderQuizTab();
    this.renderChatTab();
  }
  renderTabs(container) {
    const tabContainer = container.createDiv("live-session-tabs");
    this.configTabBtn = tabContainer.createDiv("live-session-tab");
    this.configTabBtn.textContent = "Config";
    this.configTabBtn.onclick = () => this.switchTab("config");
    this.quizTabBtn = tabContainer.createDiv("live-session-tab");
    this.quizTabBtn.textContent = "Quiz";
    this.quizTabBtn.onclick = () => this.switchTab("quiz");
    this.chatTabBtn = tabContainer.createDiv("live-session-tab");
    this.chatTabBtn.textContent = "Chat";
    this.chatTabBtn.onclick = () => this.switchTab("chat");
  }
  renderConfigTab() {
    if (!this.configContentDiv)
      return;
    this.rolesComponent = new RolesComponent(this.configContentDiv);
    this.rolesComponent.render({
      roles: this.availableRoles,
      selectedRolePrompt: this.selectedRolePrompt,
      selectedVoice: this.selectedVoice,
      selectedTemperature: this.selectedTemperature,
      isSessionActive: this.isSessionActive,
      onRoleChange: (val) => this.handleRoleChange(val),
      onVoiceChange: async (val) => {
        this.selectedVoice = val;
        if (this.isSessionActive)
          await this.restartSession("voice update");
      },
      onTemperatureChange: async (val) => {
        this.selectedTemperature = val;
        if (this.isSessionActive)
          await this.restartSession("temperature update");
      },
      selectedTopP: this.selectedTopP,
      onTopPChange: async (val) => {
        this.selectedTopP = val;
        if (this.isSessionActive)
          await this.restartSession("top_p update");
      },
      onEvalHeaders: () => this.evaluateHeaders(),
      onGenerateMetadata: () => new GenerateHeaderMetadataCommand(this.app).execute(),
      liveMode: this.liveMode,
      liveUserMode: this.liveUserMode,
      onLiveModeChange: async (val) => {
        this.liveMode = val;
        this.plugin.settings.geminiLiveMode = val;
        await this.plugin.saveSettings();
        await this.restartSession("AI Mode Update");
      },
      onLiveUserModeChange: async (val) => {
        this.liveUserMode = val;
        this.plugin.settings.geminiLiveUserMode = val;
        await this.plugin.saveSettings();
        this.renderChatTab();
      },
      selectedLocalVoice: this.selectedLocalVoice,
      onLocalVoiceChange: async (val) => {
        this.selectedLocalVoice = val;
        this.plugin.settings.geminiLiveLocalVoice = val;
        await this.plugin.saveSettings();
      }
    });
    const vocabComponent = new VocabularyComponent(this.configContentDiv);
    const currentRole = this.availableRoles.find((r) => r.prompt === this.selectedRolePrompt);
    if (currentRole && currentRole.vocabularyList) {
      vocabComponent.render(
        currentRole.vocabularyList,
        this.selectedVocabularyItems,
        (item) => this.toggleVocabularyItem(item)
      );
    }
  }
  renderQuizTab() {
    if (!this.quizContentDiv)
      return;
    this.quizContentDiv.empty();
    this.quizContentDiv.style.height = "100%";
    this.quizComponent = new QuizComponent(this.quizContentDiv);
    this.quizComponent.render({
      quizService: this.quizService,
      onStarLevelChange: async (val) => this.handleStarLevelChange(val),
      onFilterChange: async (val) => this.handleFilterChange(val),
      onAskNext: () => this.handleStartStop(),
      // Reuse start/stop logic which is now the primary trigger
      onTopicSelect: (i) => this.onQuizSelect(i),
      onRefresh: () => this.handleRefresh()
    });
    this.quizComponent.updateSessionStatus(this.isSessionActive, "", "");
  }
  renderChatTab() {
    if (!this.chatContentDiv)
      return;
    this.chatContentDiv.empty();
    const chatToolbar = this.chatContentDiv.createDiv("chat-toolbar");
    this.chatStopButton = chatToolbar.createEl("button", { cls: "chat-stop-btn destructive", text: "Stop Session" });
    this.chatStopButton.onclick = async () => await this.stopSession();
    this.updateChatStopButtonVisibility();
    this.transcriptComponent = new TranscriptComponent(this.chatContentDiv, this.app, this);
    if (this.savedTranscriptHtml) {
      this.transcriptComponent.setHtml(this.savedTranscriptHtml);
    }
    const chatContainer = this.chatContentDiv.createDiv();
    this.chatInputComponent = new ChatInputComponent(chatContainer, this.apiKey, (text) => this.handleUserText(text));
    this.chatInputComponent.render(this.isSessionActive, this.liveUserMode);
  }
  switchTab(tab) {
    this.activeTab = tab;
    this.updateTabVisibility();
  }
  updateTabVisibility() {
    if (this.configTabBtn && this.chatTabBtn && this.quizTabBtn) {
      this.configTabBtn.classList.toggle("active", this.activeTab === "config");
      this.chatTabBtn.classList.toggle("active", this.activeTab === "chat");
      this.quizTabBtn.classList.toggle("active", this.activeTab === "quiz");
    }
    if (this.configContentDiv && this.chatContentDiv && this.quizContentDiv) {
      this.configContentDiv.classList.toggle("active", this.activeTab === "config");
      this.chatContentDiv.classList.toggle("active", this.activeTab === "chat");
      this.quizContentDiv.classList.toggle("active", this.activeTab === "quiz");
    }
  }
  updateChatStopButtonVisibility() {
    if (this.chatStopButton) {
      this.chatStopButton.style.display = this.isSessionActive ? "flex" : "none";
    }
  }
  // =========================================================================================
  // Logic & Handlers
  // =========================================================================================
  async handleRoleChange(rolePrompt) {
    this.selectedRolePrompt = rolePrompt;
    const role = this.availableRoles.find((r) => r.prompt === rolePrompt);
    let shouldRestart = this.isSessionActive;
    if (role) {
      this.applyRoleSettings(role);
    } else {
      this.selectedRolePrompt = "";
    }
    await this.renderContent();
    if (shouldRestart) {
      await this.restartSession("role change");
    } else if (role) {
      showMessage(`Role applied: ${role.name}`);
    }
    if (role) {
      this.plugin.settings.geminiLiveRole = role.prompt;
      await this.plugin.saveSettings();
    }
  }
  applyRoleSettings(role) {
    this.selectedRolePrompt = role.prompt;
    this.selectedRoleEvaluationPrompt = role.evaluationPrompt || "";
    this.selectedVoice = role.liveVoice || "Aoede";
    this.selectedTemperature = role.liveTemperature !== void 0 ? role.liveTemperature : 1;
    this.selectedTopP = 0.95;
  }
  async handleStartStop() {
    if (this.isSessionActive) {
      await this.stopSession();
    } else {
      await this.handleAskNext("", true);
    }
  }
  async handleRestartSession(reason) {
    await this.restartSession(reason);
  }
  async restartSession(reason) {
    showMessage(`Restarting session for ${reason}...`);
    await this.stopSession();
    await this.startSession();
  }
  async startSession() {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    if (!this.apiKey) {
      showMessage("Gemini API Key is missing via settings.");
      return;
    }
    if (this.adapter) {
      console.log("LiveSessionView: Disconnecting existing adapter before restart...");
      this.adapter.disconnect();
      this.adapter = null;
    }
    console.log(`LiveSessionView: Instantiating adapter (Mode: ${this.liveMode})...`);
    if (this.liveMode === "text_only" || this.liveMode === "local_voice_text" || this.liveMode === "local_voice_only") {
      this.adapter = new import_core28.GoogleGeminiChatAdapter(
        this.apiKey,
        (text) => this.onAiAudioData(text),
        // Reuse text handler (it appends to transcript)
        async (score) => await this.onScoreUpdate(score),
        (text) => this.onUserAudioData(text)
        // Chat adapter might not call this often, but needed for type
      );
    } else {
      this.adapter = new GoogleGeminiLiveAdapter(
        this.apiKey,
        (text) => this.onAiAudioData(text),
        async (score) => await this.onScoreUpdate(score),
        (text) => this.onUserAudioData(text)
      );
    }
    console.log("LiveSessionView: Resuming audio...");
    await this.adapter.resumeAudio();
    console.log("LiveSessionView: Audio resumed.");
    (_a2 = this.sessionControlsComponent) == null ? void 0 : _a2.updateStatus(false, "Connecting...", "var(--text-normal)");
    (_b = this.quizComponent) == null ? void 0 : _b.updateSessionStatus(false, "Connecting...", "var(--text-normal)");
    (_c = this.transcriptComponent) == null ? void 0 : _c.startSession();
    const currentRole = this.availableRoles.find((r) => r.prompt === this.selectedRolePrompt);
    const enableScoreTracking = (currentRole == null ? void 0 : currentRole.trackLevelAnswer) || false;
    const systemInstruction = this.selectedRolePrompt;
    const success = await this.adapter.connect(systemInstruction, enableScoreTracking, this.selectedVoice, this.selectedTemperature, this.selectedTopP);
    if (success) {
      this.isSessionActive = true;
      this.sessionStartTime = /* @__PURE__ */ new Date();
      await this.sessionLogger.logStart(this.sessionStartTime);
      (_d = this.sessionControlsComponent) == null ? void 0 : _d.updateStatus(true, "", "");
      (_e = this.quizComponent) == null ? void 0 : _e.updateSessionStatus(true, "", "");
      (_f = this.chatInputComponent) == null ? void 0 : _f.render(true, this.liveUserMode);
      this.updateChatStopButtonVisibility();
      showMessage("Live Connected");
      if (enableScoreTracking)
        showMessage("Answer scoring enabled.");
    } else {
      (_g = this.sessionControlsComponent) == null ? void 0 : _g.updateStatus(false, "Connection Failed", "var(--text-error)");
      (_h = this.quizComponent) == null ? void 0 : _h.updateSessionStatus(false, "Connection Failed", "var(--text-error)");
      this.adapter = null;
    }
  }
  async stopSession() {
    var _a2, _b, _c;
    if (this.sessionStartTime) {
      const now = /* @__PURE__ */ new Date();
      const duration = (now.getTime() - this.sessionStartTime.getTime()) / 6e4;
      await this.sessionLogger.logEnd(now, duration);
      this.sessionStartTime = null;
    }
    if (this.adapter) {
      this.adapter.disconnect();
      this.adapter = null;
    }
    this.isSessionActive = false;
    (_a2 = this.sessionControlsComponent) == null ? void 0 : _a2.updateStatus(false, "Session Ended", "var(--text-muted)");
    (_b = this.quizComponent) == null ? void 0 : _b.updateSessionStatus(false, "Session Ended", "var(--text-muted)");
    (_c = this.chatInputComponent) == null ? void 0 : _c.render(false, this.liveUserMode);
    this.updateChatStopButtonVisibility();
  }
  // --- Audio Data Callbacks ---
  onAiAudioData(text) {
    var _a2;
    if (this.liveMode !== "gemini_live_voice_only" && this.liveMode !== "local_voice_only") {
      (_a2 = this.transcriptComponent) == null ? void 0 : _a2.appendAiText(text);
    }
    this.aiTranscriptBuffer += text;
    if (this.liveMode === "local_voice_text" || this.liveMode === "local_voice_only") {
      this.speakText(text);
    }
    let processBuffer = true;
    while (processBuffer) {
      const match = this.aiTranscriptBuffer.match(/([^.?!]+[.?!])\s+/);
      if (match) {
        const sentence = match[1];
        const fullMatch = match[0];
        this.sessionLogger.logTranscript("AI", sentence);
        this.aiTranscriptBuffer = this.aiTranscriptBuffer.substring(fullMatch.length);
      } else {
        processBuffer = false;
      }
    }
  }
  speakText(text) {
    if (!text)
      return;
    const utterance = new SpeechSynthesisUtterance(text);
    if (this.selectedLocalVoice) {
      const voices = window.speechSynthesis.getVoices();
      const voice = voices.find((v) => v.voiceURI === this.selectedLocalVoice);
      if (voice) {
        utterance.voice = voice;
        utterance.lang = voice.lang;
      }
    }
    window.speechSynthesis.speak(utterance);
  }
  onUserAudioData(text) {
    var _a2;
    (_a2 = this.transcriptComponent) == null ? void 0 : _a2.appendUserText(text);
    this.userTranscriptBuffer += text;
    let processBuffer = true;
    while (processBuffer) {
      const match = this.userTranscriptBuffer.match(/([^.?!]+[.?!])\s*/);
      if (match) {
        const sentence = match[1];
        const fullMatch = match[0];
        this.sessionLogger.logTranscript("User", sentence);
        this.userTranscriptBuffer = this.userTranscriptBuffer.substring(fullMatch.length);
      } else {
        processBuffer = false;
      }
    }
  }
  async onScoreUpdate(score) {
    var _a2, _b;
    console.log("LiveSessionView: Received score:", score);
    await this.sessionLogger.logScore(score);
    showMessage(`\u{1F4A1} Nota: ${score}`);
    (_a2 = this.transcriptComponent) == null ? void 0 : _a2.appendScore(score);
    await this.handleScoreInMetadata(score);
    (_b = this.adapter) == null ? void 0 : _b.sendText("continue");
  }
  // --- Quiz / Header Logic ---
  async handleAskNext(message = "", forceStart = false) {
    var _a2, _b, _c, _d, _e, _f, _g;
    if (!this.isSessionActive || forceStart) {
      if (!this.isSessionActive) {
        showMessage("Starting session...");
        await this.startSession();
        if (!this.isSessionActive) {
          return;
        }
      }
    }
    if (this.quizService.queue.length === 0) {
      const success = await this.quizService.buildQuizQueue();
      if (!success) {
        (_a2 = this.quizComponent) == null ? void 0 : _a2.setStatusText("No hay temas para preguntar.");
        console.log("ChatView: Quiz queue empty and failed to build");
        showMessage("No hay temas para preguntar. Selecciona una nota con encabezados.");
        return;
      }
      (_b = this.quizComponent) == null ? void 0 : _b.refreshList(this.quizService, (i) => this.onQuizSelect(i));
    }
    const item = this.quizService.getCurrentItem();
    if (!item) {
      console.log("ChatView: No current item found");
      showMessage("No hay ning\xFAn tema seleccionado.");
      return;
    }
    this.switchTab("chat");
    (_c = this.chatInputComponent) == null ? void 0 : _c.focus();
    await this.sessionLogger.logQuestion(item.heading);
    const statusText = `Examinando: ${item.heading}`;
    (_d = this.quizComponent) == null ? void 0 : _d.setStatusText(statusText);
    (_e = this.quizComponent) == null ? void 0 : _e.refreshList(this.quizService, (i) => this.onQuizSelect(i));
    (_f = this.transcriptComponent) == null ? void 0 : _f.appendTopic(item.heading);
    let prompt = await this.quizService.generateQuestionPrompt();
    if (!prompt) {
      return;
    }
    const vocabContext = await this.contextService.getVocabularyContent(this.selectedVocabularyItems);
    if (vocabContext) {
      prompt += `

# Contextual Knowledge
${vocabContext}`;
      showMessage(`Injected context from ${this.selectedVocabularyItems.size} vocabulary notes.`);
    }
    (_g = this.adapter) == null ? void 0 : _g.sendContextUpdate("Quiz Content", prompt);
    showMessage(`Sent: ${item.heading}`);
  }
  async handleScoreInMetadata(score) {
    var _a2;
    const currentItem = this.quizService.getCurrentItem();
    if (!currentItem)
      return;
    const oldScore = await this.quizService.recordBlockScore(currentItem, score);
    if (oldScore !== null) {
      showMessage(`Score updated: ${oldScore}`);
    }
    if (this.quizService.hasNext()) {
      this.quizService.next();
      (_a2 = this.quizComponent) == null ? void 0 : _a2.refreshList(this.quizService, (i) => this.onQuizSelect(i));
    }
  }
  async onQuizSelect(index) {
    var _a2;
    this.quizService.currentIndex = index;
    (_a2 = this.quizComponent) == null ? void 0 : _a2.refreshList(this.quizService, (i) => this.onQuizSelect(i));
  }
  async handleStarLevelChange(level) {
    var _a2;
    this.quizService.selectedStarLevel = level;
    await this.quizService.buildQuizQueue();
    (_a2 = this.quizComponent) == null ? void 0 : _a2.refreshList(this.quizService, (i) => this.onQuizSelect(i));
  }
  async handleFilterChange(onlyTitles) {
    var _a2;
    this.quizService.onlyTitlesWithoutSubtitles = onlyTitles;
    await this.quizService.buildQuizQueue();
    (_a2 = this.quizComponent) == null ? void 0 : _a2.refreshList(this.quizService, (i) => this.onQuizSelect(i));
  }
  async handleRefresh() {
    showMessage("Refrescando datos...");
    if (this.rolesService) {
      this.availableRoles = await this.rolesService.loadRoles();
    }
    await this.quizService.buildQuizQueue();
    await this.renderContent();
    showMessage("Datos actualizados.");
  }
  // --- Vocabulary Helpers ---
  toggleVocabularyItem(item) {
    if (this.selectedVocabularyItems.has(item)) {
      this.selectedVocabularyItems.delete(item);
    } else {
      this.selectedVocabularyItems.add(item);
    }
    this.renderContent();
  }
  // --- Other Handlers ---
  async evaluateHeaders() {
    if (!this.headerEvaluationService)
      return;
    if (!this.selectedRoleEvaluationPrompt) {
      showMessage("Current role has no !!evaluationPrompt defined.");
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md")
      return;
    showMessage("Starting header evaluation...");
    try {
      const result = await this.headerEvaluationService.evaluateHeaders(activeFile.path, this.selectedRoleEvaluationPrompt);
      showMessage(`Evaluation complete. Processed ${result.processed} headers.`);
    } catch (e) {
      console.error("Error evaluating headers:", e);
      showMessage(`Error during evaluation: ${e}`);
    }
  }
  async handleUserText(text) {
    var _a2, _b;
    if (!this.isSessionActive || !this.adapter)
      return;
    this.adapter.sendText(text);
    (_a2 = this.transcriptComponent) == null ? void 0 : _a2.appendUserText(text);
    this.sessionLogger.logTranscript("User", text);
    (_b = this.chatInputComponent) == null ? void 0 : _b.focus();
  }
  toggleMaximize(maximize) {
    if (!this.leaf)
      return;
    const parent = this.leaf.parent;
    const isInRightSidebar = this.leaf.parent === this.app.workspace.rightSplit;
    if (isInRightSidebar) {
      const split = this.app.workspace.rightSplit;
      if (maximize) {
        this.originalSidebarSize = split.size;
        split.setSize(window.innerWidth - 100);
      } else {
        if (this.originalSidebarSize)
          split.setSize(this.originalSidebarSize);
      }
      return;
    }
    if (parent && parent.type === "split") {
      const parentEl = parent.containerEl;
      if (maximize) {
        parentEl.classList.add("gemini-live-mode-parent");
        this.leaf.containerEl.classList.add("gemini-live-mode-active-leaf");
      } else {
        parentEl.classList.remove("gemini-live-mode-parent");
        this.leaf.containerEl.classList.remove("gemini-live-mode-active-leaf");
      }
    }
  }
};

// src/Infrastructure/Obsidian/Views/NoteOperations/NoteOperationsView.ts
var import_obsidian53 = require("obsidian");
var VIEW_TYPE_NOTE_OPERATIONS = "note-operations-view";
var NoteOperationsView = class extends import_obsidian53.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.selectedCommandId = "";
    this.executeButton = null;
    this.isExecuting = false;
    this.transcriptionAdapter = null;
    this.micButton = null;
    this.plugin = plugin;
    this.audioRecorder = new AudioRecorder2();
  }
  getViewType() {
    return VIEW_TYPE_NOTE_OPERATIONS;
  }
  getDisplayText() {
    return "Note Operations";
  }
  getIcon() {
    return "microphone";
  }
  async onOpen() {
    var _a2;
    this.transcriptionAdapter = new GeminiTranscriptionAdapter((_a2 = this.plugin.settings.geminiApiKey) != null ? _a2 : "");
    const container = this.containerEl.children[1];
    container.empty();
    container.style.padding = "20px";
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.gap = "15px";
    container.createEl("h2", { text: "Note Operations" });
    const controlsContainer = container.createDiv();
    controlsContainer.style.display = "flex";
    controlsContainer.style.flexDirection = "column";
    controlsContainer.style.gap = "10px";
    const dropdown = new import_obsidian53.DropdownComponent(controlsContainer);
    const commands = this.plugin.getNoteCommands();
    if (commands.length > 0) {
      this.selectedCommandId = commands[0].id;
    }
    commands.forEach((cmd) => {
      dropdown.addOption(cmd.id, cmd.name);
    });
    dropdown.onChange((value) => {
      this.selectedCommandId = value;
    });
    dropdown.selectEl.style.width = "100%";
    this.executeButton = new import_obsidian53.ButtonComponent(controlsContainer);
    this.executeButton.setButtonText("Ejecutar Command").setCta().onClick(() => {
      this.executeSelectedCommand();
    });
    this.executeButton.buttonEl.style.width = "100%";
    const micContainer = container.createDiv();
    micContainer.style.display = "flex";
    micContainer.style.justifyContent = "center";
    micContainer.style.marginTop = "20px";
    this.micButton = new import_obsidian53.ButtonComponent(micContainer);
    this.micButton.setIcon("microphone");
    this.micButton.setTooltip("Mant\xE9n pulsado para hablar");
    this.micButton.buttonEl.style.width = "60px";
    this.micButton.buttonEl.style.height = "60px";
    this.micButton.buttonEl.style.borderRadius = "50%";
    this.micButton.buttonEl.style.fontSize = "24px";
    const btnEl = this.micButton.buttonEl;
    btnEl.addEventListener("mousedown", (e) => this.handleStartRecording(e));
    btnEl.addEventListener("mouseup", (e) => this.handleStopRecording(e));
    btnEl.addEventListener("mouseleave", (e) => {
      if (this.audioRecorder.isRecording()) {
        this.handleStopRecording(e);
      }
    });
    btnEl.addEventListener("touchstart", (e) => {
      e.preventDefault();
      this.handleStartRecording(e);
    });
    btnEl.addEventListener("touchend", (e) => {
      e.preventDefault();
      this.handleStopRecording(e);
    });
    const bridgeContainer = container.createDiv();
    bridgeContainer.style.marginTop = "20px";
    bridgeContainer.style.borderTop = "1px solid var(--background-modifier-border)";
    bridgeContainer.style.paddingTop = "10px";
    bridgeContainer.createEl("h3", { text: "Bridge Control (Photos)" });
    const bridgeControls = bridgeContainer.createDiv();
    bridgeControls.style.display = "flex";
    bridgeControls.style.gap = "10px";
    const startBtn = new import_obsidian53.ButtonComponent(bridgeControls).setButtonText("Iniciar Bridge").onClick(() => {
      this.plugin.bridgeService.startBridge(true);
      this.updateBridgeStatus(statusIndicator);
    });
    const stopBtn = new import_obsidian53.ButtonComponent(bridgeControls).setButtonText("Detener Bridge").setWarning().onClick(() => {
      this.plugin.bridgeService.stopBridge();
      this.updateBridgeStatus(statusIndicator);
    });
    const statusIndicator = bridgeContainer.createDiv();
    this.updateBridgeStatus(statusIndicator);
  }
  updateBridgeStatus(el) {
    const isRunning = this.plugin.bridgeService.isRunning();
    el.empty();
    el.style.marginTop = "10px";
    el.style.display = "flex";
    el.style.alignItems = "center";
    el.style.gap = "8px";
    const dot = el.createSpan();
    dot.style.width = "10px";
    dot.style.height = "10px";
    dot.style.borderRadius = "50%";
    dot.style.backgroundColor = isRunning ? "var(--color-green)" : "var(--color-red)";
    el.createSpan({ text: isRunning ? "Estado: Ejecut\xE1ndose" : "Estado: Detenido" });
  }
  async handleStartRecording(e) {
    if (this.audioRecorder.isRecording())
      return;
    if (!this.plugin.settings.geminiApiKey) {
      showMessage("Gemini API Key missing. Cannot transcribe.");
      return;
    }
    const success = await this.audioRecorder.start();
    if (success) {
      this.updateMicVisuals(true);
      showMessage("Escuchando...");
    }
  }
  async handleStopRecording(e) {
    var _a2;
    if (!this.audioRecorder.isRecording())
      return;
    const blob = await this.audioRecorder.stop();
    this.updateMicVisuals(false);
    if (blob) {
      showMessage("Transcribiendo...");
      try {
        this.transcriptionAdapter = new GeminiTranscriptionAdapter((_a2 = this.plugin.settings.geminiApiKey) != null ? _a2 : "");
        const text = await this.transcriptionAdapter.transcribe(blob);
        if (text) {
          this.insertTextAtCursor(text);
          showMessage("Texto insertado.");
        }
      } catch (error) {
        showMessage("Error en la transcripci\xF3n.");
        console.error(error);
      }
    }
  }
  updateMicVisuals(isRecording) {
    if (!this.micButton)
      return;
    const btnEl = this.micButton.buttonEl;
    if (isRecording) {
      btnEl.classList.add("is-recording");
      this.micButton.setIcon("mic-off");
      btnEl.style.backgroundColor = "var(--text-error)";
      btnEl.style.color = "white";
    } else {
      btnEl.classList.remove("is-recording");
      this.micButton.setIcon("microphone");
      btnEl.style.backgroundColor = "";
      btnEl.style.color = "";
    }
  }
  async insertTextAtCursor(text) {
    let activeView = getActiveMarkdownView(this.app);
    if (activeView) {
      const currentMode = activeView.getMode();
      let appendToEnd = false;
      if (currentMode === "preview") {
        await activeView.setState({ mode: "source" }, { history: false });
        appendToEnd = true;
      }
      const editor = activeView.editor;
      editor.focus();
      if (appendToEnd) {
        const lastLine = editor.lastLine();
        const lastLineLength = editor.getLine(lastLine).length;
        editor.setCursor({ line: lastLine, ch: lastLineLength });
        if (lastLineLength > 0 || lastLine > 0) {
          editor.replaceSelection("\n");
        }
      }
      editor.replaceSelection(text);
      if (appendToEnd) {
        editor.scrollIntoView({ from: editor.getCursor(), to: editor.getCursor() });
      }
    } else {
      showMessage("No active markdown note to insert text.");
    }
  }
  async executeSelectedCommand() {
    var _a2;
    if (!this.selectedCommandId) {
      showMessage("No command selected");
      return;
    }
    if (this.isExecuting)
      return;
    const commands = this.plugin.getNoteCommands();
    const cmd = commands.find((c) => c.id === this.selectedCommandId);
    if (cmd && cmd.callback) {
      this.isExecuting = true;
      if (this.executeButton) {
        this.executeButton.setDisabled(true);
        this.executeButton.setButtonText("Ejecutando...");
      }
      try {
        let view = getActiveMarkdownView(this.app);
        let targetFile = view == null ? void 0 : view.file;
        if (!targetFile) {
          targetFile = (_a2 = this.plugin.getLastActiveMarkdownFile()) != null ? _a2 : void 0;
        }
        if (targetFile) {
          await cmd.callback(targetFile);
          showMessage(`Executed: ${cmd.name}`);
        } else {
          showMessage("No active markdown file to contextually execute command.");
        }
      } catch (error) {
        console.error("Error executing command:", error);
        showMessage(`Error executing command: ${error}`);
      } finally {
        this.isExecuting = false;
        if (this.executeButton) {
          this.executeButton.setDisabled(false);
          this.executeButton.setButtonText("Ejecutar Command");
        }
      }
    } else {
      showMessage("Command not found or invalid");
    }
  }
};

// src/Infrastructure/Adapters/SpotifyAdapter/SpotifyAdapter.ts
var import_obsidian54 = require("obsidian");
var SpotifyAdapter = class {
  constructor(clientId, accessToken, refreshToken = "", tokenExpirationTime = 0, onTokenRefreshed = async () => {
  }, onAuthNeeded = () => {
  }) {
    this.clientId = clientId;
    this.accessToken = accessToken;
    this.refreshToken = refreshToken;
    this.tokenExpirationTime = tokenExpirationTime;
    this.onTokenRefreshed = onTokenRefreshed;
    this.onAuthNeeded = onAuthNeeded;
  }
  updateCredentials(clientId, accessToken) {
    this.clientId = clientId;
    this.accessToken = accessToken;
  }
  isAuthenticated() {
    if (this.accessToken && this.tokenExpirationTime > Date.now()) {
      return true;
    }
    if (this.refreshToken) {
      return true;
    }
    return false;
  }
  async refreshAccessToken() {
    if (!this.refreshToken) {
      console.warn("Cannot refresh Spotify token: No refresh token available.");
      return;
    }
    const params = new URLSearchParams({
      client_id: this.clientId,
      grant_type: "refresh_token",
      refresh_token: this.refreshToken
    });
    try {
      const response = await (0, import_obsidian54.requestUrl)({
        url: "https://accounts.spotify.com/api/token",
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: params.toString()
      });
      if (response.status === 200) {
        const data = response.json;
        this.accessToken = data.access_token;
        this.tokenExpirationTime = Date.now() + data.expires_in * 1e3;
        await this.onTokenRefreshed(this.accessToken, this.tokenExpirationTime);
        console.log("Spotify access token refreshed successfully.");
      } else {
        console.error(`Failed to refresh Spotify token: ${response.status} - ${response.text}`);
        throw new Error(`Token refresh failed: ${response.status}`);
      }
    } catch (error) {
      console.error("Error refreshing Spotify token:", error);
      this.onAuthNeeded();
      throw error;
    }
  }
  getAuthUrl(redirectUri, challenge) {
    const scopes = "user-read-private user-read-email playlist-read-private user-library-read";
    const params = new URLSearchParams({
      client_id: this.clientId,
      response_type: "code",
      redirect_uri: redirectUri,
      scope: scopes,
      code_challenge_method: "S256",
      code_challenge: challenge,
      show_dialog: "true"
    });
    return `https://accounts.spotify.com/authorize?${params.toString()}`;
  }
  async generateAuthUrl(redirectUri, options) {
    const challenge = (options == null ? void 0 : options.challenge) || "";
    return this.getAuthUrl(redirectUri, challenge);
  }
  async exchangeCode(code, redirectUri, verifier) {
    const params = new URLSearchParams({
      client_id: this.clientId,
      grant_type: "authorization_code",
      code,
      redirect_uri: redirectUri,
      code_verifier: verifier
    });
    const response = await (0, import_obsidian54.requestUrl)({
      url: "https://accounts.spotify.com/api/token",
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: params.toString()
    });
    if (response.status === 200) {
      const data = response.json;
      this.accessToken = data.access_token;
      this.refreshToken = data.refresh_token;
      const expiresIn = data.expires_in;
      return {
        accessToken: data.access_token,
        refreshToken: data.refresh_token,
        expiresIn
      };
    } else {
      throw new Error(`Token exchange failed: ${response.status} - ${response.text}`);
    }
  }
  generatePkceVerifier() {
    const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    let text = "";
    for (let i = 0; i < 128; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }
  async generatePkceChallenge(verifier) {
    const encoder = new TextEncoder();
    const data = encoder.encode(verifier);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const base64 = btoa(String.fromCharCode.apply(null, hashArray)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    return base64;
  }
  async request(url, method = "GET", body) {
    if (this.refreshToken && this.tokenExpirationTime && Date.now() > this.tokenExpirationTime - 5 * 60 * 1e3) {
      console.log("Spotify token expired or about to expire. Refreshing...");
      await this.refreshAccessToken();
    }
    if (!this.accessToken) {
      throw new Error("Spotify access token is missing.");
    }
    const params = {
      url,
      method,
      headers: {
        "Authorization": `Bearer ${this.accessToken}`,
        "Content-Type": "application/json"
      }
    };
    if (body) {
      params.body = JSON.stringify(body);
    }
    try {
      const response = await (0, import_obsidian54.requestUrl)(params);
      if (response.status >= 200 && response.status < 300) {
        return response.json;
      } else {
        throw new Error(`Spotify API Error: ${response.status} - ${response.text}`);
      }
    } catch (error) {
      console.error("Spotify API Request Failed:", error);
      throw error;
    }
  }
  async searchTracks(query) {
    const url = `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=10`;
    const response = await this.request(url);
    return response.tracks.items.map((item) => ({
      id: item.id,
      uri: item.uri,
      name: item.name,
      artists: item.artists.map((artist) => artist.name),
      album: item.album.name
    }));
  }
  async getUserPlaylists() {
    const url = "https://api.spotify.com/v1/me/playlists?limit=50";
    const response = await this.request(url);
    return response.items.map((item) => ({
      uri: item.uri,
      name: item.name,
      id: item.id,
      totalTracks: item.tracks.total
    }));
  }
  async getPlaylistTracks(playlistId) {
    const url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`;
    const response = await this.request(url);
    return response.items.map((item) => ({
      id: item.track.id,
      uri: item.track.uri,
      name: item.track.name,
      artists: item.track.artists.map((artist) => artist.name),
      album: item.track.album.name
    }));
  }
  async searchArtists(query) {
    const url = `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=artist&limit=5`;
    const response = await this.request(url);
    return response.artists.items.map((item) => ({
      uri: item.uri,
      name: item.name,
      popularity: item.popularity,
      genres: item.genres,
      images: item.images
    }));
  }
};

// src/Application/Services/MusicService.ts
var MusicService = class {
  constructor(provider, settings) {
    this.provider = provider;
    this.settings = settings;
  }
  isAuthenticated() {
    return this.provider.isAuthenticated();
  }
  async initiateConnection(redirectUri) {
    let options = {};
    if (this.provider.generatePkceVerifier && this.provider.generatePkceChallenge) {
      const verifier = this.provider.generatePkceVerifier();
      this.settings.setSpotifyPkceVerifier(verifier);
      await this.settings.saveSettings();
      const challenge = await this.provider.generatePkceChallenge(verifier);
      options = { challenge };
    }
    return await this.provider.generateAuthUrl(redirectUri, options);
  }
  async completeConnection(code, redirectUri) {
    try {
      const verifier = this.settings.getSpotifyPkceVerifier();
      const { accessToken, refreshToken, expiresIn } = await this.provider.exchangeCode(code, redirectUri, verifier);
      this.settings.setSpotifyAccessToken(accessToken);
      this.settings.setSpotifyRefreshToken(refreshToken);
      this.settings.setSpotifyTokenExpirationTime(Date.now() + expiresIn * 1e3);
      this.settings.setSpotifyPkceVerifier("");
      await this.settings.saveSettings();
      this.provider.updateCredentials(this.settings.getSpotifyClientId(), accessToken);
      return true;
    } catch (error) {
      console.error("MusicService: Connection failed", error);
      return false;
    }
  }
  async searchTracks(query) {
    if (!this.isAuthenticated())
      return [];
    return await this.provider.searchTracks(query);
  }
  async getUserPlaylists() {
    if (!this.isAuthenticated())
      return [];
    return await this.provider.getUserPlaylists();
  }
  async getPlaylistTracks(playlistId) {
    if (!this.isAuthenticated())
      return [];
    return await this.provider.getPlaylistTracks(playlistId);
  }
};

// src/Infrastructure/Obsidian/main.ts
var import_core34 = __toESM(require_dist());

// src/Infrastructure/Obsidian/MarkdownPostProcessors/HeaderProgressRenderer.ts
var import_obsidian55 = require("obsidian");
var lastWarningTime = {};
var createHeaderProgressRenderer = (app, service) => {
  return async (el, ctx) => {
    var _a2;
    const sourcePath = ctx.sourcePath;
    if (!sourcePath)
      return;
    const progressMap = await service.getHeaderProgress(sourcePath);
    if (Object.keys(progressMap).length === 0)
      return;
    const file = app.vault.getAbstractFileByPath(sourcePath);
    if (file instanceof import_obsidian55.TFile) {
      const cache = app.metadataCache.getFileCache(file);
      const headings = ((_a2 = cache == null ? void 0 : cache.headings) == null ? void 0 : _a2.map((h) => h.heading)) || [];
      const missingKeys = service.findMissingHeaders(progressMap, headings);
      if (missingKeys.length > 0) {
        const now = Date.now();
        if (!lastWarningTime[sourcePath] || now - lastWarningTime[sourcePath] > 1e4) {
          lastWarningTime[sourcePath] = now;
          showMessage(`\u26A0\uFE0F Header Progress: The following headers in .json are missing in the note:
${missingKeys.join("\n")}`);
          console.warn(`[HeaderProgress] Missing headers in ${sourcePath}:`, missingKeys);
        }
      }
    }
    const headers = Array.from(el.querySelectorAll("h1, h2, h3, h4, h5, h6"));
    headers.forEach((header) => {
      var _a3;
      const headerText = (_a3 = header.innerText) == null ? void 0 : _a3.trim();
      if (!headerText)
        return;
      if (progressMap.hasOwnProperty(headerText)) {
        const progressValue = progressMap[headerText];
        if (header.querySelector(".header-progress-container"))
          return;
        const progressContainer = document.createElement("span");
        progressContainer.addClass("header-progress-container");
        const progressBar = document.createElement("progress");
        progressBar.addClass("header-progress-bar");
        progressBar.value = progressValue;
        progressBar.max = 100;
        const progressLabel = document.createElement("span");
        progressLabel.addClass("header-progress-label");
        progressLabel.innerText = ` ${progressValue}%`;
        progressContainer.appendChild(progressBar);
        progressContainer.appendChild(progressLabel);
        header.appendChild(progressContainer);
      }
    });
  };
};

// src/Infrastructure/Obsidian/MarkdownPostProcessors/HeaderMetadataRenderer.ts
var import_obsidian56 = require("obsidian");
var import_core29 = __toESM(require_dist());
var import_core30 = __toESM(require_dist());
var createHeaderMetadataRenderer = (app, service) => {
  return async (el, ctx) => {
    const sourcePath = ctx.sourcePath;
    if (!sourcePath)
      return;
    const metadataMap = await service.getHeaderData(sourcePath);
    const headers = Array.from(el.querySelectorAll("h1, h2, h3, h4, h5, h6"));
    if (headers.length === 0)
      return;
    const sectionInfo = ctx.getSectionInfo(el);
    headers.forEach((header, index) => {
      var _a2;
      let blockId = "";
      if (sectionInfo) {
        const startLine = sectionInfo.lineStart;
        const endLine = sectionInfo.lineEnd;
        const file2 = app.vault.getAbstractFileByPath(sourcePath);
        if (file2 instanceof import_obsidian56.TFile) {
          const cache = app.metadataCache.getFileCache(file2);
          const headingCache = (_a2 = cache == null ? void 0 : cache.headings) == null ? void 0 : _a2.find((h) => {
            return h.position.start.line === startLine;
          });
          if (headingCache) {
          }
        }
      }
      const file = app.vault.getAbstractFileByPath(sourcePath);
      if (file instanceof import_obsidian56.TFile && sectionInfo) {
        const cache = app.metadataCache.getFileCache(file);
        const line = sectionInfo.lineStart;
        if (cache == null ? void 0 : cache.blocks) {
          for (const [id, block] of Object.entries(cache.blocks)) {
            if (block.position.start.line === line) {
              blockId = id;
              break;
            }
          }
        }
      }
      if (blockId) {
        const data = metadataMap[blockId] || {};
        renderMetadataPill(header, data);
      }
    });
  };
};
function renderMetadataPill(container, data) {
  if (container.querySelector(".header-metadata-container"))
    return;
  container.style.position = "relative";
  const score = typeof data[import_core29.HeaderMetadataKeys.Score] === "number" ? data[import_core29.HeaderMetadataKeys.Score] : 0;
  const importance = typeof data[import_core29.HeaderMetadataKeys.Importance] === "number" ? data[import_core29.HeaderMetadataKeys.Importance] : 1;
  const difficulty = typeof data[import_core29.HeaderMetadataKeys.Difficulty] === "number" ? data[import_core29.HeaderMetadataKeys.Difficulty] : 0;
  const pill = document.createElement("span");
  pill.addClass("header-metadata-container");
  let stars = Math.max(1, Math.min(5, Math.round(importance)));
  const impEl = document.createElement("span");
  impEl.addClass("hm-item", "hm-importance");
  impEl.setText("\u2605".repeat(stars));
  impEl.style.color = "#ffd700";
  impEl.style.fontSize = "18px";
  impEl.style.lineHeight = "1";
  impEl.style.textShadow = "0 0 1px #b8860b";
  impEl.title = `Importancia: ${importance}/5`;
  pill.appendChild(impEl);
  const normDiff = (0, import_core30.normalizeDifficulty)(difficulty);
  const diffColor = (0, import_core30.difficultyToColor)(normDiff);
  let diffText = "Baja";
  if (normDiff === 2)
    diffText = "Media";
  if (normDiff === 3)
    diffText = "Alta";
  const diffEl = document.createElement("span");
  diffEl.addClass("hm-item");
  diffEl.innerHTML = `<svg width="18" height="18" viewBox="0 0 18 18">
        <circle cx="9" cy="9" r="6" fill="${diffColor}" stroke="none" />
    </svg>`;
  diffEl.title = `Dificultad: ${diffText} (${normDiff}/3)`;
  const size = 18;
  const center = size / 2;
  const strokeWidth = 2.5;
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const scorePct = Math.min(10, Math.max(0, score));
  const offset = circumference - scorePct / 10 * circumference;
  let scoreColor = "#50fa7b";
  if (score < 5)
    scoreColor = "#ff5555";
  else if (score < 8)
    scoreColor = "#ffb86c";
  const scoreEl = document.createElement("span");
  scoreEl.addClass("hm-item", "hm-score-svg");
  scoreEl.title = `Nota: ${score}/10`;
  scoreEl.innerHTML = `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="transform: rotate(-90deg);">
        <!-- Background Circle -->
        <circle cx="${center}" cy="${center}" r="${radius}" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="${strokeWidth}" />
        <!-- Progress Circle -->
        <circle cx="${center}" cy="${center}" r="${radius}" fill="none" stroke="${scoreColor}" stroke-width="${strokeWidth}"
            stroke-dasharray="${circumference}"
            stroke-dashoffset="${offset}"
            stroke-linecap="round" />
        <!-- Text in center (un-rotated) -->
        <text x="50%" y="54%" text-anchor="middle" dy="0.3em" fill="var(--text-normal)"
            font-size="9" font-weight="bold" transform="rotate(90 ${center} ${center})">${Math.round(score)}</text>
    </svg>`;
  const attempts = typeof data[import_core29.HeaderMetadataKeys.Attempts] === "number" ? data[import_core29.HeaderMetadataKeys.Attempts] : 0;
  const attemptsEl = document.createElement("span");
  attemptsEl.addClass("hm-item");
  attemptsEl.style.textAlign = "right";
  attemptsEl.style.fontSize = "0.8em";
  attemptsEl.style.color = "var(--text-muted)";
  attemptsEl.setText(`${attempts}x`);
  attemptsEl.title = `Intentos: ${attempts}`;
  pill.appendChild(attemptsEl);
  pill.appendChild(scoreEl);
  container.style.position = "";
  container.appendChild(pill);
}

// src/Infrastructure/Adapters/ObsidianHeaderDataRepository.ts
var ObsidianHeaderDataRepository = class {
  constructor(app) {
    this.app = app;
  }
  async getHeaderData(filePath) {
    const jsonPath = this.getJsonPath(filePath);
    if (await this.exists(jsonPath)) {
      try {
        const content = await this.app.vault.adapter.read(jsonPath);
        return JSON.parse(content);
      } catch (e) {
        console.warn(`[HeaderDataRepository] Failed to parse JSON at ${jsonPath}`, e);
      }
    }
    return {};
  }
  async getHeaderProgress(filePath) {
    const jsonPath = this.getJsonPath(filePath);
    if (await this.exists(jsonPath)) {
      try {
        const content = await this.app.vault.adapter.read(jsonPath);
        const data = JSON.parse(content);
        if (data && data.progress && typeof data.progress === "object") {
          return data.progress;
        }
      } catch (e) {
        console.warn(`[HeaderDataRepository] Failed to read progress from ${jsonPath}`, e);
      }
    }
    return {};
  }
  async exists(filePath) {
    return this.app.vault.adapter.exists(filePath);
  }
  getJsonPath(sourcePath) {
    return sourcePath.replace(/\.md$/, ".json");
  }
};

// src/Application/Services/HeaderDataService.ts
var HeaderDataService = class {
  constructor(repository) {
    this.repository = repository;
  }
  async getHeaderData(filePath) {
    return this.repository.getHeaderData(filePath);
  }
  async getHeaderProgress(filePath) {
    return this.repository.getHeaderProgress(filePath);
  }
  findMissingHeaders(progress, currentHeaders) {
    const normalizedHeaders = new Set(currentHeaders.map((h) => h.trim()));
    const jsonKeys = Object.keys(progress);
    return jsonKeys.filter((key) => !normalizedHeaders.has(key));
  }
};

// src/Infrastructure/Obsidian/Services/ImageEnricherService.ts
var ImageEnricherService = class {
  constructor(imageSearch) {
    this.imageSearch = imageSearch;
  }
  /**
   * Searches for images for a given query and returns them.
   * Handles UI feedback (messages) for starting search, success, and failure.
   * 
   * @param query The search query (usually file basename)
   * @param maxResults Number of images to fetch
   * @returns Array of image URLs
   */
  async searchImages(query, maxResults = 3) {
    showMessage(`Buscando im\xE1genes para: ${query}...`);
    try {
      const images = await this.imageSearch.searchImages(query, maxResults);
      const uniqueImages = [...new Set(images)];
      if (uniqueImages.length === 0) {
        showMessage("No se encontraron im\xE1genes.");
        return [];
      }
      showMessage(`Se encontraron ${uniqueImages.length} im\xE1genes.`);
      return uniqueImages;
    } catch (error) {
      console.error("Error searching images:", error);
      showMessage("Error al buscar im\xE1genes.");
      return [];
    }
  }
};

// src/Infrastructure/Obsidian/Services/FrontmatterEventService.ts
var import_obsidian57 = require("obsidian");
var import_core31 = __toESM(require_dist());
var FrontmatterEventService = class {
  constructor(app) {
    this.previousFrontmatter = {};
    this.app = app;
    this.registerEvents();
  }
  registerEvents() {
    this.app.metadataCache.on("changed", async (file) => {
      await this.handleMetadataChange(file);
    });
  }
  async handleMetadataChange(file) {
    if (!file || file.extension !== "md")
      return;
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache || !cache.frontmatter)
      return;
    const currentFrontmatter = cache.frontmatter;
    const filePath = file.path;
    if (!this.previousFrontmatter[filePath]) {
      this.previousFrontmatter[filePath] = { ...currentFrontmatter };
      return;
    }
    const previous = this.previousFrontmatter[filePath];
    for (const key of Object.keys(import_core31.FrontmatterRegistry)) {
      const fieldConfig = import_core31.FrontmatterRegistry[key];
      if (!fieldConfig.commands || fieldConfig.commands.length === 0)
        continue;
      const currentValue = currentFrontmatter[fieldConfig.key];
      const previousValue = previous[fieldConfig.key];
      if (JSON.stringify(currentValue) !== JSON.stringify(previousValue)) {
        for (const commandId of fieldConfig.commands) {
          this.executeCommand(commandId);
        }
      }
    }
    this.previousFrontmatter[filePath] = { ...currentFrontmatter };
  }
  async executeCommand(commandId) {
    let finalCommandId = commandId;
    let command = this.app.commands.findCommand(finalCommandId);
    if (!command && !commandId.includes(":")) {
      finalCommandId = `elocuency:${commandId}`;
      command = this.app.commands.findCommand(finalCommandId);
    }
    if (command) {
      try {
        if (command.callback) {
          await command.callback();
        } else if (command.editorCallback) {
          const activeView = this.app.workspace.getActiveViewOfType(import_obsidian57.MarkdownView);
          if (activeView) {
            await command.editorCallback(activeView.editor, activeView);
          } else {
            console.warn(`[FrontmatterEventService] Skipping editor command ${finalCommandId} because no active MarkdownView.`);
          }
        } else if (command.checkCallback) {
          await command.checkCallback(false);
        } else {
          this.app.commands.executeCommandById(finalCommandId);
        }
      } catch (e) {
        console.error(`[FrontmatterEventService] Error executing command ${finalCommandId}:`, e);
      }
    } else {
      console.warn(`[FrontmatterEventService] Command '${commandId}' (or '${finalCommandId}') not found.`);
    }
  }
};

// src/Infrastructure/Obsidian/Services/BridgeService.ts
var import_child_process2 = require("child_process");
var BridgeService = class {
  constructor(settings) {
    this.photosBridgeProcess = null;
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async startBridge(force = false) {
    var _a2, _b;
    if (this.photosBridgeProcess) {
      showMessage("PhotosBridge ya est\xE1 ejecut\xE1ndose.");
      return;
    }
    const executable = this.settings.photosBridgePath;
    if (!executable) {
      showMessage("Ruta de PhotosBridge no configurada.");
      return;
    }
    console.log(`Starting PhotosBridge at ${executable}...`);
    try {
      this.photosBridgeProcess = (0, import_child_process2.spawn)(executable, [], {
        detached: false,
        stdio: ["ignore", "pipe", "pipe"]
      });
      (_a2 = this.photosBridgeProcess.stdout) == null ? void 0 : _a2.on("data", (data) => {
        console.log(`[PhotosBridge] ${data}`);
      });
      (_b = this.photosBridgeProcess.stderr) == null ? void 0 : _b.on("data", (data) => {
        console.error(`[PhotosBridge] ${data}`);
        if (data.toString().includes("Address already in use")) {
          console.log("[PhotosBridge] Port busy, assuming external bridge is active.");
        }
      });
      this.photosBridgeProcess.on("error", (err) => {
        console.error("PhotosBridge failed to start:", err);
        showMessage("Error al iniciar PhotosBridge (Native)");
        this.photosBridgeProcess = null;
      });
      this.photosBridgeProcess.on("exit", (code) => {
        console.log(`PhotosBridge exited with code ${code}`);
        this.photosBridgeProcess = null;
      });
      this.photosBridgeProcess.unref();
      console.log("PhotosBridge process spawned.");
      showMessage("PhotosBridge iniciado.");
    } catch (e) {
      console.error("Exception starting PhotosBridge:", e);
      showMessage("Excepci\xF3n al iniciar Bridge.");
    }
  }
  stopBridge() {
    if (this.photosBridgeProcess) {
      console.log("Stopping PhotosBridge...");
      this.photosBridgeProcess.kill();
      this.photosBridgeProcess = null;
      showMessage("PhotosBridge detenido.");
    } else {
      showMessage("PhotosBridge no estaba corriendo.");
    }
  }
  isRunning() {
    return this.photosBridgeProcess !== null;
  }
  async upsertContact(data) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15e3);
      const response = await fetch("http://localhost:27345/contact", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`Bridge Error: ${response.statusText}`);
      }
      return await response.json();
    } catch (e) {
      console.error("Failed to upsert contact:", e);
      throw e;
    }
  }
  async searchContacts(query) {
    try {
      const response = await fetch(`http://localhost:27345/contacts?query=${encodeURIComponent(query)}`);
      if (!response.ok) {
        throw new Error(`Bridge Error: ${response.statusText}`);
      }
      return await response.json();
    } catch (e) {
      console.error("Failed to search contacts:", e);
      return [];
    }
  }
};

// src/Infrastructure/Obsidian/main.ts
var ObsidianExtension = class extends import_obsidian58.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    // Registry of commands to be shared with NoteOperationsView
    this.noteCommands = [];
    this.lastActiveMarkdownFile = null;
  }
  getLastActiveMarkdownFile() {
    return this.lastActiveMarkdownFile;
  }
  async onload() {
    var _a2, _b, _c, _d, _e;
    console.log(`Elocuency plugin loaded ${this.manifest.version}`);
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && activeFile.extension === "md") {
      this.lastActiveMarkdownFile = activeFile;
    }
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if ((leaf == null ? void 0 : leaf.view) instanceof import_obsidian58.MarkdownView) {
          this.lastActiveMarkdownFile = leaf.view.file;
        }
      })
    );
    await this.loadSettings();
    this.llm = new import_core33.GoogleGeminiAdapter((_a2 = this.settings.geminiApiKey) != null ? _a2 : "");
    const geocoder = new GoogleMapsAdapter(
      (_b = this.settings.googleGeocodingAPIKey) != null ? _b : "",
      this.app
    );
    const geminiImages = new import_core34.GoogleGeminiImagesAdapter((_c = this.settings.geminiApiKey) != null ? _c : "");
    const imageSearch = new GoogleImageSearchAdapter(
      (_d = this.settings.googleCustomSearchApiKey) != null ? _d : "",
      (_e = this.settings.googleCustomSearchEngineId) != null ? _e : ""
    );
    const imageEnricher = new ImageEnricherService(imageSearch);
    this.spotifyAdapter = new SpotifyAdapter(
      this.settings.spotifyClientId,
      this.settings.spotifyAccessToken,
      this.settings.spotifyRefreshToken,
      this.settings.spotifyTokenExpirationTime,
      async (newToken, newExpiration) => {
        this.settings.spotifyAccessToken = newToken;
        this.settings.spotifyTokenExpirationTime = newExpiration;
        await this.saveSettings();
      },
      () => {
        showMessage("Spotify token expired. Please re-login.");
        new SpotifyAuthModal(this.app, this.musicService).open();
      }
    );
    const settingsAdapter = new ObsidianSettingsAdapter(this);
    this.musicService = new MusicService(this.spotifyAdapter, settingsAdapter);
    this.bridgeService = new BridgeService(this.settings);
    new FrontmatterEventService(this.app);
    if (this.settings.hideEmptyProperties) {
      document.body.classList.add("hide-empty-properties");
    }
    this.noteCommands = [
      {
        id: import_core32.CommandEnum.ApplyTemplate,
        name: "Plantilla: Aplica plantilla",
        callback: async (file) => {
          const applyTemplateCommand = new ApplyTemplateCommand(
            this.llm,
            imageEnricher,
            this.app,
            this.settings
          );
          await applyTemplateCommand.execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.ApplyTemplateWithUrl,
        name: "Plantilla: Aplica plantilla con URL",
        callback: async (file) => {
          const command = new ApplyTemplateWithUrlCommand(
            this.llm,
            imageEnricher,
            this.app,
            this.settings
          );
          await command.execute(file);
        }
      },
      // {
      //   id: CommandEnum.ApplyStreamBrief,
      //   name: 'Nota: Aade resumen',
      //   callback: async (file?: TFile) => {
      //     const applyStreamBriefCommand = new ApplyStreamBriefCommand(
      //       this.llm,
      //       this.app,
      //     );
      //     await applyStreamBriefCommand.execute(file);
      //   },
      // },
      {
        id: import_core32.CommandEnum.EnhanceByAi,
        name: "IA: Enriquece con IA",
        callback: async (file) => {
          await new EnhanceByAiCommand(this.app, this.settings, this.llm).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.EnrichWithPromptUrl,
        name: "IA: Enriquecer con url [EnrichWithPromptUrlCommand]",
        callback: async (file) => {
          await new EnrichWithPromptUrlCommand(this.llm, imageEnricher, this.app, this.settings).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.AddImages,
        name: "Imagenes: A\xF1ade im\xE1genes [AddImagesCommand]",
        callback: async (file) => {
          await new AddImagesCommand(this.app, imageEnricher).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.CreateNoteFromImages,
        name: "Imagenes: Crea nota a partir de im\xE1genes [CreateNoteFromImagesCommand]",
        callback: async (file) => {
          await new CreateNoteFromImagesCommand(this.app, geminiImages).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.ApplyTemplateFromImage,
        name: "Imagenes: Aplica plantilla a partir de im\xE1genes [ApplyTemplateFromImageCommand]",
        callback: async (file) => {
          await new ApplyTemplateFromImageCommand(geminiImages, this.app, this.settings).execute(file);
        }
      },
      // {
      //   id: CommandEnum.GenerateHeaderMetadata,
      //   name: 'Nota: Genera metadatos de encabezado',
      //   callback: async (file?: TFile) => {
      //     await new GenerateHeaderMetadataCommand(this.app).execute(file);
      //   }
      // },
      {
        id: import_core32.CommandEnum.RelocateNoteByLinkField,
        name: "Reubica: [RelocateNoteByLinkFieldCommand]",
        callback: async (file) => {
          await new RelocateNoteByLinkFieldCommand(this.app).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.GenerateMissingNotesFromLinks,
        name: "Links: Create notas para links sin notas [GenerateMissingNotesFromLinksCommand]",
        callback: async (file) => {
          const generateMissingNotesCommand = new GenerateMissingNotesFromLinksCommand(
            this.app,
            this.settings
          );
          await generateMissingNotesCommand.execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.CreateReciprocityLinksNotes,
        name: "Links: Crea links reciprocos [CreateReciprocityLinksNotesCommand]",
        callback: async (file) => {
          await new CreateReciprocityLinksNotesCommand(this.app).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.AnalyzeAndLinkEntities,
        name: "Links: Analiza y enlaza entidades [AnalyzeAndLinkEntitiesCommand]",
        callback: async (file) => {
          await new AnalyzeAndLinkEntitiesCommand(this.app, this.llm).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.GenerateMissingNotesFromListField,
        name: "Links: Genera notas faltantes desde campo lista",
        callback: async (file) => {
          await new GenerateMissingNotesFromListFieldCommand(this.app, this.settings, this.llm, imageEnricher).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.EnrichPlace,
        name: "Lugares: Enriquece Nota",
        callback: async (file) => {
          await new EnrichPlaceCommand(geocoder, this.llm, this.app).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.RelocatePlaceNote,
        name: "Lugares: Reubica Nota",
        callback: async (file) => {
          await new RelocatePlaceNoteCommand(this.app).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.AddPlaceIdFromUrl,
        name: "Lugares: A\xF1adir Place Id desde URL",
        callback: async (file) => {
          await new AddPlaceIdFromUrlCommand(geocoder, this.llm, this.app).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.SearchSpotifyTrack,
        name: "Spotify: Busca canci\xF3n",
        callback: () => {
          this.spotifyAdapter.updateCredentials(this.settings.spotifyClientId, this.settings.spotifyAccessToken);
          if (!this.spotifyAdapter.isAuthenticated()) {
            new SpotifyAuthModal(this.app, this.musicService).open();
            return;
          }
          new SpotifyModal(this.app, this.musicService).open();
        }
      },
      {
        id: import_core32.CommandEnum.ImportPlaylistTracks,
        name: "Spotify: Importa canciones de playlist",
        callback: async () => {
          this.spotifyAdapter.updateCredentials(this.settings.spotifyClientId, this.settings.spotifyAccessToken);
          new ImportSpotifyPlaylistCommand(
            this.app,
            this.spotifyAdapter,
            this.musicService,
            () => new SpotifyAuthModal(this.app, this.musicService).open()
          ).checkCallback(false);
        }
      },
      {
        id: import_core32.CommandEnum.SearchSpotifyArtist,
        name: "Spotify: Busca artista",
        callback: () => {
          this.spotifyAdapter.updateCredentials(this.settings.spotifyClientId, this.settings.spotifyAccessToken);
          new SearchSpotifyArtistCommand(
            this.app,
            this.spotifyAdapter,
            () => new SpotifyAuthModal(this.app, this.musicService).open()
          ).checkCallback(false);
        }
      },
      {
        id: import_core32.CommandEnum.InsertLinkToSelectedPhoto,
        name: "Photos: Insertar Link a Foto Seleccionada",
        callback: async (file) => {
          await new InsertLinkToSelectedPhotoCommand(this.app).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.OpenLinkedPhoto,
        name: "Photos: Abrir Foto Enlazada",
        callback: async (file) => {
          await new OpenLinkedPhotoCommand(this.app).execute(file);
        }
      },
      {
        id: import_core32.CommandEnum.SyncContacts,
        name: "Contactos: Sincronizar Personas [SyncCurrentContactCommand]",
        callback: async (file) => {
          await new SyncCurrentContactCommand(this.app, this.bridgeService).execute(file);
        }
      },
      {
        id: "elo-sync-google-contacts",
        // Using explicit ID as it's not in Enum yet, or update Enum.
        name: "Contactos: Sincronizar Nota Activa con Google [SyncGoogleContactsCommand]",
        callback: async (file) => {
          await new SyncGoogleContactsCommand(this.app, this).execute(file);
        }
      },
      {
        id: "elo-process-unsynced-google-contacts",
        name: "Contactos: Procesar No Sincronizados de Google [ProcessUnsyncedGoogleContactsCommand]",
        callback: async () => {
          await new ProcessUnsyncedGoogleContactsCommand(this.app, this).execute();
        }
      },
      {
        id: "elo-import-keep-takeout",
        name: "Google Keep: Importar desde Takeout",
        callback: async () => {
          await new ImportKeepTakeoutCommand(this.app).execute();
        }
      },
      {
        id: "elo-natural-language-search",
        name: "B\xFAsqueda: Lenguaje Natural [NaturalLanguageSearchCommand]",
        callback: async () => {
          await new NaturalLanguageSearchCommand(this.app, this.llm).execute();
        }
      },
      // {
      //   id: 'open-chat-session',
      //   name: 'Chat: Abre sesin',
      //   callback: () => {
      //     this.activateView();
      //   }
      // },
      {
        id: "start-bridge",
        name: "Bridge: Iniciar Bridge (Manual)",
        callback: () => {
          this.bridgeService.startBridge(true);
        }
      },
      {
        id: import_core32.CommandEnum.TokenizeAndCreateDictionaryNotes,
        name: "Diccionario: Tokenizar y crear notas [TokenizeAndCreateDictionaryNotesCommand]",
        callback: async (file) => {
          await new TokenizeAndCreateDictionaryNotesCommand(this.app, this.settings).execute(file);
        }
      },
      {
        id: "elo-download-subtitles",
        name: "Series: Descargar Subt\xEDtulos [DownloadSubtitlesCommand]",
        callback: async (file) => {
          var _a3;
          const commandObj = new DownloadSubtitlesCommand(this).getCommand();
          const editor = (_a3 = this.app.workspace.activeEditor) == null ? void 0 : _a3.editor;
          const leaf = this.app.workspace.getLeavesOfType("markdown")[0];
          const view = leaf == null ? void 0 : leaf.view;
          if (editor && view && commandObj.editorCallback) {
            await commandObj.editorCallback(editor, view);
          }
        }
      },
      {
        id: import_core32.CommandEnum.ToggleHideEmptyProperties,
        name: "Propiedades: Ocultar/Mostrar propiedades vac\xEDas",
        callback: async () => {
          this.settings.hideEmptyProperties = !this.settings.hideEmptyProperties;
          await this.saveSettings();
          document.body.classList.toggle("hide-empty-properties", this.settings.hideEmptyProperties);
          const status = this.settings.hideEmptyProperties ? "ocultas" : "visibles";
          showMessage(`Propiedades vac\xEDas ${status}`);
        }
      },
      {
        id: "stop-bridge",
        name: "Bridge: Detener Bridge",
        callback: () => {
          this.bridgeService.stopBridge();
        }
      }
    ];
    this.noteCommands.forEach((cmd) => {
      this.addCommand({
        id: cmd.id,
        name: cmd.name,
        callback: cmd.callback
      });
    });
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        if (file instanceof import_obsidian58.TFile) {
          new MetadataService(this.app).handleRename(file, oldPath);
        }
      })
    );
    this.addSettingTab(new SettingsView(this.app, this));
    registerImageGalleryRenderer(this);
    registerSpotifyRenderer(this);
    registerGoogleMapsRenderer(this);
    const headerDataRepo = new ObsidianHeaderDataRepository(this.app);
    const headerDataService = new HeaderDataService(headerDataRepo);
    this.registerMarkdownPostProcessor(createHeaderProgressRenderer(this.app, headerDataService));
    this.registerMarkdownPostProcessor(createHeaderMetadataRenderer(this.app, headerDataService));
    this.registerView(
      VIEW_TYPE_CHAT,
      (leaf) => {
        const view = new ChatView(leaf);
        view.setPlugin(this);
        return view;
      }
    );
    this.registerView(
      VIEW_TYPE_NOTE_OPERATIONS,
      (leaf) => new NoteOperationsView(leaf, this)
    );
    this.addRibbonIcon("message-circle", "Chat Session", () => {
      this.activateView();
    });
    this.addRibbonIcon("microphone", "Note Operations", () => {
      this.activateNoteOperationsView();
    });
    if (import_obsidian58.Platform.isDesktop && this.settings.autoStartBridge) {
      this.bridgeService.startBridge();
    }
  }
  onunload() {
    console.log("Elocuency plugin unloaded");
    this.bridgeService.stopBridge();
  }
  async loadSettings() {
    const data = await this.loadData();
    const merged = Object.assign({}, DEFAULT_SETTINGS, data);
    this.settings = merged;
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.bridgeService) {
      this.bridgeService.updateSettings(this.settings);
    }
  }
  getNoteCommands() {
    return this.noteCommands;
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_CHAT)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({
          type: VIEW_TYPE_CHAT,
          active: true
        });
        leaf = workspace.getLeavesOfType(VIEW_TYPE_CHAT)[0];
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async activateNoteOperationsView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_NOTE_OPERATIONS)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({
          type: VIEW_TYPE_NOTE_OPERATIONS,
          active: true
        });
        leaf = workspace.getLeavesOfType(VIEW_TYPE_NOTE_OPERATIONS)[0];
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
/*! Bundled license information:

@google/genai/dist/web/index.mjs:
  (**
   * @license
   * Copyright 2025 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
